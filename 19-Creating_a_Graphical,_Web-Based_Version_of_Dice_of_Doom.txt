CREATING A GRAPHICAL, WEB-BASED VERSION OF DICE OF DOOM
19장.GRAPHICAL하며 웹 기반의 DICE OF DOOM version 만들기

 이전 장에서, 저희는 커다란 게임 보드에서 동작하는 Dice of Doom의 두번째 버전을 만들었습니다. 부족한crude 콘솔 인터페이스를 이용하기 때문에, 보드를 이해하고 moves 하는 것은 매우 어렵습니다. moves를 하여 가기 원하는 곳을 단순하게 클릭할 수 있는 매우 grapical 한 게임 보드를 가진다면, 틀림없이, Dice of Doom은 궁극적으로 나아질 것입니다. 흠, 저는 여러분을 위한 좋은 소식을 가지고 있습니다. . .


 이번 장에서, 저희는 이전장의 많은 코드를 한데모아 웹 브라우저 안에서 곧 바로 플레이 할 수 있는 모든-기능이있으며, graphical한 Dice of Doom게임으로 변형시킬 것입니다!


Drawing the Game Board Using the SVG Format
 저희는 이미 13장에서 초기 단계의 웹 서버를 작성했습니다. 또한, 저희는 17장에서 어떻게 SVG 그래픽을 그리는지도 다루었습니다. 다행스럽게도, HTML5 표준은 내장 SVG 그림들을 직접 표준 HTML 문서에 넣는 기능을 포함하였습니다. 이 방식으로, 저희는  완전하게 상호작용하는 vector graphic를 제공하는 단순하며 작은 웹 서버를 이용할 수 있게 되었습니다. 여러분은 이것이 얼마나 쉬운지에 놀라게 될 것입니다.

NOTE
 이 책이 쓰여질 때에는, HTML로 작성된 inline SVG를 지원하는 웹 브라우저는 Firefox 3.7 Alpha 였습니다. 새로운 Dice of Doom version을 이와 혹은 Firefox의 최신 release와 함께 사용합니다. 문제가 있다면, Firefox 주소 창에 about:config를 뒤저, html5.enable 환경 설정을 true로 바꾸도록 해보시기 바랍니다. 이는 Firefox가 최신 HTML 설정을 허용하게 해줍니다.
 또한 여러분의 웹 서버 라이브러리가 순수 ANSI Common Lisp가 아니라 CLISP에-특화된 확장을 이용했다는 것을 명심하시기 바랍니다

 우선 저희는 다른 장에서 이미 얻은 다양한 코드를 끌어올것입니다. 이전 장에서 저희는 Dice of Doom version 2의 엔진을 만들었습니다. 그 장에서의 모든 코드를 파일 dice_of_doom_v2.lisp에 넣습니다. 또한 여러분은 이미 13장에서 webserver.lisp이란 파일을 만들었습니다. (이 파일들 모두 http://landoflisp.com/에서 자유롭게 이용가능합니다.)

 이 파일들을 로드해봅시다:
[REPL]

 SVG를 지원하기 위해, 16과 17장에서 SVG를-다루는 코드가 필요합니다. 그러한 함수들을 svg.lisp에 넣습니다. (이 파일도 또한 http://landoflisp.com/에서 이용가능합니다.) 참고로, 저희가 필요한 함수들은 let1, split, pairs, print-tag, tag, svg, brightness, svg-style, polygon 입니다.

 이 파일들을 로드합니다:
[REPL]

 이제 SVG를 이용하여 게임 보드를 멋지게 그리는 version의 코드를 작성합시다. 우선, 저희는 보드를 그리기 위해 필요한 다양한 면적을 다룰 몇몇 상수를 정의해야 합니다:
[CODE]

 보드 넓이와 높이는 대다수의 컴퓨터 화면에서 브라우저에서 게임하기에 적당한 크기인 900x500 픽셀이 될 것입니다. board scale은 화면 픽셀에 대한 하나의 6각형의 넓이의 반을 나타냅니다. *top-offset* 변수는 기본 보드위에 추가 6각형 높이의 여분공간이 필요하다고 말해줍니다. 6각형 위로 쌓아 올려지게될 많은 주사위 가지게 될 것이므로 이러한 것들이 필요할 것이며, 화면에 이러한 주사위들이 보여지도록 할 공간이 필요합니다. *dice-scale* 변수는 주사위 하나가 화면에서 40 픽셀만큼 크고 넓다고 말해줍니다. 마지막으로, *dot-size*를 0.05로 설정하며, 이는 각 점이 주사위의 0.05배의 크기로 될거라 말해줍니다.


Drawing a Die
 이제  저희는 주사위를 그리는 함수를 작성할 준비가 되었습니다. 저희는 그림을 그리기 위해 비트맵이나 그와 같은 어떠한 것도 이용하지 않을 것입니다. 대신, 저희는 raw SVG 폴리곤을 직접적으로 다룸으로써  주사위를  "어려운 방식으로" 그릴 것입니다. 여기 코드가 있습니다:
[CODE]

 주사위를 그리기 위해, 저희는 3가지 인자를 넣어야 합니다. 처음 두개는 SVG 그림에서 주사위가 보여질 x, y 위치입니다. 세번째 인자는 주사위의 color 입니다. 이 함수는 color에 대해 자유를 가질 것이며, 주사위에 약간의 그림자를 주기 위해 필요하다면 이를 수정합니다.

 이 함수에서 어떠한 것을 그리는 것은, 저희가 정의한 *dice-scale*에 기반한 scaled 방식으로 다뤄져야합니다. 그러므로, 저희는 우선 point를 scale하는 지역 함수 calc-pt를 정의하였습니다. 몇몇 scaled polygons을 그려야 하기에, polygon에 있는 모든 point에 대한 calc-pt를 돌리는 편리한 함수 f를 만들것이며, polygon 함수를 호출하여 이를 그릴 것입니다.

 저희 그림에서 주사위는 세개의 보여지는 면이 있습니다 : 상단, 앞면, 우측 면. 3개의 면을 위해 하드-코딩된 좌표계를 이용하여 여기서 시작되는 함수 f를 3번 호출함으로써 이러한 것을 그립니다.

 저희가 해야할 마지막 일은 주사위 표면에 작은 점을 그리는 것입니다. 점의 좌표에 점을 다룰 수 있는lambda 함수를 mapcing함으로 이러한 일을 합니다. 이 lambda 함수는 주사위 면의 각 점을 표현하는 사각형의 polygon의 비율을 축소하기 위해 *dot-size* 변수를 이용합니다. 원형과 타원의 점을 그리기 위해선 더욱 세세한 코드를 작성해야 하지만, 점이 매우 작기에 사각형이라도 보기엔 괜찮습니다.

 RGB 빨강의 색상인 (255 0 0) 주사위를 x=50, y=50에 그려봅시다:
[REPL]

 최종 주사위가 어떻게 보여지는지를 확인하고자 한다면, 이 까다로운 것을 die.svg에 저장합니다. 그리고 다음 그림을 보여주는 Firefox에서 그 결과를 불러옵니다(과장된 크기로 보여졌습니다):
[PIC]


Drawing a Tile
 다음으로, tile에 있는 base와 주사위를 포함하는 전체 6각 tile을 그리는 함수를 작성해 봅시다:
[CODE]

  이 함수는 많은 정보가 보드의 단일 tile에 encoded되었기에 많은 인자를 취합니다. 다음 section에서 보드를 그릴시 이 인자들의 각각의 정확한 의미를 배울 것입니다.

 우선, darw-tile-svg 함수는 base를 그립니다. base를 mild한 3D처럼 보이도록 하기 위해, 다른 하나 위에 한층 쌓아올려 이를 두번 그릴 것입니다. 여기가(_1_) 두 base를 그리는 loop입니다. 저 loop로, 6각 polygon을 그려야 합니다. 좌표에 대해 scaling 함수를 map하므로 *board-scale* 변수로 scaled됩니다. 여기서(_3_3) 여러분은 10진법을 이용하여 부호화된 원근화된 6각형의 6개의 point를 볼 수 있습니다. 플레이어가 move를 수행하기 위해 선택되면 기본 색은 조금 밝아질 것입니다. polygon을 생성할때 tile의 밝기를 증가시킴으로써 이를 할 수 있습니다.

 tile base를 그린후에, tile에 거주하는 주사위를 그려야 합니다. 주사위 수만큼 loop하여 이를 수행하며, darw-die-svg 함수를 호출합니다. 주사위의 x와 y 지점을 계산할때, 약간의 scaling math를 수행해야 합니다. 이 math에서 가장 흥미로운 것은, 주어진 주사위의 x-, y-, z-좌표의 합이 홀수인지 짝수인지에 따라, 주사위가 우측이나 좌측으로 옮겨지는 것입니다. 이는 스택을 조금 부족하게 만들며, 완성된 보드의 싸여진 주사위가 만족스럽고 자연스러운 모습을 지니게 됩니다.

 이제 완성된 tile을 그리기 위해 함수를 호출하여 어떻게 보여지는지 봅시다. 다시, 이 명령어로부터 나온 결과물을 tile.svg와 같은 파일로 저장합니다.
[REPL]

 여기 Firefox에서 보여지는 파일이 있습니다:
[PIC]


Drawing the Board
 이제 저희는 전체 게임 보드를 SVG로 그리는 함수를 작성할 준비가 되었습니다. 이는 콘솔로 보드를 그리는데 이용했던 draw-board함수와 매우 비슷합니다. 이는 동일한 규칙을 준수하지만, 단순히 결과만 SVG 데이터로 출력합니다.
[CODE]

 draw-board-svg 함수는 보드를 인자로 취하며, 또한 저희 게임 사용자 인터페이스의 front end인 그림을 이용하는데 중요한 두개의 다른 인자를 필요로 합니다. 하나의 인자는 플레이어가 마우스로 클릭한 타일을 나타내는 chosen-tile 입니다. tile을 조금 밝은 색으로 할 것이며, 플레이어가 컴퓨터에게 선택을 인지하도록 할 것입니다. 또다른 인자는 플레이어가 다음에 적법하게 클릭할수 있는 tile을 나타내는 legal-tiles입니다.

 우연히도 SVG 그림은 regula HTML의 하이퍼링크 <a href="...">처럼 동작하는 웹 링크를 지니는 기법을 가졌습니다. tile이 플레이어의 다음 move에 대한 적법한 tile이라면, 링크처럼 클릭가능하도록 타일을 SVG로 감쌀 것입니다. legal-tiles 인자를 가지므로써, 어떤 타일이 클릭할 수 있는지 알 수 있습니다.

 draw-board-svg 함수는 타일 보드의 y와 x 좌표를 통한 몇몇 중첩된 루프로 이루어졌습니다. 각 타일에 대해 (10장에서 소개된 loop 매크로의 지역 변수를 위한 기능을 이용하여) 매우 많은 지역 변수들을 정의합니다. 우선, 저희는 hex 배열에 있는 현재 타일의 위치를 나타내는 pos를 선언하였습니다. 그런 다음 그 hex를 불러옵니다. 다음, xx와 yy변수에 있는 타일의 pixel 좌표를 계산합니다. 보시다시피, 보드가 화면에서 원근법을 도입하기에, 이 좌표들을 위한 math는 조금 까다롭습니다.

 저희가 정의하는 마지막 지역 변수는 현재 지점에 있는 타일과 주사위의 색상을 담을 col입니다. 현재 색상 (플레이어 A를 위한)red와 (플레이어 B를 위한)blue를 담은, 주사위 색상 리스트를 이용하여 이를 수행합니다. 또한 (17장에서 다룬) brightness 함수를 이용하여 색상을  y-좌표에 기반하여 조금 어둡게 합니다. SVG 게임 보드의 3D 모양을 추가하기위해, 이는 뒤에 있는 rows를 조금 어둡게 합니다

 현재 tile이 적법한 tile이라면, 이전에 언급한대로 이를 웹 링크로 감쌈니다. SVG에서 이는 <a xlink:href="..."> 형식의 태그로 수행됩니다. 각 타일을  SVG renderer에게 이 tile에 있는 polygon들을 그룹으로 다루어야 한다고 말하는 <g>태그로 감쌌습니다. 링크하기 원하는 실제 URL을 계산하기위해, make-game-link 함수를 호출합니다. 이 함수는 적절한 URL을 생성합니다. 웹 게임 서버를 다루는 코드를 작성하기 시작하면 URL의 형식을 보다 잘 이해할 것입니다.

 드디어, 저희는 draw-tile 함수를 호출할 준비가 되었습니다. 저희 코드에는 두가지 다른 버전의 호출이 있습니다: 하나는 하이퍼링크 version 이며 하나는 링크가 없는 version입니다.

 휴! 이제 저희는 SVG format을 이용하여 최종적으로 전체 게임 보드를 다이나믹하게 그릴 수 있게 되었습니다:
[REPL]

 이것은, 결과물을 board.svg로 저장하고 이를 Firefox에서 로드한다면, 여러분이 보게될 것입니다:
[PIC]


Building the Web Server Interface
 이제 저희는 Dice of Doom version 3의 그래픽적인 면을 완성했으며, 웹 서버와 교류interface with하는 면을 작성할 준비가 되었습니다.


Writing Our Web Request Handler
 저희 웹 서버를 다루는 central 함수는 dod-request-handler입니다. 이는 웹 서버 라이브러리의 serve 명령어를 받을 수 있는 함수이며, 웹 브라우저에서 오는 모든 웹 requests들을 책임저야 합니다. 여기 dod-request-handler의 코드가 있습니다:
[CODE]

 우선 이 함수는 웹 서버로부터 계산계산된 현재 페이지가 game.html인지 확인합니다. 이는 저희 게임이 웹 서버에서 거주하게될 페이지 입니다. 페이지의 상단에, doctype을 명시하였습니다. 이러한 방식으로 하면, 이는 웹 브라우저에게 HTML5-encoded 웹 페이지를 제외하라고 말합니다. 그런 다음, 단순한 HTML을 페이지의 중앙에 놓고 환명 메시지를 출력합니다.

 웹 서버 라이브러리로 통과되는 param들은 이 라인(_4_)을 이용하여 계산한 chosen이란 이름의 중요한 값을 포함하고 있습니다. 선택된 tile이 없거나, 현재 게임 트리가 비었다면, 이는 플레이어가 brand-new 게임을 시작해야 한다는 것을 의미합니다. 이러한 경우, web-initialize 함수를 호출할 것입니다.

 다음으로, 게임이 끝났는지 밝혀야 합니다. moves의 리스트가 비어있는지 검사하여 이를 알 수있습니다. (기억컨데, 이는 트리의 caddr 장소에 저장되었습니다) 이러한 경우, 승자를 발표할 것입니다.

 그 다음, 현재 플레이어가 인간 플레이어라는 것을 의미하는 player 0인지 확인해야 합니다. 이러한 경우엔, 이 페이지의 body에  HTML 데이터의 나머지를 생성하기 위해
web-handle-human 함수를 호출 할 것입니다. 또한 chosen 인자가 존재한다면 선택된 tile의 번호를 가져오기 위해 read-from-string 함수를 이용합니다.

 다른 경우에는, 컴퓨터 플레이어를 다룬다는것을 알게되며, HTML의 나머지를 생성하기 위해 web-handle-computer를 다루도록 넘겨줍니다.

 마지막으로, dod-request-handler 함수는, 게임 보드를 그리기 위해 draw-dod-page 함수를 호출해야 합니다


Limitations of Our Game Web Server
 저희 웹 게임 서버의 한계는 매우 중대significant합니다. 무엇보다도 단편함의 목적으로, dod-request-hanlder 함수는 web request가 누구로부터 왔는지를 판별하는데 어떠한 노력도 하지 않습니다. 이는 모든 게임 상호작용이 단일 플레이어로부터 오는 것 처럼 행동하며, 따라서 이는 Dice of Doom의 멀티플레이어 서버가 아닙니다. 다수의 플레이어가 동시에 다른 게임을 플레이 하고자 한다면, dod-request-handler는 혼란을 느낄 것이며 나쁜 일이 벌어질 것입니다.

 multiple, paralled 게임을 위한 실제 웹서버로 dod-request-handler를 확장시키는것이 너무 어려워서 할 수 없는것은 아닙니다. 이를 하기 위해선, session 정보를 header data로부터 끌어와서 웹 서버의 인자로 받아, 이를 참조하는 (예를들어, *cur-game-tree*와 같은) 모든 변수들을 session 정보를 키로 이용하여 해쉬 테이블에서 살도록 해야합니다. 이러한 방식으로, 각 플레이어는 자신만의 게임 트리를 가질 것이며, 저희 엔진은 공평하게 multiple 게임을 서비스 할 수 있게 됩니다. 이와 같은 dod-request-handler의 multigame version의 구현은 "독자를 위한 연습문제"입니다.

 또다른 dod-request-handler의 한계는 read-from-string 함수를 이용하여 URL로부터 정보를 읽는다는 것입니다. 이전 장에서 배웠듯이, 이 함수는, 숙련된(그리고 악의적인) Lisper의 손에서 잠재적인 코드가 실행으로 위태로워질 수 있습니다.


Initializing a New Game
 여기, brand-new Dice of Doom 게임을 시작하는, 게임 엔진을 초기화시키는 web-initialize함수가 있습니다:
[CODE]

 보시다시피, 이는 무작위 게임 보드를 생성하고, 이로부터 트리를 만들어내며, 결과를 전역 변수 *cur-game-tree*에 저장합니다.


Announcing a Winner
 여기 웹 브라우저로 승자를 알리는 함수가 있습니다:
[CODE]

 이는, 웹 링크를 를 생성하기 위해 끝부분에, 현재 게임이 끝났기에 알맞게 brand-new 게임을 시작하는, 여분 코드를 추가하였다는 점을 제외하면 이전 announce-winner 함수와 완전히 동일합니다.


Handling the Human Player
 web-handle-human는 HTML을 생성하며, 현재 턴을 취한 플레이어가 인간 플레이어일때 기록하는걸 담당합니다.
[CODE]

 인간의 최근 선택은 이 함수가 무얼할지를 나타냅니다. web-handle-human함수는 최근 선택 위치를 참조하여, 웹 request를 통해 인자처럼 넘겨진 변수에서 얻어 인간의 선택을 앎니다. 이는 또한 move를 위한 시작지점으로 이용하기 위해 플레이어가 초기에 선택한 tile이 어느것인지 말해주는 *from-tile 전역 변수를 참조할 수 있습니다. move가 시작 지점과 목적지 지점을 가지기에, 이는 이 값들을 모두 필요로 합니다.

 플레이어가 아직 지점을 선택하지 않았다면, the player choose a hex라는 요청 메시지를 출력할 것입니다. 플레이어가 pass를 선택하였다면, player’s reinforcements have been placed 라는 메시지를 출력할 것입니다. (reinforcements는 누군가가 pass한후에 발생한다는 것을 기억하시기 바랍니다.) 

 다음으로, *from-tile* 변수가 nil인지 확인합니다. 그렇다면, 이는 플레이어가 아직 주사위 공격할 시작 지점을 선택하지 않았다는 것을 의미합니다. nil이라면, *from-tile*을 선택한 지점과 동일하게 설정할 수 있으며, 플레이어에게 목적지의 선택을 요청할 수 있습니다.

 현재 선택된 지점이 *from-tile* 변수와 같다면, 이는 tile이 두번 선택됬다는 것을 의미합니다. 이는 플레이어가 생각을 바꾸어, 선택을 취소하기 원한다는 것을 의미합니다. 그러므로, *from-tile*을 nil로 설정하고 취소 메시지를 출력할 것입니다.

 다른 경우엔, 이는 플레이어가 공격의 시작과 끝을 위한 두 적법한 장소를 선택했다는 것을 의미합니다. 저희는 이제 *cur-game-tree*가 이용가능한 move의 lazy 리스트에 있는 적절한 다음 tree를 지정하도록 할 수 있습니다. 플레이어가 pass하거나 다른 공격을 하도록 허용하는 메시지를 출력하기 원합니다.

 이제 저희는 인간 플레이어와 소통하는데 사용될 게임 서버 코드를 완성했습니다. 다음으로가서, 컴퓨터 플레이어를 다루는 함수를 작성해 봅시다.


Handling the Computer Player
 컴퓨터플레이어를 위한 웹 인터페이스를 조정하는 것은 매우 간단합니다. 어쨋든, 컴퓨터 플레이어는 게임상에 무엇이 돌아가고 있는지를 알 수 있는 멋진 사용자 인터페이스가 필요치 않습니다. 컴퓨터가 move를 할때 웹이 하는 일은 단지 인간 플레이어의 이익을 위한 것입니다. 여기 AI 플레이어가 move를 할때 웹 인터페이스에서 HTML을 다루는 web-handle-computer 코드가 있습니다:
[CODE]

 이 함수가 하는 일은 컴퓨터가 게임 트리에서 선택한 다음 가지를 반환하는 예전 handle-computer 함수를 호출하는 것입니다. *cur-game-tree*변수를 갱식하기 위해 이를 이용합니다. 다음으로, 플레이어가 움직였다는 것을 말하는 메시지를 출력합니다. 이 함수의 마지막 부분은 웹 인터페이스에 조금 흥을 돋구어주는 영리한 작은 술책입니다. 웹 페이지의 HTML에 웹 브라우저가 자동적으로 새로운 웹 페이지를 5초마다 로드할 수 있게 해주는 약간의 JavaScript를 넣었습니다. 컴퓨터 AI 플레이어가 move할때 발생하는 모든 것을 미숙한 에니메이션으로 볼 수 있다는 것을 의미합니다!


Drawing the SVG Game Board from Within the HTML
 Dice of Doom version 3을 완성하기 위해 하나의 함수를 더 작성해야 합니다: draw-dod-page함수. 이 함수는 게임 서버 코드와 보드를 그리는 SVG 코드에 접속합니다.
[CODE]

 이 함수의 가장 복잡한 부분은 보드에 있는 어떤 타일이 플레이어가 클릭하기 적법한 타일인지 결정하는 코드 입니다. 플레이어가 이미 tile을 선택하였으면, 선택된 tile과 일치하는 move로 시작하는 모든 move를 찾아 주어진 move의 목적지를 반환합니다. 플레이어가 tile을 아직 선택하지 않았다면, 모든 적법한 시작 지점을 반환합니다.

 이제 저희는 완전한 Dice of Doom의 graphical한 version을 지녔습니다. 플레이 해봅시다!


Playing Version 3 of Dice of Doom
 우선, 웹 브라우저를 킵니다. 단순히 dod-request-handler를 서비스하면, 시작할 준비가 된것입니다:
[REPL]

 이제 Firefox로 넘어가서 http://localhost:8080/game.html로 이동합니다. 브라우저에서 게임을 볼 수 있을 것입니다:
[PIC]
[PIC]

 이제 여러분은 공격하기위해 tile을 선택할 수 있습니다. 예를들어, 선택된 더미 옆의 두 주사위 더미를 선택할 것입니다:
[PIC]

 다음, pass 웹 링크를 클릭함으로 턴을 넘깁니다. 이로써 충원 주사위가 놓여집니다 (이번 경우, 좌측-상단 구석에 오직 하나의 추가 주사위가 있습니다):
[PIC]

 continue를 누르면, 유사한 방식으로 컴퓨터 플레이어의 move를 통해 게임이 자동적으로 돌아가는것을 보게 될 것입니다. 게임의 승자가 있을 때까지 이러한 것이 계속 돌아갑니다. 원래의 game.html URL로 돌아감으로써 새로운 게임을 시작할 수 있습니다

 이는 이전에 이용했던 허접한crude 콘솔 인터페이스보다 훨씬 멋집니다. 그러나 Dice of Doom의 생기를 불어 넣을 마지막 향상할 수 있는 것이 여전히 조금 남아 있습니다. 이러한 것을 이 책의 다음 장(마지막 장)에서 다룰 것입니다.


What You’ve Learned
 이번 장에서, 저희는 Lisp프로그램에서 웹 브라우저안에서 상호작용하는 graphics를 어떻게 생성하는지를 다루었습니다. 이러한 과정속에서, 다음과 같은 것을 배웠습니다:
z SVG 포맷을 이용하여 보드를 다룸으로써 Dice Of Doom의 graphical한 version을 만들 수 있다
z HTML5 표준은 inline SVG 이미지를 지원한다. interactive하며, 웹-기반의 게임을 만들기 위해 이를 이용할 수 있습니다.
z 저희 예제에서 사용한 간단한 웹서버는 몇몇 한계점을 지닌다. 예를들어, 저희 게임은 다수의 플레이어와 플레이 할 수 없습니다. 그러나 request handler는  게임이 다수이며 병렬을 허용도록 확장될 수 있습니다.