7장. 기본 리스트를 뛰어넘어


 이번 장에서, 저희는 기본 리스트 개념을 뛰어 넘을 것입니다. 저희는 특별한 종류의 리스트에 대해 이야기를 나눌 것이며, 리스트조작에 있어 새로운 단계로 데려다 줄 게임을 작성할 것입니다.


특이한 리스트
 3장에서 배웠듯이, Lisp에서의 리스트는 cons cells(두 데이터 조각을 서로 연결 시킬 수 있는작은 자료구조)로 구성되었습니다. 리스트의 마지막 cons cel의 오른쪽 칸은 nil을 담을 것입니다. cons cell들을 서로 이음으로써, 어떤 길이의 리스트라도 만들 수 있습니다. 예를 들어, 다음은 1, 2, 3 숫자리스트를 만듬으로써 cons cell들을 어떻게 사용하는지에 대한 것입니다:
[SOURCE]
[PIC]

 인간이 리스트를 cons cell의 사슬이라고 생각하기엔 매우 복잡하기에, Lisp는 특별히 그런 리스트들을 출력하기 위한 간단한 문법을 취하였습니다. 이것을 cons cell들의 사슬이 REPL에서 평가된 것으로부터 확인할 수 있습니다.
[REPL]

 Lisp는 REPL에서 사슬을 우리에게 되풀이하여 보여줄때 간단한 리스트 문법을 사용합니다. 이것은 세가지 항목이 있는 리스트로 cons cell 문자열을 보여줍니다. 기억해야할 중요한 점은 보여짐에 있어 이 차이점이 순전히 피상적이라는 것입니다. Lisp 리스트가 어떻게 보여지든지 간에, 근복적으로 이것은 항상 cons cell사슬을 유지합니다.

 
점 찍힌 리스트
 그러면, 고전적인 "cons로 연결된 사슬" 형식에서 벗어나면 어떤 일이 일어날까요? 리스트를 출력할때 Lisp환경은 이런것을 어떻게 다룰까요?
 이와 같은 숫자 1, 2, 3을 갖는 리스트를 만든다고 가정해 봅시다:
[SOURCE]

 여기에선, 리스트의 세번째의 숫자를 위한 세번째 cons cell을 만드는 대신에, 이전 cell의 오른쪽 칸에 넣습니다. Lisp REPL에 이런 구조를 입력하면 어떤 것이 출력될 까요? 시도해 봅시다:
[REPL]

 리스트의 마지막 항목에서 nil로 끝나는 리스트를 찾을 수 없다는 것을 표시하기 위해, Lisp는 마지막 항목 앞에 점을 놓습니다. 이는 Lisp 방식대로, "저는 여러분이 입력한 이 구조를 리스트 표현법을 사용하여 출력하려고 노력했으나, 리스트의 마지막 항목 제가 예상한 nil을 포함하지 않았습니다; 대신에, 이것은 3을 포함하였습니다."라고 말하는 것입니다.
 nil이 아닌 다른 것으로 끝나는 리스트는 점 찍힌 리스트(dotted list)라 언급되어집니다. 점 찍힌 리스트는 Lisp 대륙에서 특이한 부류입니다. 그들 자체만으로는, Lisp프로그래밍을 위한 유용한 도구가 아닙니다. Lisp 프로그래머에게 데이터를 점 찍힌 리스트에 저장하는 것은 정기연습처럼 매우 드문일 일 것입니다. 그러나, Lisp에 풍부한 cons cell를 제공하기 위해선, cons cell사슬의 마지막 부분에서 nil이 아닌 값을 자주 마주치게 될 것입니다. 이러한 것이, 저희가 이것을 직접 사용하지 않더라도, 점 찍힌 리스트와 친해져야하는 이유입니다.
 이 점 표기법을 다르게 생각하는 방법은 이것을 단순히 데이터 모드에서 사용하는 cons 명령어를 위한 대안 문법이라 생각하는 것입니다. 사실, 고달픈 삶을 살고 싶으시다면, 이와 같은 점 표기법을 사용하여 적절한 리스트를 만들수도 있습니다.
[REPL]

 이 라인에 대해 생각하자면, Lisp는 일관성있는 리스트 출력 메커니즘을 유지하기 위해, 마지막 cons cell을 보여주므로 점이 찍힌 리스트안에 점이 보이는 것입니다.


쌍
 Lisp 프로그램에서의 점이 찍힌 리스트를 평범하고 일상적으로 사용하는 것중 하나는 쌍(pairs)을 우아하게 표현하는 것입니다. 예를 들어, 2와 3의 쌍을 표현하기를 원한다고 가정해봅시다. 이것을 행할 하나의 방법으로는 이 두 수를 서로 cons하는 것입니다:
[REPL]

 여러분이 여기서 할 일은 점이 찍힌 길이가 2인 리스트를 만드는 것입니다. 예상할 수 있듯이, Lisp는 쌍을 표시하기 위해 점 표기법을 사용합니다.
 Lisp에서 이러한 방법으로 쌍을 생성하는 것은 매우 편리하고 효율적입니다. 이는 표준 car와 cdr명령을 사용하여 쌍에서 멤버를 추출할 수 있기에 편리합니다. Lisp환경은 두 항목을 연결하기 위해 오직 단일 cons cell만 할당하면 되기에 비교적 효율적입니다.
 이러한 쌍의 형식은 Lisp 프로그램에서 일상적으로 사용됩니다. 예를 들어, 여러분이 복잡한 데이터 구조에 점의 x, y좌표계나 키/값 쌍을 저장할때 사용할 수 있습니다. 후반에 연관리스트를 다룰때 여기서 나온것을 이용하는 것을 보게 될 것입니다.


순환리스트
 리스트 '(1 2 3)으로 구성된 cons sell을 설명하기 위해, 3장에서 사용했던 그림이 여기 있습니다:
[PIC]

 이제 저희가 이 리스트의 괴상한 돌연변이를 만든다고 가정해 봅시다. 세번째 cons cell의 cdr이 nil대신에 첫번째 cons cell을 가리키도록 해봅시다:
[PIC]

 리스트에 있는 모든 cons cell 이론적으로 메모리상에서 분리된 객체로 존재합니다. cell에서의 car와 cdr의 슬롯은 메모리에 있는 다른 객체를 지정할 수 있기에, cons cell은 리스트의 cons cell의 시작부분을 가리킬 수 있습니다. 이를 순환리스트(혹은 환형리스트, circular list)라 부릅니다.
 대부분의 Common Lisp 환경에선 순환리스트를 가지고 실험을 하기 전에, 다음 명령어를 실행해야만 할 것입니다:
[source]

 *print-circle*를 참으로 설정하는 것은, 자기 참조형 데이터구조에 대해 눈속임할 것이며, 어떤 기괴한 것을 화면에 출력할때에 추가적인 주의가 필요하다고 Lisp에게 경고하는 것입니다. 만일 여러분이 이 변수를 설정하지 않고 순환리스트를 출력한다면, 어떤일이 일어나는지 알 수 없지만, (여러분이 스텍 오버플로우나 무한루프되는 출력에서 아름다움을 찾지 않는다면)출력결과는 예쁘지 않을것입니다.
 *print-circle*을 true로 설정하면, Common Lisp는 데이터구조를 출력하기 위해 (기본적으로 성능을 향상시키기 위해 막아놓은) 더욱 복잡한 출력 방식을 이용할 것입니다. 이 방식은 여러분이 이전에 봤던 cons cell을 실행하는지 확인하고, 무한루프에 빠지지 않도록 출력합니다.
 그러면 순환리스트는 어떻게 만들까요? 가장 간단한 방법은 다음과 같이 setf 명령어를 사용하여 추가할 것을 첫번째 인자에 넣는 것입니다.
[source]

 이 예제에선, 리스트에 마지막에 있는 nil을 자기자신 가르키도록 바꿔서, 무한리스트 '(1 2 3 1 2 3 1 2 3 ...)를 만들었습니다.
 이번 예제와 같이, 복잡한 표현식을 setf의 첫번째 인자에 위치시키는 것은 매우 멋진 능력이며, 9장에서 더 자세히 살펴볼 것입니다.

NOTE CLISP(그리고 다른 Common Lisps)는 순환리스트를 매우 실감나게 출력할 수 있습니다. 어찌됐든, 이는 리스트의 한 부분이 다른 부분을 참조한다는 사실을 말합니다. 저희가 봐왔듯,  표현식 중 자기참조하는 부분을 연결하기 위해, 은밀하지만 매우 영리한 표기법을 이용합니다. 그러나 저는 여러분들이, 자기 참조 데이터의 복잡성 증가처럼, 데이터형식을 위해 Lisp printer가 제공한 출력된 결과가 프로그래머를 공감시키는데 있어 더욱 어렵게한다는 것을 이해하실 수 있을거라 확신합니다.


연관리스트
 cons cell들로 만들 수 있는 특출하게 유용한 자료구조 중 하나는 연관리스트(association list), 짧게 alist입니다. alist는 리스트에 저장된 키/값으로 이루어 집니다.
 관례에 따라서, 만일 리스트에서 동일한 키가 반복하여 보인다면, 첫번째 보이는 키가 바람직한 값을 지닌다고 가정합니다. 예를들어, 여기 Bill, Lisa, John의 커피 주문을 나타내는 alist가 있습니다.
[SOURCE]

 어떤 사람에 대한 주문을 찾아보기 위해, assoc 함수를 사용합니다:
[REPL]

 이 함수는 리스트에서 바람직한 키로 시작하는 것을 찾고, 키/값 쌍을 반환합니다. 이제, 음료 주문을 가져다 주기 전에, Lisa가 여러분을 멈추게하고 조금 더 맛있는 것으로 주문을 바꾼다고 가정해봅시다. 여러분은 push함수로 그녀의 주문을 바꿀 수 있습니다.
[REPL]


 이 함수는 간단하게 새로운 항목을 이미 존재하는 리스트의 앞부분에 추가합니다.
 기본적으로, 연관리스트에서 키에 대해 첫번째로 참조되는 키가 우선권을 지니기에, Lisa의 주문 small drip coffee는 더 최근 주문으로 대체됩니다:
[REPL]

 보시는 것처럼, alist는 변화가능한 키/값 쌍의 자취를 얻기에 훌륭한 방식입니다. alist는 이해하기 쉽고, Lisp 함수로 다루기 쉽고, 출력된 것을 이해하기 쉽습니다. (어찌됫건, 그것들은 단지 pair들의 리스트입니다)
 더욱이, alist에 값이 저장되면, 어떤 데이터의 변화를 감시하기 쉽게, 그것을 영원히 유지합니다. 커피 예에서, Lisa의 주문 drip coffee는 교체되었더라도 여전히 남아 있습니다.
 그러나, alist는 중대한 한계점을 하나 가지고 있습니다: (12개의 항목 보다 적은) 매우 짧은 리스트를 다룰게 아니라면, 데이터를 받거나 저장하기에 효율적인 방법이 아닙니다. 비록 alist가 Lisp 프로그래머의 도구상자에서 우선시되는 도구 중 하나이지만, 비 효율적이기에 프로그램이 성숙해짐에 따라 다른 형식의 자료구조로 교체되어야만 합니다. (9장에서, 저희는 alist와 같은 리스트 기반 자료구조의 성능 한계에 대해 더욱 자세히 다룰 것입니다)


복잡한 데이터 처리하기
 cons cell은 리스트와 유사한 구조를 표현하기 위한 좋은 도구 입니다. 사실, 대다수의 Lisp프로그래머들은 성능 제약이 없는 프로그래밍 작업 시, 이에 전적으로 의지합니다. cons cell 구조의 조작과 시각화는 Lisp 설계의 핵심이기에, 이러한 구조는 디버그하고 이용하기에 매우 편리합니다.
 사실, 성능 제약이 있을지라도, cons cell의 구조는 좋은 선택이 될 수 있습니다. Lisp 컴파일러는 보통 cons cell을 단일 어셈블리 명령어로 줄일 수 있습니다.


나무 모양의 데이터를 시각화하기
 3장에서 다루었듯이, Lisp프로그램에서 데이터(그리고 코드)는 문법 표현식으로 표현됩니다. 이런 형식에서, 데이터는 중첩된 리스트를 사용하여 나타내고, Lisp 심볼은 주로 각 리스트 앞 부분에서 자료구조를 서술합니다.
 예를 들어, 여러분이 Lisp에서 집을 구성하는 요소들을 표현한다고 가정해봅시다 :
[SOURCE]

 이러한 자료구조는 집을 구성하는 부품의 계층관계를 매우 우아하게 담아내고 있습니다.
 이는 Lisp 문법 표현식과 유사한 구조이기에, 여러분은 계층 단위로 구성된 리스트를 확인하실 수 있습니다. 또한, 이것은 각 리스트앞에 심볼을 넣는 문법표현 관습을 따릅니다. 예를들어, 창문을 설명하는 리스트가 windows 심볼을 포함하며, glass frame curtains 3가지 항목이 따라오는 것을 볼 수 있습니다.
 보시다시피, 이는 계층적이며, 나무 모양의 데이터는 매우 자연스럽게 표현되어집니다. 사실, 많은 Lisper들은 XML(계층적 데이터를 표현하는 유명한 형식)을 초기 Lisp 문법 표현식 형식의 재발명으로 여깁니다.
 상대적으로 cons cell에 데이터를 저장하기 쉬울지라도, 나무 모양의 구조를 벗어난다면 문법 표현식안에 저장된 데이터를 시각화하는 것은 어려울 수 있습니다. 예를들어, 수학적 그래프가 저장된 문법 표현식을 지녔다고 가정해봅니다. 간선들로 이어진 그래프의 임의의 노드를 지닌 그래프를, 컴퓨터 프로그램에 보여지도록 하는 것은 어렵다고 악명이 났습니다. Lisp의 우아한 cons cell을 표현하는 체계라도 이와 같은 데이터를 완벽하게 도울 순 없습니다. 다음에서, 이러한 그래프의 시각화를 위한 옵션을 살펴볼 것입니다.


그래프를 시각화하기
 수학에서, 그래프는 간선으로 연결된 노드의 가지로 구성되었습니다. 이 노드들 혹은 간선들은 이와 연관된 추가 데이터를 지녀야 합니다.
 그래프를 cons cell에 저장할 수 있더라도, 시각화하는 것은 어렵습니다. 저희는 이러한 것을 5장에서 두 alist에 (방향 그래프로 된) 마법사의 집 지도를 저장했을 때 보았습니다: 하나는 노드의 정보를 포함하고 있고 다른 하나는 간선의 정보를 포함하는 것. 이번장을 위해, 여기 보이시는 것처럼 *wizard-nodes*와 *wizard-edges*로 다시 이름지었습니다:
[SOURCE]

 보시다시피, 이 가공되지 않은 데이터 표에서 게임세계의 구조를 이해하기에는 어려움이 있습니다. 불행히도, 그래프구조나 간단한 나무형태를 벗어난, 다른 성질을 포함하는 데이터 매우 흔합니다. 만일 저희가, 이 데이터로 예쁜 그래프그림의 생성을 최적화하여 처리할 수 있는 도구가 있다면 얼마나 좋을까요? 운이 좋게도, 이러한 작업을 완벽히 수행할, 환상적인 오픈 소스 도구가 있습니다.


그래프 생성하기
 Graphviz는 데이터에서 그래프를 생성합니다. 실제로, 여러분은 5장에서 간단하게 Graphviz로 마법사의 집을 표현한 것을 보았습니다.
[PIC]

 Graphviz는 오픈소스이며 Graphviz 웹사이트(http://www.graphviz.org/)에서 얻을 수 있습니다. 이것을 다운로드 받고 설치하고 나면, 그래프를 만드는 일은 쉽습니다. 여러분은 우선 그래프의 모양을 서술하는 DOT파일을 만들어야 합니다. 예를들어, Graphviz형식에 맞게, 여러분에 컴퓨터에 test.dot이란 파일을 만들고 다음에 나오는 정보를 입력합니다:
[SOURCE]

 이것은 화살표로 노드 A와 B가 연결된 방향그래프(directed graph)를 정의합니다. (DOT 파일 형식에는, Graphviz 웹사이트에 문서화된 수 만큼 많은 문법 옵션이 있습니다.)
 이제, DOT 파일에서 그래프 비트맵을 생성하기 위해 커맨드 라인에서 다음과 같이 (Graphviz 유틸리티 중 하나인)neato를 실행합니다:
[CMD]

 이는 test.dot.png파일에서 다음과 같은 그림을 생성해 줍니다:
[PIC]

 보시다시피, Graphviz의 사용법은 간단합니다. 그래픽 쪽으로 사소한 문제가 있지만, 이는 크고 심지어 복잡한 그래프를 빠르게 생성할 수 있습니다. (컴퓨터 과학에서 완벽한 그래프 형태는 여전히 풀리지 않은 문제이기에, Graphviz 형태는 완벽하지 않습니다. 그러나, 이는 저희가 기대햇던 것보다도 완벽에 가깝습니다.)

 이제 여러분이 지닌 Graphviz를 사용하여, Lisp에서 편리하게 그래프를 그려줄 command 라이브러리를 만들어 봅시다. 이것을 저희는, 어드벤처 게임 세계를 그래프로 나타내기 위해 사용할 수 있습니다.

NOTE 이번 장의 예제에 사용된 그래프 유틸리티는 Common Lisp의 표준의 일부가 아닌 방식으로 특정 시스템 콜을 수행합니다. 이는 CLISP환경에서만 동작합니다. 다른 Lisp환경에서 돌아가기 위해선, 약간의 코드 수정이 필요합니다.


DOT 정보를 생성하기
 그래프를 그리는 라이브러리를 작성하기 위해, 저희는 그래프의 세부사항을 담은 Graphviz DOT파일을 생성하기 원합니다. 이를 수행하기 위해선,  플레이어가 돌아다닐 수 있는 노드 구분자의 변환과, 이 노드들을 연결하는 간선들의 변환, 그리고 모든 노드와 간선의 이름표을 생성해야 합니다. 마법사세계의 지도를 나타내는 노드를 이용하여 저희 라이브러리를 테스트 할 것입니다.


노드 식별자 변환하기
 노드들을 DOT 형식으로 변환할때, 첫번째로 필요한 것은 노드 식별자들 유효환 DOT 식별자로 변환하는 것입니다. dot-name함수를 작성함으로써 이러한 일을 처리합니다:
[SOURCE]

 DOT형식에 있는 노드는 오직 문자, 숫자, 밑줄만 포함 할 수 있습니다. 저희가 이용할 노드 식별자를 적법하게 만들기 위해,  적법하지 않은 문자들을 밑줄로 바꿀 것입니다. 여기 dot-name 함수가 사용된 예가 있습니다:
[REPL]

 이 함수는 prin1-to-string함수를 사용하여 문자열로 변화시킬 수 있는 어떠한 Lisp 기본 타입을 받아 들입니다. 저희는 문자열의 산출할수 있으며, 필요하다면 밑줄로 치환하는 작업을 할 수 있습니다.

NOTE 단순화를 위해, dot-name함수는 알파벳이 아닌 구성물의 노드 식별자의 차이를 구분하지 않는다고 가정합니다. 예를 들어, 여러분이 foo?라고 불리는 하나의 노드를 가지고 있고, 다른 노드를 foo*라고 한다면, dot-name함수는 이들 모두 이름이 충돌하는 foo_로 바꿀것입니다.

 substitute-if 함수는 테스트 함수의 결과를 기반하여 값을 바꿉니다:
[REPL]

 이번 예제에서 테스트 함수, digit-char-p는 문자열에 있는 문자인지 숫자인지를 알려줍니다. 이와 같은, 값을 받아들이고 값에 기반하여 참을 결정하는, 테스트 함수를 주로 술부(predicates)라 합니다.
 substitute-if 함수의 또다른 흥미로운 속성으로는 리스트에서도 사용할 수 있다는 것입니다:
[REPL]

 여기서, 리스트에 있는 모든 홀수는 0으로 변경되었습니다. substitute-if 함수는 generic함수(다양한 자료구조를 인자로 받아 적절하게 다루는 함수)의 한 예입니다. (일반화 프로그래밍(Generic programming)은 9장에서 다뤄집니다.)
 dot-name함수 안에서 substitute-if를 사용하면, 알파뱃이 아닌 문자를 치환할 것입니다. Common Lisp에는 이를 수행하는 술부가 없지만, 이러한 술부를 순식간에 쉽게 만들 수 있습니다. dot-name함수 안의 다음 조각은, 올바른 행동을 하기 위한 술부함수를 생성합니다:
[SOURCE]

 Lisp는 이미 문자가 알파벳인지 알려주는 alphanumericp라 불리는 술부함수를 지녔습니다. 그러나, 저희는 오직 알파벳이 아닌 문자만 치환하기 원합니다. 저희는 이를 higher-order 함수인 complement를 통과시킴으로써 alphanumbericp과 반대의 함수를 만들 수 있습니다.
 이 함수를 substitute-if에 넣음으로써, 새로운 함수로 top level을 오염시키는 defun의 사용 없이,  저희가 원하는 substitute-if의 보안물을 얻었습니다.

NOTE Common Lisp는, substitute-if대신에 substitute-if-not이라 불리는 dot-name함수에서 사용할 수 있는 함수를 지니고 있습니다. 그러나 끝에 not이 있는 Lisp함수는 피하는게 좋습니다. 그것들은 아마도 ANSI Common Lisp 차기 표준버전에서 사라질 것이며, 이는 그것들이 비난받는다고(deprecated) 여겨진다는 것을 의미합니다.


그래프 노드에 이름표 추가하기
 저희는 노드 식별자를 DOT을 만족하도록 수정할 수 있게 되었으므로, 이제 이것이 그려질때 노드에서 보여질 이름표을 생성하는 또 다른 함수를 작성합시다. 이름표는 노드 이름과 alist에 있는 노드와 연결된 데이터로 구성됬습니다. 저희는 또한 이름표안에 매우 많은 텍스트를 입력하지 않는 것을 보장해야 합니다. 여기 이름표를 생성하는 코드가 있습니다:
[source]

 *max-label-length* 는 이름표에 들어갈 최대 문자수를 결정하는 전역 변수 입니다. 만약 노드의 이름표가 최대치보다 길다면 일부가 짤려나가고, 그러한 사실을 나타내는 생략부호가 추가될 것입니다. write-to-string 함수는 저희가 예전에 썼던 prin1-to-string함수와 유사합니다 - 이는 표현식을 문자열로 작성합니다.
 :pretty 인자는, 여러분이 원하는 매개변수를 선택하는 특정한 Lisp 함수에서 사용되는 keyword 인자의 한 예제입니다, 이번 경우 write-to-string는, Lisp에게 이것을 예쁘게 만들면서 문자열을 변경시키지 말라고 말하는 것입니다. 이것이 없으면, Lisp는 눈에 더 잘보이게 하기 위해 만든 개행이나 탭을 변환된 문자열에 넣을 것입니다. :pretty keyword 인자를 nil로 설정함으로써, Lisp에게 어떠한 꾸밈도 없이 표현식을 출력하라고 말합니다. (새로운 라인을 갖는 이름표는 Graphviz를 혼란에 빠트릴수 있으므로, 저희는 Lisp에게 어떤한 idea를 주길 원하지 않습니다.)


노드를 위한 DOT 정보 생성하기
 이제 저희는 각 노드의 이름과 이름표를 동시에 생성할 수 있으며, 다음처럼 노드 alist를 받아 부호화된 DOT 정보를 생성하는 함수를 작성할 수 있습니다:
[SOURCE]

 이 함수는 노드 리스트에 있는 모든 노드를 거쳐가기 위해 mapc를 사용하며, princ는 DOT 형식에 있는 각 노드를 화면에 직접 출력합니다. mapc는 미묘하게 더 효율적인 mapcar의 변종입니다; 차이점은 이것은 변형된 리스트를 반환하지 않는다는 점입니다. nodes->dot함수는 저희가 데이터를 변경하기 위해 만든 dot-name과 dot-label함수를 사용합니다.
 후에, 이러한 정보를 담는 파일을 생성할 때에는, 콘솔에서 이러한 데이터를 가져오는 함수를 작성해야 합니다.
 파일에 직접 작성하는 대신, 콘솔을 파일을 생성하는 중계자로 이용하는 것이 조금 이상하게 보여지지만, 이는 실제 Lisp에서 일반적인 패러다임입니다. 이러한 접근의 이점으로는 출력된 줄들을 확인하기 쉬운 REPL에서 코드를 쉽게 디버그 할 수 있습니다.
 이제 nodes-dot함수를 이용하여 마법사의 집안 노드에 대한 DOT 정보를 생성해 봅시다:
[REPL]

 여기서, DOT 형식에서 보여지는, 마법사의 집에 대한 노드와 각 노드의 생략된 정보들을 볼 수 있습니다. nodes->dot 함수에서 반환된 값에는 관심이 없음을 알립니다 - 필요한 정보는 REPL에서 출력된 정보입니다. Lisper는 저희가 이 함수의 부수효과(side effects)에만 관심이 있다고 예기할 것입니다. 비록 mapc가 리스트를 반환하지 않지만, 여전히 리스트가 코드를 거쳐가게 되며 mapcar를 사용하여 출력된 결과와 동일한 것을 생성하므로, 이는 좀 더 빠르며 mapcar와 부수효과가 같습니다.


간선을 DOT 형식으로 변환하기
 다음 단계는 노드를 이어주는 간선에 대한 DOT정보를 생성하는 것입니다. 이것은 그래프에서 화살표로 보여질 것입니다. edges->dot함수는 콘솔로 직접 출력하여 필요한 데이터를 생성합니다.
[SOURCE]

 이 함수를 이용하여 마법사의 집의 간선에서 DOT 정보를 생성해 봅시다:
[SOURCE]

 여기서, 저희는 DOT 형식으로된 마법사의 집에 있는 노드간의 관계를 명확히 확인할 수 있습니다. 예를 들어, 첫번째 줄은 (WEST DOOR)라 이름표가 붙은 간선을 이용하여 플레이어가 LIVING_ROOM노드에서 GARDEN노드로 걸어나갈 수 있다는 것을 나타냅니다.


모든 DOT 데이터 생성하기
 DOT데이터의 생성을 완료하기 위해, nodes->dot과 edges->dot을 함께 호출하고, 다음과 같이 추가 장식으로 이를 꾸며보도록 합시다:
[SOURCE]

 이 함수는 저희 그래프를 방향그래프(directional graph)라 정의하여 nodes->dot과 edges->dot함수를 호출함으로써 모든것을 한데 모아 묶었습니다.
 여기 새로운 라이브러리로 보이는 마법사게임을 위한 최종 DOT정보가 있습니다:
[SOURCE]

 이제 저희는 예쁜 그림을 생성할때 필요한 마법사 지도의 모든 세부사항 포함하는 적절한 Graphviz DOT파일을 생성할 수 있습니다. 이는 플레이어가 방문할 수 있는 노드와, 이 노드와 연결되는 간선들, 그리고 모든 노드와 간선들의 이름표를 포함하고 있습니다.


DOT 파일을 그림으로 만들기
 DOT파일을 실제 비트맵으로 바꾸기 위해, DOT파일 데이터를 파일에 넣고, 이와 같이 시스템 명령 라인에서 dot 명령어를 직접 실행합니다.
[SOURCE]

 이 함수는 몇몇 진보된 Lisp기술을 사용하여 그래프를 그리는 라이브러리의 중요한 행동을 수행합니다.
 우선, dot->png함수는 재활용을 위해, graph->dot함수를 직접 호출하지 않습니다. 대신에, thunk를 받도록 작성하였습니다.


thunk의 사용
 Lisp에서 인자가 없는 작은 함수를 만드는 것은 일반적입니다. 이러한 함수를 공식적으로 nullary 함수라 부릅니다. 그러나, Lisper는 종종 나중까지 실행을 미뤄두기 원하는 계산을 기술하기 위해 이와 같은 함수를 만듭니다. 이번 시나리오에서, 인자가 없는 함수는 일반적으로 thunk 혹은 suspension이라 합니다. 이번 경우에, 저희 dot-png함수가 필요로하는 thunk는 이 함수를 호출시 DOT파일을 콘솔에 출력하는 함수가 될 것입니다.
 왜 dot->png함수에서의 thunk는 유용할까요? 저희에게 있어 graph->dot과 다른 DOT파일 함수들을 작성하고 디버그하기 쉬운방법으로는, 결과를 직접 콘솔로 출력을 하는 것입니다. graph->dot를 호출하면, 값으로 결과를 반환하지 않고, 부수효과로 콘솔로 출력합니다. 그러므로, 우리는 graph-dot의 값을 dot->png로 넘겨줄 수 없습니다. 대신, graph->dot을 thunk로써 넘깁니다. 그러면 dot->png는 graph->dot을 호출하며, 결과를 받아, 파일로 보냅니다.
 컴퓨터 프로그램에 있어 텍스트로된 데이터를 생산하는것은 일반적이기에, 이 특별한 기법은 많은 Lisp 코드에서 쓰여집니다: 첫번째로, 무언가를 콘솔에 곧바로 출력합니다; 그리고, 그것을 thunk로 옮깁니다; 마지막으로, 결과를 다른 장소로 보냅니다.
 14장에서 보게될것이지만, 함수형 프로그래밍 형식을 따르는 Lisper는 이러한 기법을 삼가해야하는데, 왜냐하면 콘솔로 출력하는 것은 부수효과를 요구하기 때문입니다.


파일 작성하기
 with-open-file 함수는 dot->png이 파일에 정보를 써넣는걸 가능케합니다. 여기, 이 함수가 어떻게 동작하는지 경험하기 위해, 새로운 testfile.txt란 이름의 파일을 만들고, "Hello File!"을 써넣는 예제가 있습니다.
[SOURCE]

 이번 예제에서, 저희는 with-open-file에 넣어진 첫번째 항목이 (with-open-file에 의해 만들어지는) 스트림(stream)이라 불리는 특별한 Common Lisp 데이터형식이 된다는 것을 확인 할 수 있습니다.


스트림 생성하기
 princ와 같이 출력하는 함수는 스트림을 추가인자로 받을 수 있습니다. 이번 경우에, 출력하는 이 함수는 어떤 것도 콘솔로 출력하지 않는 대신에, 스트림 객체에 출력할 것입니다.
 let이 변수 이름에서 변수를 만드는 것과 마찬가지로, with-open-file이 stream변수이름에서 stream변수를 만든다는 것을 이해하는 것이 중요합니다:
[SOURCE]

 만약 여러분이 첫번째 리스트앞에 있는 my-stream 이름을 with-open-file에 넣는다면, 이는 let으로 시작하여 my-variable를 정의하는 것과 유사할 것입니다. my-stream 변수 이름은 with-open-file 내부에서 사용가능하고, 이와 같은 방식으로 my-variable은 let 내부 안에서 사용가능합니다.

 그러나 아직은 스트림이 정확히 무엇인지에 대해 걱정하실 필요가 없습니다. 12장에서 더욱 자세히 살펴볼 것입니다. 이제, 저희는 스트림이 객체이며 파일로 연결될 수 있다는 것을 알게되었으며, 연결된 파일에 어떤것을 작성하기 위해 이것을 (princ와 같은)함수로 보낼 수 있게 되었습니다.


키워드 매개변수 이해하기
 with-open-file명령어는 또한 어려운 키워드 매개변수(keyword parameter)를 사용합니다. 이전 예제로가서 이 명령어를 다시 살펴봅시다:
[SOURCE]

 키워드 매개변수는 두부분으로 나뉩니다: 매개변수 이름과 매개변수의 값. 매개변수의 이름은 항상 콜론으로 시작하는 심볼입니다. 이 예제에서는 두 키워드 매개변수가 있습니다: (읽지 않고 단순히 파일만 작성하는):output을 설정하는 :direction,  그리고 (파일 이름이 이미 존재하면, 이전 버전으로 넘겨주는) :superseded를 설정하는 :if-exists.
 파일을 여는것이 복잡한 연산이고 수많은 희괴한 옵션있기 때문에, with-open-file은 키워드 매개변수를 지니고 있습니다. with-open-file가 이 모든 것을 설정하기 위해 평범하게 매개변수를 제공한다면, with-open-file의 호출은 매번 길어질 것이며 다루기 어려워 질 것입니다. 또한, 인간은 긴 매개변수 리스트를 살펴보고 어느곳에 있는지 기억하는데 어려움이 있습니다.
 이미 눈치챗듯이, Common Lisp에서의 심볼은 종종 콜론으로 시작합니다. 이는 항상 콜론으로 시작하는 키워드 매개변수를 포함합니다. Lisp에서 평범한 심볼은 다른 것으로 참조될 수 있기 때문입니다. 예를들어, cigar변수를 5로 설정하고 반환해 보겠습니다:
[REPL]

 그러나, 때때로 저희는 심볼이 다른 무언가를 참조하기 원하지 않습니다. 노골적으로 심볼 자체를 사용하길 원하고, 자기자신을 의미하길 원합니다. Common Lisp에서 앞에 콜론이 붙은 (키워드 심볼이라 불리는게 놀랍지않은)심볼은 항상 그 자체를 의미합니다:
[REPL]

 보시다시피, 키워드 심볼 :cigar은 REPL에서 평가될 수 있고, 이미 값을 가지고 있습니다. 알맞게도, 이 값은 :cigar입니다. :cigar을 다른 것으로 재정의를 시도하면, Common Lisp는 허락하지 않습니다. 이것이 상수라는 사실은 유용한데 Lisp 컴파일러는 잠재적으로 다른 형식보다 최적화가 가능한, 이 단순한 심볼 형식을 최적화 할 수 있기 때문입니다. 또한, 심볼이 그 자체를 의미하는 코드에서 키워드 심볼을 사용함으로써 에러를 줄일 수 있습니다. 때때로 cigar은 단지 cigar일 뿐입니다.


콘솔 출력 가로채기
 저희 dot->pgn는 이전 예제에서 보였던것과는 미세하게 다른 방법으로 데이터를 파일로 보냅니다: (Common Lisp에서 출력 함수가 출력하는 기본위치를 조정할 수 있는 특별한 전역 변수) *standard-output*으로 선언된 스트림. 결과적으로, thunk내부의 출력은 DOT 파일로 방향을 돌릴 것입니다.
 이를 확인하기 위해 dot->png함수를 다시 살펴 봅시다:
[SOURCE]

 어떻게 dot->png 함수가 DOT 데이터를 콘솔로 보내지 않고 파일로 저장할까요? 이에 답하기 위해, 여러분은 여러분의 두뇌를 약간 활용할 필요가 있습니다. 또한, 2장에서 지역변수와 동적변수를 다뤘던 것을 회상할 필요가 있습니다.
 let명령어가 lexical 혹은 local 변수을 만든다는 것을 기억하시길 바랍니다. 저희가 (예전에)다뤘듯이, with-open-file로부터 만들어진 스트림변수는, 변수를 만들기 위해 let을 사용하는 것과 유사합니다. 그런 이유로, 이것은 lexical 스트림 변수의 생성으로 여겨집니다.
 그러나, 만약 같은 이름의 동적 변수가 이미 존재한다면, let대신에 임시로 동적 변수의 값을 새로운 값으로 덮어버릴 것입니다. *starndard-output*은 동적 변수와 같습니다. 이는 with-open-file명령어 안에서 임시로 *standard-output*의 값을 새로운 값으로 뒤덮어 버릴 수 있다는 것을 의미합니다.
 trunk를 호출하는 with-open-file내부에서 콘솔로 출력되는 어떤 값들은 이제 자동적으로 저희 파일을 경유할 것입니다. (Common Lisp의 lexical과 dynamic 변수의 설계에 의해 가능하게된) 놀랄만한 것은 비록 dot->png에서 간접적으로 호출할지라도 graph->dot함수에서의 princ문은 참이라는 것입니다.


그래프의 그림 만들기
 끝으로, 몇몇 노드와 간선으로 쉽게 그래프를 만들수 있도록 모든 조각을 한데 묶어줄 함수가 필요합니다:
[SOURCE]

 이 함수는 DOT파일 이름(변수 fname)과 노드와 간선을 받으며, 그래프를 만드는데 사용합니다. 이를 수행하기 위해, dot->png함수를 호출하고 적절한 (lambda 함수)thunk를 생성하였습니다. thunk는 일반적으로 인자를 취하지 않습니다.
 graph->dot함수는 지연 계산(delayed compuation)처럼 thunk내부에서 호출됩니다. 특이하게도, 여러분이 graph->dot을 직접 호출하였다면, 이것의 출력이 콘솔에서 보일 것입니다. 그러나 thunk내부에 있다면, 이는 dot->png함수 내부에서 호출될 것이고, 출력은 graph->png의 첫번째 인자로 들어온 파일 이름으로 DOT파일을 생성하는데 사용될 것입니다.
 새로운 함수로 마법사의 집에 대한 그래프를 그려봅시다!
[SOURCE]

 이 함수를 호출한 뒤에, 여러분은 wizard.dot.png파일과 마법사의 집에 대한 지도를 확인할 수 있습니다:
[PIC]

 지구상에서 가장 예쁜 그래프는 아닐지라도, 이는 정보를 담고 있으며 이해하기 쉽습니다. 또한, 코드는 매우 유연하고, 노드와 간선 데이터에 있어 의존성이 적습니다.
 강력한 이 유틸리티로, 저희는 Lisp프로그램에서 상호 연관된 데이터에서 쉽게 그래프를 생성할 수 있습니다. 복잡한 데이터를 다룰때, 이러한 기법이 귀중한 디버깅 도구가 되는 것을 발견하실 수 있을것입니다.


무방향그래프 생성하기
 간선에 화살표를 가진 그래프를 방향그래프(directed graph)라 부릅니다:
[PIC]

 그러나, 때때로 저희는, 하나의 간선으로 두 방향을 경유할 수 있는, 방향이 없는 데이터를 지녀야 합니다. 이와 같은 그래프는 방향그래프보다 복잡하지 않고, 이해하기 쉽습니다:
[PIC]

 다음 코드는 저희 그래프유틸리티를 무방향그래프(undirected graph)를 그리게 하는 새로운 함수로 확장시킵니다:
[SOURCE]

 이 코드는 방향그래프를 만들기 위한 코드와 매우 유사합니다. 차이점을 살펴봅시다.
 udeges->dot 함수는 edges->dot 함수와 매우 유사합니다. 그러나 저희가 그리는 그래프는 동일한 노드 사이에 다수의 방향성 간선을 지닐 것이며, 저희는 이를 무방향성 간선 하나로 바꾸길 원합니다. 예를들어, 마법사 지도에서 저희는 동쪽으로 가서 문을 통해 정원에서 거실로 갈 수 있습니다. 물론, 저희는 서쪽으로 같은 문을 통해 거실에서 정원으로 갈 수 있습니다. 무방향그래프에서 저희는 이것이 붕괴되길 원합니다; 단순히 "정원과 거실 사이에는 하나의 문이 있습니다" 라고 말하길 원합니다.
 uedges->dot함수는 maplist함수를 사용하여 간선 리스트를 통해 중복된 간선들을 지웁니다. 이는, 함수안에서 현재 항목만이 아닌 리스트의 전체를 받는 점을 제외하면, mapcar함수와 동일합니다:
[REPL]

 maplist 함수는 현재 항목부터 마지막까지 리스트에 있는 모든 것을 print함수로 보냅니다. 그리고 uedges->dot은, 간선 리스트에서 나중에 보이는 노드의 목적지가 어디인지 확인하는 maplist로부터 얻은, 미래의 노드 정보를 이용합니다. assoc 함수로 (cdr lst)로 계산된 남아있는 간선 리스트에서 현재 간선  살펴봄으로써 실제 확인이 끝나게 됩니다. 이러한 경우, 이번 간선은 건너뛰는데 따라서 간선 쌍중 하나만이 출력될 것입니다.
 DOT데이터를 생성할때 방향그래프대신 단순한 그래프를 기술한다는 점을 제외하면, ugraph->dot함수는 graph->dot함수와 같습니다. ugraph->png함수는 graph->dot대신에 ugraph->dot를 호출한다는 점을 빼면 graph->png함수와 근본적으로 같습니다.
 dot->png함수를 다른 thunk를 취하도록 설계하였음으로 저희는 다른 DOT데이터 생성자와 작업할 수 있습니다. 이제 이것의 유연성을 이용하여 무방향그래프를 출력하는 함수를 생성합니다. 예를 들기 위해, 마법사의 집의 무방향그래프를 생성해 봅시다:
[SOURCE]

 여기, 저희가 만들기를 원했던 "uwizard.dot"파일이 있습니다. *wizard-nodes*와 *wizard-deges*변수는 마법사 세계의 지도의 노드와 간선들을 서술하는 데이터를 포함하고 있습니다. 이 코드는, 이와 같이 uwizard.dot.png파일을 생성합니다:
[PIC]

 이제 여러분은 방향성 무방향성 그래프에 적합한 유틸리티를 가졌으며, 이 함수를 graph-util.lisp로 작성하여, 이를 다른 프로그램에서 접근 할 수 있게 하였습니다.


여러분이 배운것
 이번장에서 특이한 리스트 형태을 다루었고 수학적 그래프를 위한 그림그리는 라이브러리를 만들었습니다. 이러한 과정을 거치면서, 여러분은 다음과 같은 것을 배웠습니다.
 
z Lisp에서  nil이 아닌 값으로 끝나는 리스트를 만들 수 있다. 마지막 항목전에 추가로 점이 보이는 리스트가 있고 이를 dotted list라 부릅니다.
z Pairs는 리스트 그 자체가 아닌 두 항목을 써로 cons할때 얻는 것이다. 오직 두 항목만을 포함하는 dotted list를 통해서 얻을 수 있습니다.
z Circular list은 마지막 cons cell이 리스트의 처음 cons cell을 가리킨다.
z Association lists (alists)는 pairs의 list이다. 값과 연관된 key의 form으로 data를 저장할 때 사용 할 수 있습니다.
z Lisp 문법 표현식은 저장하고 list-like와 hierarchical data를 표현하기에 좋다. 추가 툴들은 더욱 복잡한 data를 보여줌에 있어 유용할 것입니다.
z 여러분의 데이터가 수학적 그래프 틀안에 있다면, 데이터를 그림으로 만들어 내는데에 있어 Graphviz를 사용하는 것은 유용하다.
z Lisp 프로그램에 있어 텍스트로된 데이터를 생성하는 일반적인 기법은, 디버깅의 편의를 위해 텍스트를 콘솔에 출력하고, 이 함수를 thunks로 받는 함수를 작성하는 것이다. 그러면 이 thunk를, 콘솔 출력을 잡고 텍스트를 적절한 목적지로 파일을 작성하는 다른 함수로 보낼 수 있습니다.