7장. 기본 List를 뛰어넘어

 이번 장에서, 저희는 기본 List 개념을 뛰어 넘을 것입니다.
 저희는 특별한 종류의 list들에 대해 이야기를 나눌 것이며, list 조작을 새로운 단계로 데려다줄 게임을 작성할 것입니다


Exotic Lists

 3장에서 배웠듯이, Lisp에서의 list는 cons cells-두 data 조각을 서로 연결 시킬 수 있는작은 data 구조-로 구성되었습니다. list의 마지막 cons cel의 오른쪽 칸은 nil을 담을 것입니다. 몇몇 cons cell들을 서로 이음으로써, 어떤 길이의 list라도 만들 수 있습니다. 예를 들어, 이것은 1, 2, 그리고 3의 list를 만듬으로써 cons cell들을 어떻게 사용하는지에 대한 것입니다:
[source]

[pic]


 list가 cons cell들의 사슬이라고 인간 생각하기엔 매우 복잡하기 때문에, Lisp는 특별히, 그런 list들을 출력하기 위한 간단한 문법을 취하였습니다. cons cell들의 사슬이 REPL에서 평가됨으로써 여러분은 볼 수 있습니다.
[source]

 Lisp는, REPL에서 사슬을 우리에게 되풀이하여 보여줄때, 간단한 list 문법을 사용합니다. 이것은 세가지 항목이 있는 list로 cons cell 문자열을 보여줍니다. 기억해야할 중요한 점은 보여짐에 있서 표면상 완전히 다르다는 것입니다. Lisp list가 어떻게 보여지든지 간에, 근복적으로, 이것은 항상 cons cell사슬을 유지합니다.


Dotted Lists

 그러면, 고전 "cons들의 문자열" 형식에서 벗어나면 어떤 일이 일어날까요? list를 출력할때 Lisp환경은 이런것을 어떻게 다룰 까요?

 이와 같은 1, 2, 그리고 3을 갖는 list를 만든다고 가정해 봅시다:
[source]


 여기에선, list의 세번째의 숫자위한 세번째 cons cell을 만드는 대신에, 이전 cell의 오른쪽 칸에 넣습니다. Lisp REPL에 이런 구조를 입력하면 어떤 것이 출력될 까요? 시도해 봅시다:
[source]


 nil-terminated list의 적절한 지점에서 list의 마지막 항목을 찾을 수 없는 것을 나타내기 위해, Lisp는 마지막 항목 앞에 점을 놓습니다. 이 점은 기본적으로 Lisp의 방법으로, "저는 여러분이 입력한 이 구조를 list 표현법을 사용하여 출력하려고 노력했으나, list의 마지막 항목 제가 예상한 nil을 포함하지 않았습니다; 대신에, 이것은 3을 포함하였습니다.",  라고 말하는 것입니다.


 nil이 아닌 다른 것으로 끝이나는 Lisp의 list는 점이 찍힌 리스트(dotted list)로 언급되어집니다. Dotted list는 Lisp대륙에서 이상한(oddity) 부류입니다. 그들 자체 만으로는, Lisp프로그래밍을 위한 유용한 도구가 아닙니다. 평범한 방식대로(regular practice) dotted list에 data를 저장하는것은 Lisp 프로그래머에게 매우 드문일 입니다. 그러나, Lisp에서 cons cell의 충만함(pervasiveness)를 주기 위해, 여러분은 cons cell사슬의 마지막에서 nil이-아닌 값을 자주 마주치게 될 것입니다. 이것이, 여러분이 직접적으로 사용하지 않더라도,  점이 찍힌 list와 친해져야 하는 이유입니다


 이 점 표기법을 다르게 생각하는 방법은 이것을 단순히 data mode에서 사용하는 cons 명령어를 위한 대안 문법이라 생각하는 것입니다. 사실, 여러분이 인생을 피곤하게 만들고 싶다면, 이와 같은 점 표기법을 사용한 적절한 list들로 만들 수 도 있습니다.
[source]

 Lisp는 list-printing mecanism의 일관성을 유지하여 최종 cons cell을 보여주기 때문에 dotted list에서의 점은 단순하게 보여집니다.


Pairs

Lisp 프로그램에서의 점이 찍힌 list를 평범하고 일상적으로 사용하는 것중 하나는 우아하게 쌍(pairs)을 표현하는 것입니다. 예를 들어, 2와 3의 쌍을 표현하고자 표현하기 원한다고 가정해봅시다. 이것을 행할 하나의 방법은 이 두 수를 서로 cons하는 것입니다:
[source]

 본질적으로, 여러분이 여기서 할것은 점이 찍힌 길이가 2인 list를 만드는 것입니다. 예상했듯이, Lisp는 쌍을 표시하기 위해 점 표기법을 사용합니다.

 Lisp에서 이러한 방법으로 쌍을 생성하는 것은 매우 편리하고 효율적입니다. 표준 car와 cdr명령을 사용하여 쌍에서 멤버(member)를 추출할 수 있기 때문에, 이것은 편리합니다. Lisp환경은 두 항목을 연결하기 위해 오직 단일 cons cell만 할당할 필요가 있기 때문에, 이것은 비교적 효율적입니다

 이러한 쌍의 형식은 Lisp 프로그램에서 일상적으로 사용되어 집니다. 예를 들어, 여러분이 복잡한 data 구조에 점의 x-와 y-coordinates(좌표계)나 key/value(키/값) 쌍을 저장할때 사용할 수 있습니다. association(연관) list를 다룰때 여기 나온것을 쌍을 위해 사용하는 것을 보게 될 것입니다


Circular Lists

여기 list '(1 2 3)으로 구성된 cons sell을 설명하기 위해 3장에서 사용했던 그림이 있습니다:
[pic]

 이제 저희가 이 list의 괴상한 돌연변이를 만든다고 가정해 봅시다. 세번째 cons cell의 cdr이 nil대신에 첫번째 cons cell을 가리키도록 해봅시다:
[pic]

 list에 있는 모든 cons cell 이론적으로 메모리상에서 분리된 객체(object)처럼 존재합니다. cell에서의 car와 cdr 의 위치로 메모리에 있는 다른 객체를 지정할 수 있기 때문에, cons cell은 list의 cons cell의 시작부분을 가리킬 수 있습니다. 이것을 circular list(순환 리스트)라 부릅니다.

 그러나 어떤 Common Lisp 환경에서 circular list에 관한 실험을 하기 전에, 여러분은 이 명령어를 실행해야만 합니다:
[source]

 *print-circle*를 true로 설정하는 것은, 여러분이 자기-참조형 data 구조에 관한 속임수(shenanigans)를 계획하고 있고 여러분이 만든 어떤 기괴한 것을 화면에 출력할때 추가적인 주의가 필요하다는 것을, Lisp에게 경고하는 것입니다. 만일 여러분이 이 변수를 설정하지 않고 circular list를 출력한다면, 어떤일이 일어나는지 말해주지 않지만, 출력결과는, 예쁘지 않을것입니다(여러분이 stack overflow와 무한 loop 출력에서 아름다움을 찾을수 없다면)

 *print-circle*을 true로 설정하면, Common Lisp는 data 구조를 출력하기 위한 더욱 복잡해진 출력 방식을 이용할 것입니다. (기본적으로 성능을 향상시키기 위해 막아놓은) 이 방식은 여러분이 이전에 봤던 cons cell을 실행시키는지 확인하고, 무한 loop에 빠지지 않도록 출력합니다.

 circular list를 만드는 것은 어떻게 할까요? 가장 간단한 방법은 다음과 같이 setf 명령어를 사용하여 첫번째 인자로 추가할 것을 넣는 것입니다
[source]

 이 예제에서, 저희는 nil을 자신을 참조하는 간단한 리스트로 교체함으로써 무한 list '(1 2 3 1 2 3 1 2 3 ...)을 만들었습니다

 이번 예제와 같이, 복잡한 표현식을 setf의 첫번째 인자에 위치시키는 능력은 매우 멋지며, 9장에서 더 자세히 살펴볼 것입니다.

NOTE
CLISP(그리고 다는 Common Lisps)는 circular list의 출력을 매우 사려깊게 다룰수 있습니다. 어찌됐든, list의 한 부분이 다른 부분을 참조한다는 사실을 다루었습니다. 여러분이 보았듯이,은밀(esteric)하지만, 매우 영리하게, 자기-참조를 표현식(expression)의 일부로 연결하는 표기법(notation)을 사용합니다. 그러나, 어떠한 증가하는 자기 참조형 data의 복잡함으로 이러한 data형식을 위해 Lisp printer에게 제공된 출력된 결과가 프로그래머를 공감하기 더욱 어렵게 할 수 있다는 것을, 여러분이 또한 인식할 수 있다는 것을 확신합니다


Association Lists

cons cell들로 만들수 있는 특출하게 유용한 data구조 중 하나는 연관 리스트(association list), 짧게 alist입니다. alist는 list에 저장된  키/값(key/value)으로 이루어 집니다.

 관례에 따라서, 만일 key가 list에 반복하여 보인다면, 첫번째 보이는 key가 desired value를 포함한다고 가정합니다. 예를들어, 여기 Bill, Lisa, John의 커피 주문을 나타내는 alist가 있습니다
[source]

주어진 사람의 주문을 살펴보기 위해, assoc 함수를 사용합니다:
[source]

이 함수는 list에서 desired key로 시작하는 것을 찾고, key/value쌍을 반환합니다. 이제, 음료 주문을 가져다 주기 전에, Lisa가 여러분을 멈추게하고 그녀의 주문이 조금 더 맛있는 것으로 바꾼다고 가정해봅시다. 여러분은 push함수로 그녀의 주문을 바꿀 수 있습니다.
[source]
 이 함수는 단순히 새로운 항목을 이미 존재하는 list의 앞부분에 추가합니다.

 기본적으로, association list에서 key를 참조하는 처음 보다 더 나중에 참조한 것을 우선시함므로, Lisa의 주문 small drip coffee는 더 최근 주문으로 대체됩니다:
[source]

 여러분이 보는것처럼, alist는 어떤 변화가 가능한 key/value 쌍 모음의 자취를 추적하기 좋은 방법입니다. alist를 "이해하기, Lisp 함수와 함께 조작하기, 출력된 것을 이해하기"가 쉽습니다. (어찌됫건, 그것들은 단지 pair들의 list입니다)

 더욱이,  alist에 값이 저장되면, 어떤 data의 변화를 감시하기 쉽게, 그것을 영원히 유지합니다. 커피 예에서, Lisa의 주문 drip coffee는 교체되었더라도 여전히 남아 있습니다.

 그러나, alist는 하나의 중대한 한계점을 가지고 있습니다: (12개의 항목 보다 적은(under a dozen items))매우 짧은 list를 다룰게 아니라면, data를 받거나 저장하기 위한 효율적인 방법이 아닙니다. 비록 alist가 Lisp 프로그래머의 toolbox의 첫번째 tool중 하나이지만, 이것이 비 효율적이기 때문에, program matures처럼 다른 형식의 data 구조로 교체되어야만 합니다. (9장에서, 저희는 alist와 같은 list-기반 data구조의 성능 한계에 대해 더욱 자세히 다룰 것입니다)



Coping with Complicated Data

 cons cell은 list-와유사한 구조를 표현하기 위한 좋은 도구 입니다. 사실, 대다수의 Lisp프로그래머들은 성능 제약이 없는 프로그래밍 작업을 할때 그것들에게 전적으로 의지합니다. 이 조작물과 cons cell들로 만들어진 visualization of structures들은 Lisp 디자인의 중심이게 때문에, 이러한 구조는 사용하기와 디버그하기에 매우 편리합니다

 사실, 성능 제약이 있을지라도, cons cell의 구조는 좋은 선택이 될 수 있습니다. Lisp 컴파일러는 보통 cons cell을 단일 어셈블리 명령어로 바꾸어 줄일 수 있습니다.


Visualizing Tree-like Data


3장에서 다루었듯이, Lisp프로그램에서 data(그리고 code)는 문법 표현식(syntax 
expressions)으로 표현됩니다. 이런 형식에서, data는 nested list를 사용하여 나타내어지고, 보통 각 list앞에 있는 Lisp symbol들은 data 구조를 설명합니다.

 예를 들어, 여러분이 Lisp에서 집을 구성하는 요소들을 표현하기 원한다고 가정해봅시다 :
[source]

 이 data구조는 매우 우아하게 집을 구성하는 hierarchical한 자연스런 부분 유지합니다.

 Lisp symtax expression(문법 표현식)과 비슷한 구조로 인해, 여러분은 hierarchy 수준으로 구성된 list를 볼 수 있습니다. 또한, 이것은 각 list앞에 symbol을 넣음으로써 symtax expression의 관습을 따릅니다. 예를들어, 창문을 설명하는 list가 windows symbol을 포함하고, 유리, 창틀, 커튼 3가지 항목이 따라오는 것을 볼 수 있습니다.

 보시다시피, 이러한 방법으로 계층적이며(hierarchical) 자연의 나무-와같은 data는 매우 자연스럽게 표현되어집니다. 사실, 많은 Lisper들은 XML(계층적 data를 표현하는 유명한 형식)을 초기 Lisp 문법 표현식 형식의 재발명으로 여깁니다.


 상대적으로 cons cell에 data를 저장하기 쉬울지라도, 여러분이 나무와-같은 구조들 뒤로가서 문법 표현식안에 저장된 data를 시각화 하는 것은 어려울 수가 있습니다. 예를들어, 문법 표현식에 저장된 수학적 그래프를 가졌다고 가정해봅니다. 이 그래프 종류들, 간선들로 이어진 그래프의 임의의 노드들은 컴퓨터 프로그램에서 보이도록 하는 것이 어렵다고 악명이 났습니다.

 Lisp의 우아한 cons cell을 표현하는 system이라도 이와 같은 data를 충분히 도와줄수는 없습니다. 다음으로, 저희는 그래프같이 시각화 시키기 위한 option을 살펴볼 것입니다.


Visualizing Graphs

 수학에서, 그래프는 간선으로 연결된 노드들의 가지로 구성되었습니다. 이 노드들 혹은 간선들은 이것들과 관련된 추가 data를 가져야만 합니다.

 그래프를 cons cell에 저장할 수 있더라도, 보여지게 하는 것은 어렵습니다. 5장에서  두 alist에 마법사의 집의 (directed graph으로 구성된)지도를 저장했을때 이것을 보았습니다: 하나는 노드의 정보를 포함하고 있고 다른 하나는 간선의 정보를 포함하는 것. 이번장을 위해, 여기 나타난 것과 같이 그것들의 이름을 *wizard-nodes*와 *wizard-edges*로 다시 지었습니다:
[source]

 보시다시피,  이 raw data table로부터 게임세계의 구조를 이해하기에는 어려움이있습니다. 불행히도, 그래프나 간단한 tree 구조를 넘어선 다른 성질을 포함하는 형태를 지니는
data는 매우 흔합니다. 만일 저희가, 이 data로 예쁜 그래프의 그림을 생성하는 것을 최적하게 처리할 수 있는, 툴을 가졌다면 좋지 않았을까요? 다행히도, 이 작업을 완벽히 수행할, 다음에 시도해볼 환상적인 open source tool이 있습니다.


Creating a Graph

 Graphviz는 여러분의 data로부터 그래프를 생성합니다. 실제로, 여러분은 5장에서 간단하게 Graphviz로 마법사의 집을 표현한 것을 보았습니다.
[pic]

 Graphviz는 open source이며 Graphviz website(http://www.graphviz.org/)에서 얻을 수 있습니다. 이것을 다운로드 받고 설치하고 나면, 그래프를 만드는 것은 쉽습니다. 첫번째로, 여러분은 그래프의 모양을 설명하는 DOT파일을 만들 것입니다. 예를들어, Graphviz에서, 여러분에 컴퓨터에 test.dot이란 파일을 만들고 다음에 나오는 정보를 입력합니다:
[source]

 이것은 화살표로 노드 A와 B가 연결된 directed graph를 정의합니다. (DOT 파일 형식에는, Graphviz website에 있는 문서화된것 만큼의, 수많은 문법 option들이 있습니다.)

 이제, DOT 파일에서 그래프 bitmap을 생성하기 위해 command line에서 다음과 같이 (Graphviz utilities중 하나인)neato를 실행합니다:
[cmd]

 이것은 test.dot.png파일안에 이와 같은 그림을 생성해 줍니다:
[pic]

 보시다시피, Graphviz는 사용하기 간단합니다. 사소한 그래프 문제가 있지만, 이것은 심지어 크고 복잡한 그래프를 빠르게 생성할 수 있습니다. (컴퓨터 과학에서 완벽한 그래프 형태는 여전히 풀리지 않은 문제이기 때문에, Graphviz 형태는 완벽하지 않습니다. 그러나, 그것은 여러분이 기대햇던 것보다도 완벽에 가깝습니다.)

 이제 여러분이 가진 Graphviz를 사용하여, Lisp에서 편리하게 그래프를 그려줄 command 라이브러리를 만들어 봅시다. 우리는 adventure 게임 세계의 어떤 그래프를 그리기 위해 이것을 이용할 수 있습니다


NOTE
 이번 장의 예제에 사용된 그래프 utilities는 Common Lisp의 표준의 일부가 아닌 방법으로 특정 system call을 수행합니다 이것은 CLISP환경에서만 동작합니다. 다른 Lisp환경에서 돌아가도록 약간의 code 수정이 필요합니다


Generating the DOT Information

 graph drawing library를 만들기 위해, 저희는 그래프의 세부사항을 담은 Graphviz DOT파일을 생성하기 원합니다. 이것을 하기 위해,  게이머가 돌아다닐 수 있는 노드 구분자의 변환과, 이 노드들을 연결하는 간선들의 변환, 그리고 모든 노드와 간선 label을 생성할 필요가 있습니다. 마법사의 세계의 지도를 나타내는 노드를 이용하여 저희 라이브러리를 테스트 할 것입니다.


Converting Node Identifiers

 노드들을 DOT 형식으로 변환할때,우리가 필요한 첫번째 것은 노드 식별자들 유효환 DOT 식별자로 변환하는 것입니다. 우리는 dot-name함수를 작성함으로써 이러한 일을 합니다:
[source]

 DOT형식에 있는 노드는 오직 문자(letters), 숫자, 밑줄문자(under-score character)만 포함 할 수 있습니다. 우리가 사용할 노드 식별자를 합법적(legal)으로 만들기 위해,  금지된 문자들을 밑줄로 바꿀 것입니다. 여기 dot-name 함수가 사용된 예제가 있습니다:
[source]

 이 함수, prin1-to-string함수를 사용하여 변화시킬 수 있는, 어떠한 기본 Lisp 형태도 받아 들입니다. 문자열의 산출하는 작업과 필요하다면 밑줄로 치환하는 작업을 할 수 있습니다.

NOTE

 간단히 하기 위해, dot-name함수는 알파벳이 아닌 구성물의 노드 식별자의 차이를 구분할 수 없다고 가정합니다. 예를 들어, 여러분이 foo?라고 불리는 하나의 노드를 가지고 있고 다른 노드를 foo*라고 부른다면 dot-name함수는 그것들 모두, 이름이 충돌을 유발시키는, foo_로 바꿀것입니다.


 substitute-if 함수는 테스트 함수의 결과에 기반하여 값을 변화시킵니다:
[source]


 이번 예제에서 테스트 함수, digit-char-p는, 문자열에 있는 문자인지 숫자인지를 말해줍니다. 이와 같은, 값을 받아들이고 값에 기반하여 참을 결정하는, 테스트 함수는 종종 predicates로 언급되어집니다.

 또다른 substitute-if 함수의 흥미로운 속성으로는 list에서도 사용할 수 있다는 것입니다:
[source]

 여기, list에 있는 모든 홀수는 0으로 변경되었습니다. substitute-if 함수는 generic 함수 -인자로 다양한 datatype들을 수용할 수 있고 그것들을 적절하게 다루는 함수- 의 한 예입니다. (Generic programming은 9장에서 다뤄집니다.)

 dot-name함수 안에서 substitute-if를 사용할때에는 알파뱃이 아닌 문자만 치환합니다.


 반면 이 테스트 predicate와 반대의 것이 Common Lisp에서 가능하며, 이 predicate를 바로 만드는 것은 쉽습니다.

 dot-name함수안에서 다음 조각은, 올바른 행동을 하기 위한 predicate 함수를 만듭니다:
[source]

Lisp는 이미 이것이 알파벳인지 말해주는 alphanumericp라 불리는 predicate 함수를 가졌습니다. 그러나, 저희는 오직 알파벳이 아닌 문자만 치환하기 원합니다. 저희는 이것을  고-수준 함수 complement를 통과시킴으로써 alphanumbericp의 반대 함수를 만들 수 있습니다.

 substitute-if에서 이 함수를 통과하면, substitute-if를 체워주기 위한 새로운 함수로 top level을 오염시키는 defun을 사용할 필요없이, 우리가 원하는 것을 얻습니다.

NOTE
#TODO
Common Lisp는 substitute-if-not이라 불리는 함수를 가지고 있습니다
dot-name함수에서 사용할 수 있는 lambda함수 밖으로 빠져나오지 않게하는 substitute-if대신에
 Common Lisp has a function called substitute-if-not that could have been used in the dot-name function in lieu of substitute-if to allow us to leave the not out of the lambda function.

 그러나 끝에 not이 있는 Lisp함수는 피하는게 좋습니다. 그것들은 아마도 ANSI Common Lisp 표준 차기 버전에서 사라질 것이며, 이것이 의미하는 것은 그것들이 deprecated로 간주된다는 것입니다.


Adding Labels to Graph Nodes

 이제 우리는 DOT에 알맞게 만드는 노드 식별자를 tweak할 수 있고, 이것이 그려질때 노드에서 보여질 label을 생성하는 다른 함수들을 작성합시다. label은 노드 이름과 노드 alist에 있는 노드와 연결된 data로 구성됬습니다. 저희는 또한 label안에 매우 많은 text를 타이핑 하지 않는다는 것을 확실히 해야할 필요가 있습니다. 여기 label을 생성하는 code가 있습니다:
[source]

*max-label-length* 는 label에 들어갈 최대 문자수를 결정할 전역 변수 입니다.

is a global variable that determines the maximum 
number of characters for the label.

만약 노드 label이 최대치보다 길다면 일부가 짤려나가고, 그 사실을 나타내는 생략부호(ellipsis)가 추가될 것입니다.

 If a node label is larger than the limit Z, it 
gets cropped, and an ellipsis is added to indicate that fact [.

write-to-string 함수는 우리가 전에 썼던 prin1-to-string함수와 유사합니다 --이것은 표현식을 문자열로 씁니다.

 The write-to-string function Y is similar to the prin1-to-string function we used earlier?
it writes an expression to a string.

 :pretty 인자는,  특정 Lisp함수에서 사용되어지는 여러분이 통과하기 원하는 인자를 고르는, keyword 인자의 예제입니다,

이변 경우 write-to-string는, Lisp에게 이것을 예쁘게 만들면서 문자열을 변경시키지 말라고 말하는 것입니다.

 In the case of write-to-string, it tells Lisp not to alter the string to make 
it pretty.

이것이 없으면, Lisp는 눈에 더 잘보이게 하기 위해 만든 개행이나 탭을 변형시킨 문자열에 넣을 것입니다.

 Without this, Lisp would place new lines or tabs into our converted 
string to make it look more pleasing to the eye.


:pretty keyword인자를 nil로 설정함으로써,
Lisp에게 어떠한 꾸밈도 없이 표현식을 출력하라고 말합니다.
 By setting the :pretty keyword parameter to nil, we are telling Lisp to output the expression without any 
decorations.

새로운 줄을 갖는 label은
Graphviz를 혼란에 빠트릴수 있으므로,
저희는 Lisp에게 어떤 ideas를 주길 원하지 않습니다.
 (Having new lines in a label can confuse Graphviz, so we don’t 
want to give Lisp any ideas.)




Generating the DOT Information for the Nodes

 이제 우리는 각 노트의 이름과 label을 동시에 생성할 수 있고, 다음과 같이, node들의 alist를 받아 그것으로 부호화된 DOT 정보를 생성하는 함수를 작성할 수 있습니다:
[source]

#TODO
이 함수는 노드 list에 있는 모든 node들을
 통해서 가기 위해
mapc를 사용하고, princ는 DOT 형식에 있는 각 노드를 화면에 직접 출력합니다
This function uses mapc to go through every node in the list of nodes X, 
and princ prints each node in the DOT format directly to the screen.

mapc는 미묘하게 더 효율적인 mapcar의 변종입니다; 차이점은 이것은 변형된 list를 반환하지 않는다는 점입니다.
 mapc is a slightly more efficient variant of mapcar; the difference is that it does not return the transformed list.

nodes->dot함수는 data를 변경하기 위해 생성한 dot-name과 dot-label함수를 사용합니다.
 The nodes->dot function uses the dot-name Y and dot-label 
Z functions we created to convert the data.


 후에, 이 정보를 담기 위해 파일을 생성하기 원할때, 우리는 console로부터 이 data를 가져오는 함수를 작성해야 합니다
Later, when we want to generate a file that contains this information, we’ll 
write a function that takes this data from the console.

직접 파일에 작성하는 대신에, 파일을 생성하는 중계자로 console을 사용하는 것이 조금 이상하게 보여지지만, 이것은 실제로 Lisp에서 일반적인 paradiam입니다.
It may seem a bit odd to use the console as an intermediary for generating 
a file, instead of just writing directly into a file, but this is actually a common paradigm in Lisp.

이러한 접근의 이점으로 출력된 줄들을 보기 쉬운 REPL에서 쉽게 code를 디버그 할 수 있습니다
 One immediate benefit of this approach is that we can easily debug the code in the REPL, where the printed lines are easy to see.

이제 nodes-dot함수를 이용하여 마법사의 집에 있는 노드에 대한 DOT 정보를 생성해 봅시다:
[source]

여기,여러분은, DOT 형식에서 보여지는, 마법사의 집의 노드와 각 노드의 생략된 정보들을 볼 수 있습니다.
Here, you can see the nodes of the wizard’s house and an abbreviated 
version of the information attached to each node, shown in DOT format. 


nodes->dot함수로부터 반환된 값에는 관심이 없다는 것을 알립니다.
 - 필요한 정보는 REPL에서 출력된 정보입니다.
Notice that we are not interested in the value returned from the nodes->dot 
function - only in the information it prints in the REPL.

Lisper들은 저희가 이 함수의 부수효과에 관심 있다고 말하고 싶습니다.
 Lispers would say that we are only interested in the side effects of this function.

#TODO
mapc가 list를 반환하지 않지만, 이것은
여전히
야기시킵니다

code

 Although mapc does not return the list,
  it still causes the code to iterate
   through the list and generate the same printed output
    that using mapcar would have,
 so it generates the same side effects as mapcar, a bit more quickly.



Converting Edges into DOT Format

다음단계는 노드를 이어주는 간선을 위한 DOT정보를 생성하는 것입니다.
The next step is to generate the DOT information for the edges that link 
our nodes.

이것은  visual 그래프에서 화살표가 될 것입니다.

 These will become the arrows in our visual graph.
 
 edges->dot함수는 또다시 필요한 console로 직접적으로 출력되는 data를 생성합니다.
  The function 
edges->dot generates the necessary data, again by printing it directly to the 
console.
[source]

 이 함수를
  마법사의 집의 간선에 대한 DOT 정보를 생성하기 위해 사용해 봅시다

Let’s use this function to generate the DOT information for the edges of 
the wizard’s house:
[source]

여기서,
우리는 DOT 형식에 있는 마법사의 집에 있는 노드들 사이의 관계를 명백히 볼 수 있습니다.

Here, we can clearly see the relationships between the nodes in the wiz-
ard’s house, in the DOT format.

예를 들어, 첫번째 줄은
(WEST DOOR)라 이름표가 붙은 
간선을 이용하여
플레이어가 LIVING_ROOM노드에서 GARDEN노드로 걷고 있다는 것을 나타냅니다


 For instance, the first line X indicates that 
the player can walk from the LIVING_ROOM node to the GARDEN node by using an 
edge labeled (WEST DOOR).



Generating All the DOT Data

DOT data 생성하는것을 완료하기 위해, nodes->dot과 edges->dot을 함께 호출하고, 다음과 같이 추가 장식으로 이것을 꾸미도록 합니다.
To complete our generation of the DOT data, we call both nodes->dot and 
edges->dot, and wrap it up with some extra decoration, as follows:
[source]

이 함수는
directional graph로 그래프를 정의함으로써 모든것을 한데 모아 묶고,
nodes->dot과 edges-.dot함수를 호출합니다.



This function ties everything together by defining our graph as a direc-
tional graph X, and then calling our nodes->dot Y and edges->dot Z functions.


여기 새로운 라이브러리로 만들어진 저희 마법사 게임의 최종 DOT정보처럼 보이는 것이 있습니다
Here’s what the final DOT information for our wizard game looks like, 
as created by our new library:
[source]

우리는 이제,
예쁜 그림을 생성할때 필요한 마법사 지도의 모든 세부사항 가진,
더 낳은 Graphviz DOT파일을 생성할 수 있습니다

We can now generate a proper Graphviz DOT file that captures all the 
details of our wizard map that we need to generate a pretty picture.



이것은
게이머가 방문할 수 있는 노드와,
이 노드와 연결되는 간선들, 그리고
모든 노드와 간선들의 label을 포함하고 있습니다.
 These 
include the nodes the player can visit, the edges connecting these nodes, and 
labels for every node and edge.



Turning the DOT File into a Picture
DOT파일을 실제 bitmap으로 바꾸기 위해,
DOT 파일 data를 잡아서
파일에 넣고,
이와 같이 dot 명령어를 system command line에서 직접적으로 실행합니다

To turn the DOT file into an actual bitmap, we capture the DOT file data, 
put it into a file, and then execute the dot command directly from the system 
command line, like this:
[source]


이 함수는
몇몇 진보된 Lisp기술을 사용하며
그래프 그리는 라이브러리에 있어
중요한 행동을 수행합니다

This function performs the most critical actions in our graph drawing 
library, using some advanced Lisp techniques.

첫번째로,
dot->png함수는
가능한 재활용
을 유지하기위해
graph->dot함수를 직접적으로 호출하지 않습니다.
First, to keep this dot->png function as reusable as possible, the graph->dot 
function isn’t called directly.

대신에, dot->png를 thunk를 받아들이도록 짭니다.
 Instead, we write dot->png to accept a thunk X.



Using Thunks
It is common in Lisp to create small functions that have zero arguments. These 
functions are officially called nullary functions. However, Lispers will often 
create such functions in order to describe a computation that they don’t want 
to run until later. In this scenario, a function without arguments is com-
monly called a thunk or a suspension. In this case, the thunk our dot->png func-
tion needs would be a function that, when called, prints a DOT file to the 
console.
Why is a thunk useful in our dot->png function? Remember that the easi-
est way for us to write and debug graph->dot and other DOT file functions is to 
have them print their results directly to the console. When we call graph->dot, 
it doesn’t return its results as a value, but, instead, prints them at the console 
as a side effect. Therefore, we can’t just pass the value of graph->dot to dot->png. 
Instead, we pass in graph->dot as a thunk. Then dot->png is responsible for call-
ing graph->dot, capturing the results, and sending them to a file.

Since it is so common to generate textual data with a computer program, 
this particular technique is used a lot in Lisp code: First, we print stuff right 
to the console; next, we wrap it in a thunk; finally, we redirect the results to 
some other location.
As you’ll see in Chapter 14, Lispers who follow the functional program-
ming style eschew this technique, because side effects are required when 
printing to the console.
Writing to a File
The function with-open-file enables dot->png to write information to a file Y. 
To give you a feel for how this function works, here’s an example that creates 
a new file named testfile.txt and writes the text “Hello File!” to it:


[source]

In this example, you can see that the first item X passed into with-open-
file becomes the name of a special Common Lisp datatype called a stream, 
which is created for us by with-open-file.
Creating a Stream
Printing functions, such as princ, can accept a stream as an optional parame-
ter. In this case, these printing functions won’t print anything to the console, 
but instead will print to the stream object.
It is important to understand that with-open-file creates a stream variable 
from a stream variable name, in the same way that let creates a variable from 
a variable name:

[source]

So if we pass the name my-stream in at the front of the first list to with-open-
file X, this is analogous to defining my-variable at the start of a let Z. A vari-
able named my-stream will be available to us in the body of with-open-file Y, in 
the same way that my-variable will be available to us in the body of the let [.
But don’t worry too much about exactly what a stream is just yet. We’ll be 
looking at them more closely in Chapter 12. For now, you just need to know 
that a stream is an object that can be connected to a file, and we can pass it to 
functions (such as princ) to write stuff to the connected file.


Understanding Keyword Parameters
The with-open-file command also makes heavy use of keyword parameters. 
Let’s look at our previous example of this command again:

[source]


A keyword parameter has two parts: the name of the parameter and the 
value of the parameter. The name of the parameter is always a symbol begin-
ning with a colon. This example has two keyword parameters: :direction X, 
which is set to :output (we’re only writing to the file and not reading it), and 
:if-exists Y, which is set to :superseded (if a file by that name already exists, 
just toss out the old version).
with-open-file has keyword parameters because opening a file is a complex 
operation, and many esoteric options are available. If with-open-file just gave 
you regular parameters to set all this, every call to with-open-file would be long 
and cumbersome due to all the parameters. Also, humans have a hard time 
looking at a long list of parameters and remembering which one does what.
As you’ve probably noticed, symbols in Common Lisp sometimes begin 
with a colon. This includes keyword parameters, which always start with a 
colon. This is because a regular symbol in Lisp can refer to something else. 
For instance, we could set a variable cigar equal to 5 and then return it:
[source]


However, sometimes we don’t want a symbol to refer to something else. 
We want to use the symbol outright, and we want it to have its own meaning. 
A colon-prepended symbol in Common Lisp (not surprisingly, called a keyword 
symbol) always means itself:
[source]

As you can see, the keyword symbol :cigar can be evaluated right at the 
REPL and already has a value X. Its value is, conveniently, :cigar. If we try to 
redefine :cigar to something else, Common Lisp won’t let us Y. The fact that 
it is constant is useful, because a Lisp compiler can potentially optimize this 
simple type of symbol more than it can optimize other types. Also, we can 
reduce errors in our code by using keyword symbols in places where we know 
a symbol just has a meaning in its own right. Sometimes a cigar is just a cigar.

Capturing the Console Output
Our dot->png sends our data to the file in a slightly different way than is shown 
in this example: by declaring the name of the stream to be *standard-output* 
(a special global variable in Common Lisp that controls the default location 
to which printing functions send their output). As a result, any printing done 
inside the thunk will be redirected to our DOT file.
Let’s look at our dot->png function again to see this:
[source]

So how exactly does the dot->png function cause our DOT data to get saved 
to a file instead of just going to the console? To answer this, you’ll need to 
exercise your brain a bit. Also, you’ll need to recall our discussion of local 
and dynamic variables in Chapter 2.
Remember that the let command usually creates a lexical, or local, variable. 
As we’ve discussed, the stream variable created by with-open-file is analogous 
to using let to create a variable. Hence, it usually leads to the creation of a 
lexical stream variable for us.
However, if a dynamic variable already exists with the same name, let will 
instead, temporarily, override the value of the dynamic variable to the new 
value. *standard-output* is such a dynamic variable. This means that we can 
temporarily override the value of *standard-output* to a new value by passing it 
into our with-open-file command X.
In the body of the with-open-file, where we call our thunk Y, any values 
printed to the console will now be automagically routed to our file, instead. 
The surprising thing (enabled by the design of lexical and dynamic variables 
in Common Lisp) is that this is also true for the princ statements in our graph-
>dot function, even though they are called indirectly from dot->png.
Creating a Picture of Our Graph
Lastly, we need a function that ties together all the pieces to let us easily 
create a graph from some nodes and edges:

[source]

This function takes the name of a DOT file (as the variable fname), as well 
as the graph’s nodes and edges X, and uses them to generate the graph. To 
do this, it calls dot->png Y and creates the appropriate thunk?a lambda func-
tion Z. As is usual for a thunk, it takes no parameters.

The graph->dot function is called inside the thunk [ as a delayed computation. 
Specifically, if we had called graph->dot directly, its output would just show up 
in the console. However, when inside the thunk, it will be called at the lei-
sure of the dot->png function, and the output will be used to generate the 
DOT file with the filename passed in as the first parameter to graph->png.
Let’s try out our new function to draw a graph of the wizard’s house!
[source]


After calling this function, you should now see a file named wizard.dot.png, 
a picture of the map of the wizard’s house:
[pic]

This may not be the prettiest graph on the planet, but it’s packed with 
information and is very easy to understand. Also, the code is extremely flexible, 
and places few dependencies on our node and edge data.
With these utilities in our arsenal, we can now easily create graphs from 
any interconnected data in our Lisp programs. You’ll find this technique to 
be a valuable debugging tool when you need to deal with complicated data.
Creating Undirected Graphs
A graph that has arrows on its edges is called a directed graph:

[pic]

But sometimes we have data that is undirected, allowing us to travel in 
both directions along an edge. Such a graph is less busy than a directed graph, 
and can be easier to understand:
[pic]

The following code expands our graph utilities with new functions that 
let us draw undirected graphs:
[source]

This code is very similar to the code for creating our directed graphs. 
Let’s look at some of the differences.

The uedges->dot function is very similar to the edges->dot function X. How-
ever, the graph we’re drawing may have multiple directed edges between the 
same nodes that we want to replace with a single, undirected edge. For instance, 
on our wizard map, we can walk from the garden to the living room by going 
east through the door. Of course, we can also walk from the living room to 
the garden by going west through the exact same door. In our undirected 
graph, we’ll want to collapse this; in essence, we just want to say, “There’s a 
door between the garden and living room.”
The uedges->dot function erases such duplicate edges by running through 
the list of edges using the maplist function. This is like the mapcar function, 
except that the function inside it receives the entire remainder of the list, not 
just the current item in the list:
[source]

The maplist function sends the print function everything in the list from 
the current item until the end. uedges->dot X then uses the information about 
future nodes it gets from maplist to check whether the destination of the node 
appears later in the edge list. The actual checking is done with the assoc func-
tion, looking for the current edge in the list of remaining edges, calculated 
as (cdr lst) Y. In this case, it skips the edge so that only one of any pair of 
edges will be printed.
The ugraph->dot Z function is similar to the graph->dot function, except 
that it describes the graph as just a graph [ when generating the DOT data, 
instead of a digraph. The ugraph->png function \ is essentially identical to the 
graph->png function, except that it calls ugraph->dot instead of graph->dot.
We designed the dot->png function to accept different thunks so it could 
work with different DOT data generators. Now we’ve used this flexibility to 
generate these functions that output pictures for undirected graphs. For 
example, let’s try generating an undirected graph for the wizard’s house:

[source]

Here, "uwizard.dot" is the name of the DOT file we want to create. The 
*wizard-nodes* and *wizard-edges* variables contain the data describing the 
nodes and edges of the map of the wizard’s world. This code generates the 
uwizard.dot.png file, which looks like this:
[pic]

Now that you have a full suite of utilities for both directed and undirected 
graphs, write these functions to a file named graph-util.lisp, so you can access 
them from other programs.
What You’ve Learned
In this chapter, we discussed exotic types of lists and created a drawing 
library for mathematical graphs. Along the way, you learned the following:
z You can create lists in Lisp that end in a value other than nil. Such lists are 
displayed with an extra dot before the last item and are called dotted lists.
z Pairs are what you get when you cons together two items that are not lists 
themselves. They can also be thought of as dotted lists that contain only 
two items.
z Circular lists are lists where the last cons cell points to an earlier cons cell 
in the same list.
z Association lists (alists) are lists of pairs. They can be used to store data that 
is in the form of keys associated with values.
z Lisp syntax expressions are great for storing and visualizing list-like and 
hierarchical data. Extra tools may be helpful for visualizing more com-
plex data.
z If your data is in the form of a mathematical graph, it’s helpful to be able 
to generate pictures of your data using Graphviz.
z A common technique for generating textual data in a Lisp program is to 
write functions that print the text to the console for easy debugging and 
wrap these functions in thunks. Then you can send these thunks to other 
functions, which capture the console output and route the text to the 
appropriate destination, such as writing it to a file.

