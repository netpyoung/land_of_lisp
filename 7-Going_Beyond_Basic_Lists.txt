7장. 기본 List를 뛰어넘어
7.Going Beyond Basic List

 이번 장에서, 저희는 기본 List 개념을 뛰어 넘을 것입니다. 저희는 특별한 종류의 list들에 대해 이야기를 나눌 것이며, list조작에 있어 새로운 단계로 데려다줄 게임을 작성할 것입니다


Exotic Lists

 3장에서 배웠듯이, Lisp에서의 list는 cons cells-두 data 조각을 서로 연결 시킬 수 있는작은 data 구조-로 구성되었습니다. list의 마지막 cons cel의 오른쪽 칸은 nil을 담을 것입니다. 몇몇 cons cell들을 서로 이음으로써, 어떤 길이의 list라도 만들 수 있습니다. 예를 들어, 이것은 1, 2, 그리고 3의 list를 만듬으로써 cons cell들을 어떻게 사용하는지에 대한 것입니다:
[source]

[pic]

 list가 cons cell들의 사슬이라고 인간 생각하기엔 매우 복잡하기 때문에, Lisp는 특별히, 그런 list들을 출력하기 위한 간단한 문법을 취하였습니다. 여러분은 이것을 cons cell들의 사슬이 REPL에서 평가된거에서 볼 수 있습니다.
[source]

 Lisp는, REPL에서 사슬을 우리에게 되풀이하여 보여줄때, 간단한 list 문법을 사용합니다. 이것은 세가지 항목이 있는 list로 cons cell 문자열을 보여줍니다. 기억해야할 중요한 점은 보여짐에 있어 이 차이점이 순전히 피상적이라는 것입니다. Lisp list가 어떻게 보여지든지 간에, 근복적으로, 이것은 항상 cons cell사슬을 유지합니다.


Dotted Lists

 그러면, 고전 "cons들의 문자열" 형식에서 벗어나면 어떤 일이 일어날까요? list를 출력할때 Lisp환경은 이런것을 어떻게 다룰까요?

 이와 같은 1, 2, 그리고 3을 갖는 list를 만든다고 가정해 봅시다:
[source]


 여기에선, list의 세번째의 숫자를 위한 세번째 cons cell을 만드는 대신에, 이전 cell의 오른쪽 칸에 넣습니다. Lisp REPL에 이런 구조를 입력하면 어떤 것이 출력될 까요? 시도해 봅시다:
[source]


 nil-로 끝나는 list(nil-terminated list)의 적절한 지점에서 list의 마지막 항목을 찾을 수 없는 것을 나타내기 위해, Lisp는 마지막 항목 앞에 점을 놓습니다. 이것은  Lisp 방식대로, "저는 여러분이 입력한 이 구조를 list 표현법을 사용하여 출력하려고 노력했으나, list의 마지막 항목 제가 예상한 nil을 포함하지 않았습니다; 대신에, 이것은 3을 포함하였습니다.",  라고 말하는 것입니다.

 nil이 아닌 다른 것으로 끝나는 Lisp의 list는 점이 찍힌 리스트(dotted list)로 언급되어집니다. Dotted list는 Lisp대륙에서 이상한(oddity) 부류입니다. 그들 자체 만으로는, Lisp프로그래밍을 위한 유용한 도구가 아닙니다. 평범한 방식대로(regular practice) dotted list에 data를 저장하는것은 Lisp 프로그래머에게 매우 드문일 입니다. 그러나, Lisp에서 pervasiveness of cons cell를 주기 위해, 여러분은 cons cell사슬의 마지막에서 nil이-아닌 값을 자주 마주치게 될 것입니다. 이것이, 여러분이 직접적으로 사용하지 않더라도, dotted list와 친해져야 하는 이유입니다


 이 점 표기법을 다르게 생각하는 방법은 이것을 단순히 data mode에서 사용하는 cons 명령어를 위한 대안 문법이라 생각하는 것입니다. 사실, 여러분이 인생을 피곤하게 만들고 싶다면, 이와 같은 점 표기법을 사용한 적절한 list들로 만들 수 도 있습니다.
[source]

 Lisp는 list-printing mecanism의 일관성을 유지하여 최종 cons cell을 보여주기 때문에 dotted list에서의 점은 단순하게 보여집니다.


Pairs

 Lisp 프로그램에서의 점이 찍힌 list를 평범하고 일상적으로 사용하는 것중 하나는 우아하게 쌍(pairs)을 표현하는 것입니다. 예를 들어, 2와 3의 쌍을 표현하기 원한다고 가정해봅시다. 이것을 행할 하나의 방법으로는 이 두 수를 서로 cons하는 것입니다:
[source]

 본질적으로, 여러분이 여기서 할 일은 점이 찍힌 길이가 2인 list를 만드는 것입니다. 예상했듯이, Lisp는 쌍을 표시하기 위해 점 표기법을 사용합니다.

 Lisp에서 이러한 방법으로 쌍을 생성하는 것은 매우 편리하고 효율적입니다. 표준 car와 cdr명령을 사용하여 쌍에서 멤버(member)를 추출할 수 있기 때문에, 이것은 편리합니다. Lisp환경은 두 항목을 연결하기 위해 오직 단일 cons cell만 할당할 필요가 있기 때문에, 이것은 비교적 효율적입니다

 이러한 쌍의 형식은 Lisp 프로그램에서 일상적으로 사용되어 집니다. 예를 들어, 여러분이 복잡한 data 구조에 점의 x-와 y-coordinates(좌표계)나 key/value(키/값) 쌍을 저장할때 사용할 수 있습니다. association(연관) list를 다룰때 여기 나온것을 쌍을 위해 사용하는 것을 보게 될 것입니다


Circular Lists

 list '(1 2 3)으로 구성된 cons sell을 설명하기 위해, 3장에서 사용했던 그림이 여기 있습니다:
[pic]

 이제 저희가 이 list의 괴상한 돌연변이를 만든다고 가정해 봅시다. 세번째 cons cell의 cdr이 nil대신에 첫번째 cons cell을 가리키도록 해봅시다:
[pic]

 list에 있는 모든 cons cell 이론적으로 메모리상에서 분리된 객체(object)처럼 존재합니다. cell에서의 car와 cdr 의 위치로 메모리에 있는 다른 객체를 지정할 수 있기 때문에, cons cell은 list의 cons cell의 시작부분을 가리킬 수 있습니다. 이것을 circular list(순환 리스트)라 부릅니다.

 그러나 어떤 Common Lisp 환경에서 circular list에 관한 실험을 하기 전에, 여러분은 이 명령어를 실행해야만 합니다:
[source]

 *print-circle*를 true로 설정하는 것은, 여러분이 자기-참조형 data 구조에 관한 속임수(shenanigans)를 계획하고 있고, 여러분이 만든 어떤 기괴한 것을 화면에 출력할때 추가적인 주의가 필요하다는 것을, Lisp에게 경고하는 것입니다. 만일 여러분이 이 변수를 설정하지 않고 circular list를 출력한다면, 어떤일이 일어나는지 말해주지 않지만, (여러분이 stack overflow와 무한 loop 출력에서 아름다움을 찾을수 없다면)출력결과는 예쁘지 않을것입니다.

 *print-circle*을 true로 설정하면, Common Lisp는 data 구조를 출력하기 위한 더욱 복잡해진 출력 방식을 이용할 것입니다. (기본적으로 성능을 향상시키기 위해 막아놓은) 이 방식은 여러분이 이전에 봤던 cons cell을 실행시키는지 확인하고, 무한 loop에 빠지지 않도록 출력합니다.

 circular list를 만드는 것은 어떻게 할까요? 가장 간단한 방법은 다음과 같이 setf 명령어를 사용하여 첫번째 인자로 추가할 것을 넣는 것입니다
[source]

 이 예제에서, 저희는 nil을 자신을 참조하는 간단한 리스트로 교체함으로써 무한 list '(1 2 3 1 2 3 1 2 3 ...)을 만들었습니다

 이번 예제와 같이, 복잡한 표현식을 setf의 첫번째 인자에 위치시키는 능력은 매우 멋지며, 9장에서 더 자세히 살펴볼 것입니다.

NOTE
 CLISP(그리고 다른 Common Lisps)는 circular list의 출력을 매우 사려깊게 다룰 수 있습니다. 어찌됐든, list의 한 부분이 다른 부분을 참조한다는 사실을 다루었습니다. 여러분이 보았듯이, 은밀(esteric)하지만, 매우 영리하게, 자기-참조를 표현식(expression)의 일부로 연결하는 표기법(notation)을 사용합니다. 그러나 저는, 어떤 자기-참조 data의 복잡성의 증가와 같은, 이러한 data형식을 위해 Lisp printer가 제공한 출력된 결과가, 프로그래머를 공감시키는데 있어 더욱 어렵게 할 수 있다는 것을 확신합니다
   

Association Lists

 cons cell들로 만들 수 있는 특출하게 유용한 data구조 중 하나는 연관 리스트(association list), 짧게 alist입니다. alist는 list에 저장된  키/값(key/value)으로 이루어 집니다.

 관례에 따라서, 만일 key가 list에 반복하여 보인다면, 첫번째 보이는 key가 desired value를 포함한다고 가정합니다. 예를들어, 여기 Bill, Lisa, John의 커피 주문을 나타내는 alist가 있습니다
[source]

 주어진 사람의 주문을 살펴보기 위해, assoc 함수를 사용합니다:
[source]

 이 함수는 list에서 desired key로 시작하는 것을 찾고, key/value쌍을 반환합니다. 이제, 음료 주문을 가져다 주기 전에, Lisa가 여러분을 멈추게하고 그녀의 주문이 조금 더 맛있는 것으로 바꾼다고 가정해봅시다. 여러분은 push함수로 그녀의 주문을 바꿀 수 있습니다.
[source]

 이 함수는 간단하게 새로운 항목을 이미 존재하는 list의 앞부분에 추가합니다.

 기본적으로, assocation list에서 첫번째로 key를 참고하는것 보다 더 나중에 같은 key를 참조한 것을 우선시 하기 때문에, Lisa의 주문 small drip coffee는 더 최근 주문으로 대체됩니다:
[source]

 여러분이 보시는 것처럼, alist는 어떤 변화가 가능한 key/value 쌍 모음의 자취를 추적하기 좋은 방법입니다. alist를 "이해하기, Lisp 함수와 함께 조작하기, 출력된 것을 이해하기"가 쉽습니다. (어찌됫건, 그것들은 단지 pair들의 list입니다)

 더욱이, alist에 값이 저장되면, 어떤 data의 변화를 감시하기 쉽게, 그것을 영원히 유지합니다. 커피 예에서, Lisa의 주문 drip coffee는 교체되었더라도 여전히 남아 있습니다.

 그러나, alist는 하나의 중대한 한계점을 가지고 있습니다: (12개의 항목 보다 적은(under a dozen items))매우 짧은 list를 다룰게 아니라면, data를 받거나 저장하기 위한 효율적인 방법이 아닙니다. 비록 alist가 Lisp 프로그래머의 toolbox의 첫번째 tool중 하나이지만, 이것이 비 효율적이기 때문에, program matures처럼 다른 형식의 data 구조로 교체되어야만 합니다. (9장에서, 저희는 alist와 같은 list-기반 data구조의 성능 한계에 대해 더욱 자세히 다룰 것입니다)


Coping with Complicated Data

 cons cell은 list-와유사한 구조를 표현하기 위한 좋은 도구 입니다. 사실, 대다수의 Lisp프로그래머들은 성능 제약이 없는 프로그래밍 작업을 할때 그것들에게 전적으로 의지합니다. 이 조작물과 cons cell들로 만들어진 visualization of structures들은 Lisp 디자인의 중심이게 때문에, 이러한 구조는 사용하기와 디버그하기에 매우 편리합니다

 사실, 성능 제약이 있을지라도, cons cell의 구조는 좋은 선택이 될 수 있습니다. Lisp 컴파일러는 보통 cons cell을 단일 어셈블리 명령으로 바꾸어 줄일 수 있습니다.


Visualizing Tree-like Data

 3장에서 다루었듯이, Lisp프로그램에서 data(그리고 code)는 문법 표현식(syntax 
expressions)으로 표현됩니다. 이런 형식에서, data는 nested list를 사용하여 나타내어지고, 보통 각 list앞에 있는 Lisp symbol들은 data 구조를 설명합니다.

 예를 들어, 여러분이 Lisp에서 집을 구성하는 요소들을 표현하기 원한다고 가정해봅시다 :
[source]

 이 data구조는 매우 우아하게 집을 구성하는 hierarchical한 자연스런 부분 유지합니다.

 Lisp symtax expression(문법 표현식)과 비슷한 구조로 인해, 여러분은 hierarchy 수준으로 구성된 list를 볼 수 있습니다. 또한, 이것은 각 list앞에 symbol을 넣음으로써 symtax expression의 관습을 따릅니다. 예를들어, 창문을 설명하는 list가 windows symbol을 포함하고, 유리, 창틀, 커튼 3가지 항목이 따라오는 것을 볼 수 있습니다.

 보시다시피, 이러한 방법으로 계층적이며(hierarchical) 자연의 tree-like data는 매우 자연스럽게 표현되어집니다. 사실, 많은 Lisper들은 XML(계층적 data를 표현하는 유명한 형식)을 초기 Lisp 문법 표현식 형식의 재발명으로 여깁니다.

 상대적으로 cons cell에 data를 저장하기 쉬울지라도, 여러분이 tree-like 구조들 너머 문법 표현식안에 저장된 data를 시각화 하는 것은 어려울 수가 있습니다. 예를들어, 문법 표현식에 저장된 수학적 그래프를 가졌다고 가정해봅니다. 이 그래프 종류들, 간선들로 이어진 그래프의 임의의 노드들을 컴퓨터 프로그램에서 보이도록 하는 것은 어렵다고 악명이 났습니다. Lisp의 우아한 cons cell을 표현하는 system이라도 이와 같은 data를 충분히 도울수는 없습니다. 다음으로, 저희는 이 그래프를 보여주기 위한 option을 살펴볼 것입니다.


Visualizing Graphs

 수학에서, 그래프graph는 간선edges으로 연결된 노드nodes들의 가지로 구성되었습니다. 이 노드들 혹은 간선들은 이것들과 관련된 추가 data를 가져야만 합니다.

 그래프를 cons cell에 저장할 수 있더라도, 보여지게 하는 것은 어렵습니다. 5장에서 두 alist에 마법사의 집(directed graph으로 구성된)지도를 저장했을때 이것을 보았습니다: 하나는 노드의 정보를 포함하고 있고 다른 하나는 간선의 정보를 포함하는 것. 이번장을 위해, 여기 나타난 것과 같이 그것들의 이름을 *wizard-nodes*와 *wizard-edges*로 다시 지었습니다:
[source]

 보시다시피,  이 raw data table로부터 게임세계의 구조를 이해하기에는 어려움이있습니다. 불행히도, 그래프나 간단한 tree 구조를 넘어선 다른 성질을 포함하는 형태를 지니는
data는 매우 흔합니다. 만일 저희가, 이 data로 예쁜 그래프의 그림을 생성하는 것을 최적하게 처리할 수 있는, 툴을 가졌다면 좋지 않았을까요? 다행히도, 이 작업을 완벽히 수행할, 다음에 시도해볼 환상적인 open source tool이 있습니다.


Creating a Graph

 Graphviz는 여러분의 data로부터 그래프를 생성합니다. 실제로, 여러분은 5장에서 간단하게 Graphviz로 마법사의 집을 표현한 것을 보았습니다.
[pic]

 Graphviz는 open source이며 Graphviz website(http://www.graphviz.org/)에서 얻을 수 있습니다. 이것을 다운로드 받고 설치하고 나면, 그래프를 만드는 것은 쉽습니다. 첫번째로, 여러분은 그래프의 모양을 설명하는 DOT파일을 만들 것입니다. 예를들어, Graphviz에서, 여러분에 컴퓨터에 test.dot이란 파일을 만들고 다음에 나오는 정보를 입력합니다:
[source]

 이것은 화살표로 노드 A와 B가 연결된 directed graph를 정의합니다. (DOT 파일 형식에는, Graphviz website에 있는 문서화된것 만큼의, 수많은 문법 option들이 있습니다.)

 이제, DOT 파일에서 그래프 bitmap을 생성하기 위해 command line에서 다음과 같이 (Graphviz utilities중 하나인)neato를 실행합니다:
[cmd]

 이것은 test.dot.png파일안에 이와 같은 그림을 생성해 줍니다:
[pic]

 보시다시피, Graphviz는 사용하기 간단합니다. 사소한 그래프 문제가 있지만, 이것은 심지어 크고 복잡한 그래프를 빠르게 생성할 수 있습니다. (컴퓨터 과학에서 완벽한 그래프 형태는 여전히 풀리지 않은 문제이기 때문에, Graphviz 형태는 완벽하지 않습니다. 그러나, 그것은 여러분이 기대햇던 것보다도 완벽에 가깝습니다.)

 이제 여러분이 가진 Graphviz를 사용하여, Lisp에서 편리하게 그래프를 그려줄 command 라이브러리를 만들어 봅시다. 우리는 adventure 게임 세계의 어떤 그래프를 그리기 위해 이것을 사용할 수 있습니다.


NOTE
 이번 장의 예제에 사용된 그래프 utilities는 Common Lisp의 표준의 일부가 아닌 방법으로 특정 system call을 수행합니다. 이것은 CLISP환경에서만 동작합니다. 다른 Lisp환경에서 돌아가도록 약간의 code 수정이 필요합니다


Generating the DOT Information

 graph drawing library를 만들기 위해, 저희는 그래프의 세부사항을 담은 Graphviz DOT파일을 생성하기 원합니다. 이것을 하기 위해,  게이머가 돌아다닐 수 있는 노드 구분자의 변환과, 이 노드들을 연결하는 간선들의 변환, 그리고 모든 노드와 간선 label을 생성할 필요가 있습니다. 마법사의 세계의 지도를 나타내는 노드를 이용하여 저희 라이브러리를 테스트 할 것입니다.


Converting Node Identifiers

 노드들을 DOT 형식으로 변환할때,우리가 필요한 첫번째 것은 노드 식별자들 유효환 DOT 식별자로 변환하는 것입니다. 우리는 dot-name함수를 작성함으로써 이러한 일을 합니다:
[source]

 DOT형식에 있는 노드는 오직 문자(letters), 숫자, 밑줄문자(under-score character)만 포함 할 수 있습니다. 우리가 사용할 노드 식별자를 합법적(legal)으로 만들기 위해,  금지된 문자들을 밑줄로 바꿀 것입니다. 여기 dot-name 함수가 사용된 예제가 있습니다:
[source]

 prin1-to-string함수를 사용하여 변화시킬 수 있는 이 함수는, 어떠한 기본 Lisp 형태도 받아 들입니다. 문자열의 산출하는 작업과 필요하다면 밑줄로 치환하는 작업을 할 수 있습니다.

NOTE

 간단히 하기 위해, dot-name함수는 알파벳이 아닌 구성물의 노드 식별자의 차이를 구분할 수 없다고 가정합니다. 예를 들어, 여러분이 foo?라고 불리는 하나의 노드를 가지고 있고 다른 노드를 foo*라고 부른다면 dot-name함수는 그것들 모두, 이름이 충돌하는, foo_로 바꿀것입니다.


 substitute-if 함수는 테스트 함수의 결과에 기반하여 값을 변화시킵니다:
[source]


 이번 예제에서 테스트 함수, digit-char-p는, 문자열에 있는 문자인지 숫자인지를 말해줍니다. 이와 같은, 값을 받아들이고 값에 기반하여 참을 결정하는, 테스트 함수는 종종 predicates로 언급되어집니다.

 또다른 substitute-if 함수의 흥미로운 속성으로는 list에서도 사용할 수 있다는 것입니다:
[source]

 여기, list에 있는 모든 홀수는 0으로 변경되었습니다. substitute-if 함수는 generic 함수 -인자로 다양한 datatype들을 수용할 수 있고 그것들을 적절하게 다루는 함수- 의 한 예입니다. (Generic programming은 9장에서 다뤄집니다.)

 dot-name함수 안에서 substitute-if를 사용할때에는 알파뱃이 아닌 문자만 치환합니다. 반면 이 테스트와 반대의 predicate가 Common Lisp에서 가능하며, 이 predicate를 만드는 것은 쉽습니다. dot-name함수 안에서 다음 조각은, 올바른 행동을 하기 위한 predicate 함수를 만듭니다:
[source]

 Lisp는 이미 이것이 알파벳인지 말해주는 alphanumericp라 불리는 predicate 함수를 가졌습니다. 그러나, 저희는 오직 알파벳이 아닌 문자만 치환하기 원합니다. 저희는 이것을  고-수준 함수 complement를 통과시킴으로써 alphanumbericp과 반대의 함수를 만들 수 있습니다.

 substitute-if에서 이 함수를 통과하면, substitute-if를 체워주기 위한 새로운 함수로 top level을 오염시키는 defun을 사용할 필요없이, 우리가 원하는 것을 얻습니다.

NOTE

 Common Lisp는, substitute-if대신에 dot-name함수에서 사용할 수 있는, substitute-if-not이라 불리는 함수를 가지고 있습니다.(Common Lisp has a function called substitute-if-not that could have been used in the dot-name function in lieu of substitute-if to allow us to leave the not out of the lambda function.) 그러나 끝에 not이 있는 Lisp함수는 피하는게 좋습니다. 그것들은 아마도 ANSI Common Lisp 표준 차기 버전에서 사라질 것이며, 이것이 의미하는 것은 그것들이 deprecated로 간주된다는 것입니다.


Adding Labels to Graph Nodes

 이제 우리는 DOT에 알맞게 만드는 노드 식별자를 tweak할 수 있고, 이것이 그려질때 노드에서 보여질 label을 생성하는 다른 함수들을 작성합시다. label은 노드 이름과 노드 alist에 있는 노드와 연결된 data로 구성됬습니다. 저희는 또한 label안에 매우 많은 text를 타이핑 하지 않는다는 것을 확실히 해야할 필요가 있습니다. 여기 label을 생성하는 code가 있습니다:
[source]

 *max-label-length* 는 label에 들 어갈 최대 문자수를 결정할 전역 변수 입니다. 만약 노드 label이 최대치보다 길다면 일부가 짤려나가고, 그 사실을 나타내는 생략부호(ellipsis)가 추가될 것입니다. write-to-string 함수는 우리가 전에 썼던 prin1-to-string함수와 유사합니다 --이것은 표현식을 문자열로 씁니다.

 :pretty 인자는, 특정 Lisp함수에서 사용되어지는 여러분이 통과하기 원하는 인자를 고르는, keyword 인자의 예제입니다, 이번 경우 write-to-string는, Lisp에게 이것을 예쁘게 만들면서 문자열을 변경시키지 말라고 말하는 것입니다. 이것이 없으면, Lisp는 눈에 더 잘보이게 하기 위해 만든 개행이나 탭을 변형된 문자열에 넣을 것입니다. :pretty keyword인자를 nil로 설정함으로써, Lisp에게 어떠한 꾸밈도 없이 표현식을 출력하라고 말합니다. (새로운 줄을 갖는 label은 Graphviz를 혼란에 빠트릴수 있으므로, 저희는 Lisp에게 어떤 ideas를 주길 원하지 않습니다.)


Generating the DOT Information for the Nodes

 이제 우리는 각 노트의 이름과 label을 동시에 생성할 수 있고, 다음과 같이, node들의 alist를 받아 그것으로 부호화된 DOT 정보를 생성하는 함수를 작성할 수 있습니다:
[source]

 이 함수는 list of node에 있는 모든 node들을 거쳐가기 위해 mapc를 사용하고, princ는 DOT 형식에 있는 각 노드를 화면에 직접 출력합니다. mapc는 미묘하게 더 효율적인 mapcar의 변종입니다; 차이점은 이것은 변형된 list를 반환하지 않는다는 점입니다. nodes->dot함수는 data를 변경하기 위해 생성한 dot-name과 dot-label함수를 사용합니다.

 후에, 이 정보를 담기 위해 파일을 생성하기 원할때, 우리는 console로부터 이 data를 가져오는 함수를 작성해야 합니다

 직접 파일에 작성하는 대신에, 파일을 생성하는 중계자로 console을 사용하는 것이 조금 이상하게 보여지지만, 이것은 실제로 Lisp에서 일반적인 paradiam입니다. 이러한 접근의 이점으로 출력된 줄들을 보기 쉬운 REPL에서 쉽게 code를 디버그 할 수 있습니다.

 이제 nodes-dot함수를 이용하여 마법사의 집에 있는 노드에 대한 DOT 정보를 생성해 봅시다:
[source]

 여기서, 여러분은, DOT 형식에서 보여지는, 마법사의 집의 노드와 각 노드의 생략된 정보들을 볼 수 있습니다. nodes->dot함수로부터 반환된 값에는 관심이 없다는 것을 알립니다 - 필요한 정보는 REPL에서 출력된 정보입니다. Lisper들은 우리들이 이 함수의 부수효과(side effects)에만 관심 있다고 예기합니다. 비록 mapc가 list를 반환하지 않지만, 이것은 여전히 code가 list를 거쳐 순환시키도록 하고 mapcar를 사용하여 출력된 결과와 같은것을 생성하므로, 이것은 조금 더 빠르고, side effect는 mapcar와 같습니다.


Converting Edges into DOT Format

 다음 단계는 노드를 이어주는 간선을 위한 DOT정보를 생성하는 것입니다. 이것은  visual 그래프에서 화살표가 될 것입니다. edges->dot함수는 console로 직접적으로 출력함으로써 필요한 data를 또다시 생성합니다.
[source]

 이 함수를 마법사의 집의 edges에 대한 DOT 정보를 생성하기 위해 사용해 봅시다:
[source]

 여기서, 우리는 DOT 형식에 있는 마법사의 집에 있는 노드들 사이의 관계를 명백히 알 수 있습니다. 예를 들어, 첫번째 줄은 (WEST DOOR)라 이름표가 붙은 간선을 이용하여 게이머가 LIVING_ROOM노드에서 GARDEN노드로 걷고 있다는 것을 나타냅니다


Generating All the DOT Data

 DOT data 생성하는것을 완료하기 위해, nodes->dot과 edges->dot을 함께 호출하고, 다음과 같이 추가 장식으로 이것을 꾸며보도록 합니다:
[source]

 이 함수는 directional graph로 그래프를 정의함으로써 모든것을 한데 모아 묶고, nodes->dot과 edges-.dot함수를 호출합니다.

 여기 새로운 라이브러리로 만들어진것 처럼 보이는 마법사 게임의 최종 DOT정보가 있습니다:
[source]

우리는 이제, 예쁜 그림을 생성할때 필요한 마법사 지도의 모든 세부사항 가진, 더 낳은 Graphviz DOT파일을 생성할 수 있습니다. 이것은 게이머가 방문할 수 있는 노드와, 이 노드와 연결되는 간선들, 그리고 모든 노드와 간선들의 label을 포함하고 있습니다.


Turning the DOT File into a Picture

 DOT파일을 실제 bitmap으로 바꾸기 위해, DOT 파일 data를 잡아서 파일에 넣고, 이와 같이 system command line에서 dot 명령어를 직접 실행합니다
[source]


 이 함수는, 몇몇 진보된 Lisp기술을 사용하여, graph drawing library에 있어 중요한 행동을 수행합니다

 첫번째로, dot->png함수는 가능한 재활용하기 위해, graph->dot함수를 직접적으로 호출하지 않습니다. 대신에, dot->png를 thunk를 받아들이도록 짭니다.


Using Thunks

 Lisp에서 인자가 없는 작은 함수를 만드는 것은 일반적입니다. 이러한 함수를 공식적으로 nullary functions라고 부릅니다. ??? 그러나, Lisper들은 후에 동작하기 원하지 않는 계산을 기술하기 위해 종종 이와 같은 함수를 만들 것입니다. However, Lispers will often create such functions in order to describe a computation that they don’t want to run until later. ??? 이번 시나리오에서, 인자가 없는 함수는 일반적으로 thunk 혹은 suspension이라 불립니다. 이번 경우에, 저희 thunk dot-png함수는 이 함수가 호출되때 DOT파일을 console에 출력하는 함수가 필요합니다.

 왜 dot->png함수에서 thunk는 유용할까요? 저희에게 있어 graph->dot과 다른 DOT 파일 함수들을 작성하고 디버그하기 쉬운방법은 결과를 직접 console로 출력을 하는 것입니다. graph->dot를 호출할때, 값으로써 결과를 반환하지 않고, 대신에 side effect로 console로 출력합니다. 그러므로, 우리는 graph-dot의 값을 dot->png로 넘겨줄 수 없습니다. 대신, graph->dot을 thunk로써 넘깁니다. 그러면 dot->png는 graph->dot을 호출할 의무가 있고, 결과를 잡아, 그것을 파일로 보냅니다.

 컴퓨터 프로그램에 있어 textual data를 생산하는것은 일반적이기 때문에, 이 특별한 기법은 많은 Lisp code에서 쓰여집니다: 첫번째로, 무언가를 올바르게 출력합니다; 그리고, 이것을 thunk로 워프시킵니다; 마지막으로, 결과를 다른 장소로 보냅니다.

 14장에서 보게될것이지만, 함수형 프로그래밍 형식을 따르는 Lisper들은 이 기법을 삼가해야하는데, 왜냐하면 console로 출력할때 side effect가 필요하기 때문입니다.


Writing to a File

 with-open-file는 파일에 정보를 쓰기위해 dot->png를 활성화시킵니다. 여기, 이 함수가 어떻게 동작하는지 경험하기 위해, 새로운 testfile.txt란 이름의 파일을 말들고 "Hello File!"을 이것에 쓰는 예제가 있습니다
[source]

 이번 예제에서, with-open-file에 의해 만들어진, stream이라 불리는 특별한 Common Lisp datatype 첫번째 항목이 with-open-file을 통과하는 것을 여러분은 볼 수 있습니다 


Creating a Stream

 princ와 같은 출력하는 함수는 stream을 optional 인자로 받아들일 수 있습니다. 이번 경우에, 출력하는 이 함수는 어떤 것도 console로 출력하지 않는 대신에, stream object에 출력을 할것입니다.

 변수 이름에서 변수를 만드는 것과 동일한 방법으로, stream 변수 이름에서 stream변수를 만드는 with-open-file을 이해하는 것은 중요합니다:
[source]

 만약 여러분이 첫번째 list앞에 있는my-stream 이름을 my-stream 이름을 with-open-file에 통과시킨다하면, 이것은 let으로 시작하여 my-variable를 정의하는 것과 유사합니다. my-stream 변수 이름은 with-open-file 내부에서 사용가능하고 이와 같은 방식으로 my-variable은 let 내부 안에서 사용가능합니다.

 그러나 stream이 정확히 무엇인지에 대해 걱정할 필요가 없습니다. 저희는 12장에서 더욱 자세히 살펴볼 것입니다. 이제, 우리는 stream이 object이며 file로 연결될 수 있다는 것을 알았고, 연결된 파일에 어떤것을 작성하기 위해 이것을 (princ와 같은)함수로 보낼 수 있습니다


Understanding Keyword Parameters
 with-open-file명령어는 또한 어려운 keyword 인자를 사용합니다. 이전 예제에서 이 명령어를 다시 살펴봅시다:
[source]

 keyword 인자는 두부분으로 나뉩니다: 인자의 이름과 인자의 값. 인자의 이름은 항상 colone으로 시작하는 symbol입니다. 이 예제에서는 두 keyword 인자가 있습니다: :output을 설정하는 :direction, (단지 파일을 작성하고 읽지 않습니다) 그리고 :superseded를 설정하는 :if-exists (파일 이름이 이미 존재하면, 이전 버전에게 넘겨줍니다)

 with-open-file은 파일을 여는것이 복잡한 연산이고, 많은 esteric option들이 가능하기 때문에, keyword를 인자로 가지고 있습니다. with-open-file에게 모든 것을 설정하는 보통 인자들을 준다면, with-open-file를 호출하는 것은 길어지고, 다루기 어려워 질 것입니다. 또한, 인간은 긴 인자 list에서 찾고 어느곳에 있는지 기억하는데 어려움이 있습니다


 이미 눈치챗듯이, Common Lisp에서의 symbol 종종 colon으로 시작합니다. 이것은 항상 conlone으로 시작하는 keyword인자를 포함합니다. Lisp에서 보통 symbol은 다른 것으로 참조될 수 있기 때문입니다. 예를들어, cigar변수를 5로 설정하고 반환 하였습니다:
[source]

 그러나, 때때로 저희는 symbol을 다른 것으로 참조하기 원하지 않습니다. 노골적으로 symbol을 사용하길 원하고, 그것이 그 자체 의미하는 것을 가지길 원합니다. Common Lisp에서 앞에-colon이 붙은 symbol(keyword symbol이라 불리는 것은 놀랍지 않습니다)은 항상 그 자체를 의미합니다:
[source]


 보시다시피, keyword symbol :cigar은 REPL에서 평가될 수 있고, 이미 값을 가지고 있습니다. 알맞게도, 이 값은 :cigar입니다. :cigar을 다른 것으로 재정의를 시도하면, Common Lisp는 허락하지 않습니다. 이것이 상수라는 사실은 유용한데 Lisp 컴파일러는 잠재적으로, 다른 형식보다 최적화가 가능한, 이 단순한 symbol 형식을 최적화할 수 있기 때문입니다. 또한, symbol이 그 자체를 의미하는 code에서 keyword symbol을 사용함으로써 에러를 줄일 수 있습니다. 때때로 cigar은 단지 cigar일 뿐입니다.


Capturing the Console Output

 저희 dot-pgn는 이번 예제에서 보여진것과 미세하게 다른 방법으로 data를 파일로 보냅니다: *standard-output*으로 선언된 stream으로(Common Lisp에서 출력함수들이 출력하는 기본 위치를 조정할 수 있는 특별한 전역 변수입니다.). 결과적으로, thunk내부에서 어떤 출력은 DOT 파일로 방향을 돌릴 것입니다.

 dot->png함수를 다시 살펴 봅시다:
[source]

 어떻게 dot->png 함수가 DOT data를 console로 보내는 대신에 파일로 저장할까요? 이것에 답하기 위해, 여러분은 여러분의 두뇌를 약간 활용할 필요가 있습니다. 또한, 2장에서 지역과 동적변수를 다뤘던 것을 회상할 필요가 있습니다.

 let명령어가 lexical, 혹은 local, variable을 만든다는 것을 기억하시길 바랍니다. 저희가 (예전에)다뤘듯이, with-open-file로부터 만들어진 stream변수는, 변수를 만들기 위해 let을 사용하는 것과 유사합니다. 그런 이유로, 이것은 lexical stream 변수의 생성으로 여겨집니다.

 그러나, 만약  같은 이름의 동적 변수가 이미 존재한다면, let대신에, 임시로, 동적 변수의 값을 새로운 값으로 덮어버릴 것입니다. *starndard-output*은 동적 변수와 같습니다. 이것이 의미하는 것은 with-open-file명령어 안에서 임시로 *standard-output*의 값을 새로운 값으로 뒤덮을 수 있다는 것입니다.

 trunk를 호출하는 with-open-file내부에서 console로 출력되는 어떤 값들은 이제 자동적으로 저희 파일을 경유할 것입니다. (Common Lisp에서의 lexical과 dynamic 변수의 설계에 의해 가능하게된) 놀랄만한 것은 비록 dot->png에서 간접적으로 호출될 지라도 graph->dot함수에서의 출력 상태 또한 참이라는 것입니다.


Creating a Picture of Our Graph

 끝으로, 몇몇 노드와 간선으로부터 쉽게 graph를 만들도록 모든 조각들을 묶어줄 함수가 필요합니다:
[source]

 이 함수는 DOT파일 이름(변수 fname)와 노드와 간선을 받고, graph를 생성하는데 사용합니다. 이것을 하기 위해, dot->png함수를 호출하고 적절한 thunk-lambda 함수-를 생성합니다. thunk는 일반적으로 인자를 취하지 않습니다.

 graph->dot함수는 delayed compuation처럼 thunk내부에서 호출됩니다. 특이하게도, 여러분이 graph->dot을 직접 호출하였다면, 이것의 출력은 console에서 보여질 것입니다. 그러나 thunk내부에 있을때, 이것은 dot->png함수의 leisure에서 호출될 것이고, 출력은 graph->png의 첫번째 인자로 들어온 파일 이름으로 DOT파일을 생성하는데 사용될 것입니다.

 새로운 함수로 마법사의 집의 graph를 그려봅시다!
[source]

 이 함수를 호출한 뒤에, 여러분은 wizard.dot.png파일과 마법사의 집의 지도 그림을 볼 수 있습니다:
[pic]

 지구상에서 가장 예쁜 graph는 아닐지라도, 이것은 정보를 담고 있고 이해하기 쉽습니다. 또한, code는 매우 유연하고, 노드와 간선 data에 있어 적은 의존성을 지닙니다.

 저희 무기고(arsenal)에서 있는 이 utilities로, 우리는 Lisp프로그램에서 상호 연관된 data로부터 쉽게 graphs를 만들 수 있습니다. 여러분은 복잡한 data를 다룰 필요가 있을때, 귀중한 디버깅 tool이 되는, 이 기법을 찾을 것입니다.


Creating Undirected Graphs

 간선에 화살표를 가진 그래프를 directed graph라 부릅니다:
[pic]

 그러나, 때때로 저희는, 하나의 간선으로 두 방향을 경유할 수 있는, 방향이 없는 data를 가져야 합니다. 이와 같은 graph는 directed graph보다 복잡하지 않고, 이해하기 쉽습니다:
[pic]

다음 code는 저희 graph utilities를 undirected graph를 그리게 하는 새로운 함수로 확장시킵니다:
[source]

 이 코드는 directed graphs를 만들기 위한 코드와 매우 유사합니다. 차이점을 살펴봅시다.

 udeges->dot 함수는 edges->dot 함수와 매우 유사합니다. 그러나 우리가 그리는 graph는, 하나의 undirected edge로 바꾸길 원하는, 같은 노드 사이에서 다중 directed edges를 가졌습니다. 예를들어, 마법사 지도에서 저희는 동쪽으로 가서 문을 통해 정원에서 거실로 갈수 있습니다. 물론, 저희는 서쪽으로 같은 문을 통해 거실에서 정원으로 갈 수 있습니다. undirected graph에서는 우리는 이것이 붕괴하길 원합니다; 본질적으로, 우리는 단지 "정원과 거실 사이에는 하나의 문이 있습니다" 라고 말하길 원합니다.

 uedges->dot함수는 maplist함수를 사용하여 간선 list를 통해 중복된 간선들을 지웁니다. 이것은, 함수 안에서 list의  현제 항목만이 아닌 list의 전체를 받는 것을 제외하면, mapcar함수와 같습니다:
[source]


 maplist 함수는 현제 항목부터 마지막까지 list에 있는 모든 것을 print함수로 보냅니다. 그리고 uedges->dot은, edge list에서 나중에 보이는 node의 목적지가 어디인지 확인하는 maplist로부터 얻은, future nodes의 정보를 이용합니다. (cdr lst)로 계산된 남아있는 edge list에서 현제 edge를 살펴봄으로써, assoc 함수에 관한 실제 확인이 끝납니다. 이번 경우에, 간선의 쌍이 하나만 출력될 것이기 때문에 edge를 건너 뜁니다.

 DOT data를 생성할때 diagraph대신에 단순한 graph를 기술한다는 점을 제외하고, ugraph->dot함수는 graph->dot함수와 유사합니다. ugraph->png함수는 graph->dot대신에 ugraph->dot를 호출한다는 점을 빼면 graph->png함수와 근본적으로 동일합니다.

 dot->png함수를 다른 thunk를 취하도록 설계하였음으로 저희는 다른 DOT data generator와 작업할 수 있습니다. 이제 이것의 유연성을 이용하여 undirected graphs 그림을 출력하는 함수를 생성합니다. 예를 들기 위해, 마법사의 집의 undirectd graph를 생성해 봅시다:
[source]

 여기, 우리가 만들기 원한 "uwizard.dot"파일이 있습니다. *wizard-nodes*와 *wizard-deges*변수는 마법사 세계의 지도의 노드와 간선들을 서술하는 data를 포함하고 있습니다. 이 code는, 이와 같이, uwizard.dot.png파일을 생성합니다:
[pic]

 이제 여러분은 directed와 undirected graph에 적합한 utilities를 가졌고, 이 함수를 graph-util.lisp로 작성하여, 여러분은 다른 프로그램으로부터 그것에 접근 할 수 있습니다.


What You’ve Learned

 이번장에서 list의 exotic 형식을 다루었고 수학적 graphs를 위한 drawing library를 만들었습니다. 이러한 과정을 거치면서, 여러분은 다음에 나오는 것을 배웠습니다.

z Lisp에서  nil이 아닌 값으로 끝나는list를 만들 수 있다. 마지막 항목전에 추가 dot이 보이는 list가 있고 dotted list라 부릅니다.

z Pairs는 list 그 자체가 아닌 두 항목을 써로 cons할때 얻는 것이다. 오직 두 항목만을 포함하는 dotted list를 통해서 얻을 수 있습니다.

z Circular list은 마지막 cons cell이 list의 처음 cons cell을 가리킨다.

z Association lists (alists)는 pairs의 list이다. 값과 연관된 key의 form으로 data를 저장할 때 사용 할 수 있습니다.

z Lisp 문법 표현식은 저장하고 list-like와 hierarchical data를 보여주기에 좋다. 추가 툴들은 더욱 복잡한 data를 보여줌에 있어 유용할 것입니다.

z 여러분의 data가 수학적 graph의 form안에 있다면, 여러분의 데이터를 그림으로 만들어 내는데에 있어 Graphviz를 사용하는 것은 유용하다. 

z Lisp 프로그램에 있어 textual data를 생성하는 일반적인 기법은, 쉬운 디버깅을 위해 text를 console에 출력하고 이 함수를 thunks로 wrap하는 함수를 작성하는 것이다. 여러분은 이 thunk를, console 출력을 잡고 text를 적절한 목적지로 file을 작성하는, 다른 함수로 보낼 수 있습니다.