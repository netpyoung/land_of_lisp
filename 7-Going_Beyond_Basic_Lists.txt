7장. 기본 List를 뛰어넘어

 이번 장에서, 저희는 기본 List 개념을 뛰어 넘을 것입니다.
 저희는 특별한 종류의 list들에 대해 이야기를 나눌 것이며, list 조작을 새로운 단계로 데려다줄 게임을 작성할 것입니다


Exotic Lists

 3장에서 배웠듯이, Lisp에서의 list는 cons cells-두 data 조각을 서로 연결 시킬 수 있는작은 data 구조-로 구성되었습니다. list의 마지막 cons cel의 오른쪽 칸은 nil을 담을 것입니다. 몇몇 cons cell들을 서로 이음으로써, 어떤 길이의 list라도 만들 수 있습니다. 예를 들어, 이것은 1, 2, 그리고 3의 list를 만듬으로써 cons cell들을 어떻게 사용하는지에 대한 것입니다:
[source]

[pic]


 list가 cons cell들의 사슬이라고 인간 생각하기엔 매우 복잡하기 때문에, Lisp는 특별히, 그런 list들을 출력하기 위한 간단한 문법을 취하였습니다. cons cell들의 사슬이 REPL에서 평가됨으로써 여러분은 볼 수 있습니다.
[source]

 Lisp는, REPL에서 사슬을 우리에게 되풀이하여 보여줄때, 간단한 list 문법을 사용합니다. 이것은 세가지 항목이 있는 list로 cons cell 문자열을 보여줍니다. 기억해야할 중요한 점은 보여짐에 있서 표면상 완전히 다르다는 것입니다. Lisp list가 어떻게 보여지든지 간에, 근복적으로, 이것은 항상 cons cell사슬을 유지합니다.


Dotted Lists

 그러면, 고전 "cons들의 문자열" 형식에서 벗어나면 어떤 일이 일어날까요? list를 출력할때 Lisp환경은 이런것을 어떻게 다룰 까요?

 이와 같은 1, 2, 그리고 3을 갖는 list를 만든다고 가정해 봅시다:
[source]


 여기에선, list의 세번째의 숫자위한 세번째 cons cell을 만드는 대신에, 이전 cell의 오른쪽 칸에 넣습니다. Lisp REPL에 이런 구조를 입력하면 어떤 것이 출력될 까요? 시도해 봅시다:
[source]


 nil-terminated list의 적절한 지점에서 list의 마지막 항목을 찾을 수 없는 것을 나타내기 위해, Lisp는 마지막 항목 앞에 점을 놓습니다. 이 점은 기본적으로 Lisp의 방법으로, "저는 여러분이 입력한 이 구조를 list 표현법을 사용하여 출력하려고 노력했으나, list의 마지막 항목 제가 예상한 nil을 포함하지 않았습니다; 대신에, 이것은 3을 포함하였습니다.",  라고 말하는 것입니다.


 nil이 아닌 다른 것으로 끝이나는 Lisp의 list는 점이 찍힌 리스트(dotted list)로 언급되어집니다. Dotted list는 Lisp대륙에서 이상한(oddity) 부류입니다. 그들 자체 만으로는, Lisp프로그래밍을 위한 유용한 도구가 아닙니다. 평범한 방식대로(regular practice) dotted list에 data를 저장하는것은 Lisp 프로그래머에게 매우 드문일 입니다. 그러나, Lisp에서 cons cell의 충만함(pervasiveness)를 주기 위해, 여러분은 cons cell사슬의 마지막에서 nil이-아닌 값을 자주 마주치게 될 것입니다. 이것이, 여러분이 직접적으로 사용하지 않더라도,  점이 찍힌 list와 친해져야 하는 이유입니다


 이 점 표기법을 다르게 생각하는 방법은 이것을 단순히 data mode에서 사용하는 cons 명령어를 위한 대안 문법이라 생각하는 것입니다. 사실, 여러분이 인생을 피곤하게 만들고 싶다면, 이와 같은 점 표기법을 사용한 적절한 list들로 만들 수 도 있습니다.
[source]

 Lisp는 list-printing mecanism의 일관성을 유지하여 최종 cons cell을 보여주기 때문에 dotted list에서의 점은 단순하게 보여집니다.


Pairs

Lisp 프로그램에서의 점이 찍힌 list를 평범하고 일상적으로 사용하는 것중 하나는 우아하게 쌍(pairs)을 표현하는 것입니다. 예를 들어, 2와 3의 쌍을 표현하고자 표현하기 원한다고 가정해봅시다. 이것을 행할 하나의 방법은 이 두 수를 서로 cons하는 것입니다:
[source]

 본질적으로, 여러분이 여기서 할것은 점이 찍힌 길이가 2인 list를 만드는 것입니다. 예상했듯이, Lisp는 쌍을 표시하기 위해 점 표기법을 사용합니다.

 Lisp에서 이러한 방법으로 쌍을 생성하는 것은 매우 편리하고 효율적입니다. 표준 car와 cdr명령을 사용하여 쌍에서 멤버(member)를 추출할 수 있기 때문에, 이것은 편리합니다. Lisp환경은 두 항목을 연결하기 위해 오직 단일 cons cell만 할당할 필요가 있기 때문에, 이것은 비교적 효율적입니다

 이러한 쌍의 형식은 Lisp 프로그램에서 일상적으로 사용되어 집니다. 예를 들어, 여러분이 복잡한 data 구조에 점의 x-와 y-coordinates(좌표계)나 key/value(키/값) 쌍을 저장할때 사용할 수 있습니다. association(연관) list를 다룰때 여기 나온것을 쌍을 위해 사용하는 것을 보게 될 것입니다


Circular Lists

여기 list '(1 2 3)으로 구성된 cons sell을 설명하기 위해 3장에서 사용했던 그림이 있습니다:
[pic]

 이제 저희가 이 list의 괴상한 돌연변이를 만든다고 가정해 봅시다. 세번째 cons cell의 cdr이 nil대신에 첫번째 cons cell을 가리키도록 해봅시다:
[pic]

 list에 있는 모든 cons cell 이론적으로 메모리상에서 분리된 객체(object)처럼 존재합니다. cell에서의 car와 cdr 의 위치로 메모리에 있는 다른 객체를 지정할 수 있기 때문에, cons cell은 list의 cons cell의 시작부분을 가리킬 수 있습니다. 이것을 circular list(순환 리스트)라 부릅니다.

 그러나 어떤 Common Lisp 환경에서 circular list에 관한 실험을 하기 전에, 여러분은 이 명령어를 실행해야만 합니다:
[source]

 *print-circle*를 true로 설정하는 것은, 여러분이 자기-참조형 data 구조에 관한 속임수(shenanigans)를 계획하고 있고 여러분이 만든 어떤 기괴한 것을 화면에 출력할때 추가적인 주의가 필요하다는 것을, Lisp에게 경고하는 것입니다. 만일 여러분이 이 변수를 설정하지 않고 circular list를 출력한다면, 어떤일이 일어나는지 말해주지 않지만, 출력결과는, 예쁘지 않을것입니다(여러분이 stack overflow와 무한 loop 출력에서 아름다움을 찾을수 없다면)

 *print-circle*을 true로 설정하면, Common Lisp는 data 구조를 출력하기 위한 더욱 복잡해진 출력 방식을 이용할 것입니다. (기본적으로 성능을 향상시키기 위해 막아놓은) 이 방식은 여러분이 이전에 봤던 cons cell을 실행시키는지 확인하고, 무한 loop에 빠지지 않도록 출력합니다.

 circular list를 만드는 것은 어떻게 할까요? 가장 간단한 방법은 다음과 같이 setf 명령어를 사용하여 첫번째 인자로 추가할 것을 넣는 것입니다
[source]

 이 예제에서, 저희는 nil을 자신을 참조하는 간단한 리스트로 교체함으로써 무한 list '(1 2 3 1 2 3 1 2 3 ...)을 만들었습니다

 이번 예제와 같이, 복잡한 표현식을 setf의 첫번째 인자에 위치시키는 능력은 매우 멋지며, 9장에서 더 자세히 살펴볼 것입니다.

NOTE
CLISP(그리고 다는 Common Lisps)는 circular list의 출력을 매우 사려깊게 다룰수 있습니다. 어찌됐든, list의 한 부분이 다른 부분을 참조한다는 사실을 다루었습니다. 여러분이 보았듯이,은밀(esteric)하지만, 매우 영리하게, 자기-참조를 표현식(expression)의 일부로 연결하는 표기법(notation)을 사용합니다. 그러나, 어떠한 증가하는 자기 참조형 data의 복잡함으로 이러한 data형식을 위해 Lisp printer에게 제공된 출력된 결과가 프로그래머를 공감하기 더욱 어렵게 할 수 있다는 것을, 여러분이 또한 인식할 수 있다는 것을 확신합니다


Association Lists

cons cell들로 만들수 있는 특출하게 유용한 data구조 중 하나는 연관 리스트(association list), 짧게 alist입니다. alist는 list에 저장된  키/값(key/value)으로 이루어 집니다.

 관례에 따라서, 만일 key가 list에 반복하여 보인다면, 첫번째 보이는 key가 desired value를 포함한다고 가정합니다. 예를들어, 여기 Bill, Lisa, John의 커피 주문을 나타내는 alist가 있습니다
[source]

주어진 사람의 주문을 살펴보기 위해, assoc 함수를 사용합니다:
[source]

이 함수는 list에서 desired key로 시작하는 것을 찾고, key/value쌍을 반환합니다. 이제, 음료 주문을 가져다 주기 전에, Lisa가 여러분을 멈추게하고 그녀의 주문이 조금 더 맛있는 것으로 바꾼다고 가정해봅시다. 여러분은 push함수로 그녀의 주문을 바꿀 수 있습니다.
[source]

#TODO 
이 함수는 단순히 새로운 항목을 이미 존재하는 list의 앞부분에 추가합니다.

기본적으로, association list에서 key를 참조하는 처음 것이, 같은 key를 더 나중에 참조한 것을 우선시함므로, Lisa의 주문 small drip coffee는 더 최근 주문에 의해 대체됩니다:
Because, by default, the first reference to a key in an association list takes 
precedence over later references to the same key, the order Lisa placed for a 
small drip coffee is superseded by her more recent order:
[source]

볼수 있듯이, alist는 어떤 변화가 가능한 key/value 쌍 모음의 자취를 유지하는 좋은 방법입니다.
As you can see, alists are a great way to keep track of any changeable 
collection of key/value pairs.

alist를 (이해하기가, Lisp 함수와 함께 조작하기가, 출력된 것을 이해하기가) 쉽습니다
(그것들은 단지 pair들의 list입니다)
 Alists are easy to understand, to manipulate with Lisp functions, and to comprehend when printed out (they’re just lists of pairs, after all).

더욱이,  alist에 값이 저장되면, 어떤 data의 변화를 감시하기 쉽게, 그것을 영원히 유지합니다.

 커피 예에서, Lisa의 주문 drip coffee는 교체되었더라도 여전히 남아 있습니다.

 그러나, alist는 하나의 중대한 한계점을 가지고 있습니다: (12개의 항목 보다 적은(under a dozen items))매우 짧은 list를 다룰게 아니라면, data를 받거나 저장하기 위한 효율적인 방법이 아닙니다. 비록 alist가 Lisp 프로그래머의 toolbox의 첫번째 tool중 하나이지만, 이것이 비 효율적이기 때문에, program matures처럼 다른 형식의 data 구조로 교체되어야만 합니다. (9장에서, 저희는 alist와 같은 list-기반 data구조의 성능 한계에 대해 더욱 자세히 다룰 것입니다)



#TODO
Coping with Complicated Data

cons cell은 list-와 유사한 구조를 표현하기 위한 좋은 도구 입니다.
Cons cells are a great tool for representing a wide variety of list-like structures. 

사실, 대다수의 Lisp프로그래머들은

In fact, most Lisp programmers, when faced with a programming task that is 
not bound by performance constraints, will rely on them almost exclusively. 

왜냐하면
조작물
visualization of structures
cons cell을 

Because the manipulation and visualization of structures made of cons cells 
are central to the design of Lisp, these structures are extremely convenient to 
use and debug.


사실, 여러분이 성능 제약을 가진다면, cons cell의 구조는 좋은 선택이 될 수 있습니다.

In fact, even if you do have performance constraints, structures made 
of cons cells can often be a great choice.

Lisp 컴파일러는 보통 cons cell을 단일 어셈블리 명령어로 바꾸어 줄일 수 있습니다.
 A Lisp compiler can often reduce a 
change to a cons cell down to a single assembly instruction!



Visualizing Tree-like Data

3장에서 다루었듯이, 
Lisp프로그램에서 data(그리고 code)는 문법 표현식으로 나타내어집니다

As discussed in Chapter 3, the data (and code) in a Lisp program is represented 
with syntax expressions.

이런 형식에서, data는
nested list를 사용하여 나타내어지고,
보통 각 list앞에 있는 Lisp symbol들은 data 구조를 설명합니다.
 In this format, data is represented using nested lists, 
often with Lisp symbols at the front of each list explaining the structure of 
the data.

예를 들어, 여러분이
Lisp에서 집을 구성하는 부분을 나타내길 원한다고 가정해봅시다 :
For example, suppose we wanted to represent the component parts of a 
house in Lisp:
[source]

이 data구조는 매우 우아하게 집을 구성하는 hierarchical한 자연스런 부분 유지합니다.
This data structure very elegantly captures the hierarchical nature of the 
parts that make up a house.

Lisp 문법 표현식과 같은 구조,
여러분은 list를 볼 수 있습니다
hierarchy의
 Since it is structured as a Lisp syntax expression, 
we can see the lists that make up the levels of the hierarchy.

 Also, it follows the convention of a syntax expression by putting a symbol at the front of each list.

 For instance, we can see how the list describing the windows first contains the Lisp symbol windows X, which is then followed by three items, representing the glass, frame, and finally the curtains Y.


 As you can see, data that is hierarchical and tree-like in nature can be 
very naturally expressed in this way. In fact, many Lispers consider XML (a 
popular format for representing hierarchical data) somewhat of a reinven-
tion of the syntax expression format that Lisp pioneered.
If, however, we move beyond tree-like structures, data stored in a syntax 
expression can start becoming hard to visualize, even if it’s relatively easy to 
store the data in cons cells. For instance, suppose we have a mathematical 
graph stored in a syntax expression. These types of graphs, where any arbi-
trary node of the graph may be connected to another by an edge, are notori-
ously hard to visualize in a computer program. Even Lisp’s elegant system for 

