PRINTING TEXT WITH THE FORMAT FUNCTION
11.format 함수로 텍스트 출력


 현시대의 프로그래밍에서도 text를 다루는 것은 매우 중요하며, Common Lisp는 환상적인 text-출력 함수들을 가졌습니다. XML, HTML, Linux 환경설정파일 혹은 textual 형식의 데이터를 다루게 된다면, Lisp는 여러분의 작업을 쉽게 만들어 드릴 것입니다.

 Common Lisp에서 가장 중요한 진보된 text 출력 함수는 이번장의 주제인 format 함수 입니다.


Anatomy of the format Function
 여기 format 함수가 쓰인 예제가 있습니다:
[REPL]

 이 함수의 각 부분이 무엇을 의미하는지 살펴봅시다.
[PIC]


The Destination Parameter
 format 함수의 첫번째 인자는 어디로 text를 보내는지 format에게 말하는 목적지 인자입니다. 여기 가능한 값들이 있습니다:
 
 nil : 아무 것도 출력하지 않음; 단순히 문자열string로 값을 반환합니다.
 t :console로 값을 출력함. 이번 경우에서(저희 예제에서), 함수는 nil을 값으로 반환합니다.
 stream : 데이터를 출력 스트림에 씀(12장에서 다룸)

 다음 예제에서 첫번째 인자를 nil로 설정하였으며, 이것은 단순히 문자열로 값을 반환하였습니다:
[REPL]

 문자열 값의 결과 ("Add onion rings for only 1.50 dollars more!") 는 reverse 함수를 통과해서, 역방향된 문자열이 princ 명령어로 화면에 출력되었습니다.

 이 예제에서, REPL은 princ 명령어에 의한 출력 정보와 같이 입력된 표현식의 값을 출력하였습니다. 이는 두번째 출력된 값이 보이는 이유입니다. 이번 장의 나머지에서는, 예제에서 REPL에 의해 출력된 이 값들이 생략될 것이며, 저희 코드에서 출력된 정보만 보여줄 것입니다.


The Control String Parameter
 format 함수의 두번째 인자는 text 형식을 조정하는 control string입니다. format 함수의 power는 control string에 달려있습니다. 최근 예제에서 control string은 "Add onion rings for only ~$ dollars more!"입니다.

 기본적으로, 이 문자열에 있는 text는 단순히 결과물로 출력됩니다. 그러나 이 장의 나머지에서 다루게될 control sequence들을, 출력 형식에 영향을 주기 위해 이 문자열에 넣을 수 있습니다. 예제는 소수점으로된 화폐값을 나타내는 control sequence ~$을 포함합니다. format 함수에 의해 인식된 모든 control sequence들은 물결 (~) 문자로 시작합니다.


Value Parameters
 control string 다음에 오는 format 인자들은 값이나 보여지거나 형식화format될 실제 데이터를 포함합니다. 보시다시피, control string은 이 인자와 상호작용하며 형식을 조정합니다.


Control Sequences for Printing Lisp Values
 print나 print1 명령어로 어떤 Lisp 값은 출력될 수 있습니다. 어떤 구획 문자(delimiter)없이 값을 출력한다면, princ 명령어를 사용할 수 있습니다:
[REPL]

 prin1이나 princ와 동일하게 행하도록 format에 ~s와 ~a control sequence들을 사용할 수 있습니다. format에서 사용될때 ~s control sequence는 적절한 구획문자들을 포함합니다. ~a는 구획문자 없이 사람이 읽을 수 있는 값을 보여줍니다:
[REPL]

 control sequence에 인자들을 넣음으로써, 이러한 control sequence들의 행동을 더 세밀하게 조정할 수 있습니다. 예를들어, 오른쪽에 공란이 들어올 값이라는 것을 알리려 a나 s 앞에 숫자 n을 놓을 수 있습니다. 그러면 format 명령어는 값의 전체 넓이가 n이 될때동안 공란을 체웁니다.

 예를들어, 다음 예제에서 ~10a를 써넣음으로써, 7개의 공란을 foo오른쪽에 추가하여 형식화된 값의 전체 넓이가 10문자가 되도록 만듭니다:
[REPL]

 다음처럼 @ 심볼을 추가함으로써 왼쪽에 공란을 추가할 수 도 있습니다:
[REPL]

 이번 경우, foo 값을 포함하여 추가된 공간의 전체 넓이는 10문자입니다.

 control sequence는 하나보다 더 많은 인자를 받을 수 있습니다. 이전 예제에서, 형식화된 문자열의 최종 넓이를 다루는, 첫번째 인자만 설정하였습니다. control sequnce ~a의 두번째 인자를 설정하는 예제를 살펴봅시다:
[REPL]

 보시다시피, control sequence에 추가 인자는 쉼표로 구분되었습니다. 이번 경우 두번째 인자는, format 명령어에게 목표 넓이 10에 도달하기 전까지  (한번에 하나씩 하는 대신) 3개씩 공란을 추가하도록, 3으로 설정되었습니다. 이번 예제에서는, 형식화된 값에 9개의 공란이 추가되었습니다. 이것은 (설정된) 목표 넓이 10을 넘어섰다는 것을 의미하며, (foo에 9개의 공란이 추가된) 최종 넓이는 12가 됩니다. 이와 같이 다수의 채움문자열(padding strings)은 보통 필요한 기능이 아니므로, ~a control sequence의 두번째 인자는 드물게 사용됩니다.

 때로는 최종 값의 길이에 상관없이, 문자열에 추가할 공란의 수를 정확하게 조정할 필요가 있습니다. control sequence ~a에 세번째 인자를 설정하여 그러한 일을 할 수 있습니다. 예를들어, 형식화된 값 후에 정확하게 4개의 공란을 출력하기 원한다고 가정해봅시다. 세번째 control sequence 인자를 4로 설정하려고, 이 인자 앞에 처음 두 인자들이 공란이라는 것을 알리는 두개의 쉼표를 넣었고, 다음으로 4를 넣었습니다:
[REPL]

 결과로 정확하게 4개의 공란이 삽입되었습니다. 처음과 두번째 인자가 쉼표전에 설정되지 않았기 때문에, 기본 값이 사용되었습니다.

 4번째 control sequence 인자는 어떤 문자가 채움padding에 사용될지 지정합니다. 예를들어, 다음 리스트에서 출력된 값에 4개의 느낌표를 체워넣었습니다:
[REPL]

 또한 이러한 control sequence 인자들은 결합할 수 있습니다. 예를들어, 다음처럼 느낌표가 값 앞에 보여질거라는 것을 표시하려고, 코드에 @ 심볼을 추가할 수 있습니다:
[REPL]

 format 명령어의 control sequence들의 대략적인 것을 살펴보았음으로, 이제 어떻게 이들이 숫자와 함께 형식화되어 사용되는지 살펴봅시다.


Control Sequences for Formatting Numbers
 format 명령어는, 숫자의 보여짐을 조정하는 특별하게 설계된, 많은 옵션을 가지고 있습니다. 그중 몇몇 유용한 것들을 살펴보겠습니다.
 

Control Sequences for Formatting Integers
 우선, 다른 진법base을 이용하는 숫자를 나타내기 위해 format을 사용할 수 있습니다. 예를들어,  ~x control sequence로 숫자를 16진수(base-16)로 나타낼 수 있습니다:
[REPL]

 유사하게, ~b control sequence로 숫자를 2진수(base-2)로 나타낼 수 있습니다:
[REPL]

 심지어 ~d control sequence를 사용하여 값이 10진수(base-10)로 나타낸다고 명시적으로 선언할 수 있습니다:
[REPL]

 이번 경우, 더욱 generic한 ~a control sequence를 사용한 것과 동일한 결과를 얻을 것입니다. 차이점은 ~d는 10진수 숫자의 출력을 지정하는 특별한 인자와 flag들을 지원합니다. 예를들어, 수의 그룹 구분자로써 쉼표를 활성화 시키기 위해, colon(:)을 control sequence에 놓을 수 있습니다:
[REPL]

 수의 넓이를 지정하기 위해, ~a와 ~s control sequence에서 했던것 처럼 채움 인자를 설정할 수 있습니다:
[REPL]

 채움에 사용되는 문자를 바꾸기 위해 원하는 문자를 (이번 경우 문자 x) 두번째 인자로 통과시킵니다:
[REPL]


Control Sequences for Formatting Floating-Point Numbers
 소수는 ~f control sequcne로 다룰 수 있습니다. 이전에 다루었던 control sequence들과 같이, 첫번째 인자를 바꿈으로써 넓이를 바꿀 수 있습니다. 소수에서 사용할 때에는, format 명령어는 요청한 문자 수에 맞게(소수점을 포함하여) 자동적으로 값을 반올림 할 것입니다:
[REPL]

 보시다시피, 3.14의 최종 넓이는 control sequence에서 설정된 것과 같이 문자 4개의 넓이입니다.

 ~f control sequence의 두번째 인자는 소수점 후에 보여질 숫자의 수를 조정합니다. 예를들어, 이전 예제에서 두번째 인자로 4를 넣으면, 다음과 같은 결과물을 얻을 것입니다:
[REPL]

 실제로 Common Lisp는 상수 pi를 표준의 일부로 포함하므로, 이와 같이 다시 작성할 수 있습니다:
[REPL]

 ~f contro sequence의 세번째 인자는 10의 제승입니다. 예를들어, 분수에 10^2를 곱하여 퍼센티지로 바뀌도록 세번째 인자에 2를 넣을 수 있습니다:
[REPL]

 덧붙이자면, ~f대신 화폐 형식에서 사용되는 control sequence ~$로 사용할 수 도 있습니다:
[REPL]

 여러분은 이번 장의 시작부분에서 ~$를 사용한 예제를 보았습니다.


Printing Multiple Lines of Output
 Common Lisp는 출력중에 새로운 라인을 추가하는 두가지 다른 명령어를 가졌습니다. 우선, terpri는 단순히 Lisp에게 현재 라인을 끝내고 다음 출력을 위해 새로운 라인으로 시작한다는 것을 알립니다. 예를들어, 이와 같이 다른 라인에 두 수를 출력할 수 있습니다:
[REPL]

 또한 fresh-line으로 새로운 라인을 넣을 수도 있습니다. 이 명령어는 REPL에서 커서 위치가 라인 앞부분에 위치 하지 않는 경우에만 새로운 라인을 추가합니다. 예제를 살펴봅시다:
[REPL]

 보시다시피, 두 princ사이에 위치한 두 fresh-line은 출력된 숫자 사이에 단지 하나의 라인이 출력되도록 합니다. 처음 fresh-line은 새로운 라인을 추가합니다; 두번째 fresh-line은 무시합니다.

 terpri 명령어는 "새로운 라인을 추가하라"고 말하는 반면, fresh-line은 "만약 필요하다면, 새로운 라인을 추가하라"고 말합니다. terpri명령어를 사용하는 코드는 이전에 무엇이 출력되었는지 "알아야" 합니다. 그렇지 않으면, 보기 흉한 빈 라인들이 보일 것입니다. 프로그램의 다양한 부분들이 서로에 대해 가능한 적게 아는 것이 좋고, 다음으로부터 하나의 데이터 조각의 출력을 분리하므로, 대다수의 Lisper들은 terpri보다 fresh-line을 선호합니다.

 format 명령어는 terpi와 fresh-line과 비슷한 두 control sequence를 가졌습니다:
 
~% : 모든 경우에 새로운 라인을 추가한다 (terpri 처럼)
~& : 필요하다면 새로운 라인을 추가한다 (fresh-line 처럼) 

 이 예제들은 이러한 차이점을 보여줍니다:
[REPL]

 보시다시피, ~%를 사용한 것은 보기 흉한 빈 라인을 출력하지만, ~&를 사용한것은 그렇지 안습니다.

 또한 이 두 line-termination sequence는, 새로운 라인이 만들어질 수를 나타내기 위해, 그 앞쪽에 추가 인자를 가집니다. 이것은 결과물에 공백을 두기 위해 빈 라인을 사용하기 원할때 유용합니다. 예를들어, 다음 예제에서 5를 추가 하여 결과물에 빈 라인 5개를 더하였습니다:
[REPL]


Justifying Output
 또한 format 명령어는 text 자리맞춤justification에 대한 수 많은 제어권을 저희에게 줍니다. control sequence는 테이블 구성, 가운데 text, 그리고 다른 유용한 justification feat들을 제공합니다.

 다양한 justification rules의 이해를 돕기 위해, 다양한 문자의 길이를 지닌 서로 다른 동물들의 이름을 반환하는 간단한 함수를 작성할 수 있습니다:
[REPL]

 이제 무작위 동물 테이블 한 뭉텅이를 출력하길 원한다고 가정해봅시다. ~t control sequence를 사용함으로써 이러한 일을 할 수 있습니다. ~t는, 형식화된 값이 보여질때 column위치를 지정하는, 인자를 취할 수 있습니다. 예를들어, 5번째, 15번째, 25번째 문자 위치에 3열로 보여지게 함으로써, 이 테이블을 만들 수 있습니다:
[REPL]

 loop명령어와 repeat 10 절은 loop 본체를 10번 실행한다는 것을 기억하시기 바랍니다. 보시다시피, ~t control sequence의 사용으로 동물들이 깔끔하게 정형화된 테이블안에 위치하도록 하였습니다.
[PIC]

 이제 모든 동물들 하나의 라인에서 동일한 공간만큼 떨어져 있길 원한다고 가정해봅시다. 이를 위해, 다음처럼 ~<와 ~> control sequence들을 이용할 수 있습니다:
[REPL]

 어떻게 동작하는지 알아내기 위해 이 control string을 파해쳐봅시다:
[PIC]

 우선, ~30< 은 함수에게 justified text 블록을 시작한다는 것을 말합니다. 인자 30은 블록이 30문자의 넓이가 될 것이라는 것을 나타냅니다. 다음으로, 각 동물들을 위한 세가지 ~a control sequence들을 가졌습니다. 각 ~a는, ~<에 의해 justified되는 새로운 값을 시작한다는 것을 format에게 알리며, ;로 구분되어졌습니다. (~; sequence들은 값을 justify하기 위해 삽입되어야 하는 추가 공간의 위치를 나타냅니다.) 그런 다음 ~> command sequence로 justified section을 마칩니다.

 각 라인에 있는 동일한 동물 공간이 column이 정렬된다는 것을 보증하지 않기 때문에, justification ~< command sequence에 :@ flag를 추가하였습니다. 예를들어, 다음과 같이 중첩되는 중앙 column을 만들 수 있습니다:
[REPL]

 이와 동일한 방법으로 :@와, 좌우 끝에 추가 공간을 넣어 중앙정렬시키는, 다수의 justified 값들을 이용할 수 있습니다:
[REPL]

 이 단계는 3개의 중앙정렬된 column을 가지는데 있어 한발짝 나아가게 해주지만, 3개의 중앙정렬된 column을 이용하여 값을 정렬하도록 format에게 말하지 않고 하나의 라인에서 정렬을 하기 때문에 여전히 조금 엉성해 보입니다.

 중첩 column을 하기위해 :@ flag를 사용하고, row는 3개로 분리된 10-문자 justification seciton을 사용하여 기술할 것입니다:
[REPL]

 마침네, 저희는 중앙정렬된 무작위 동물 column을 가지게 되었습니다!
 보시다시피, format의 layout 옵션은 매우 유연합니다. 어플리케이션을 디버깅할때 종종 복잡한 리스트와 테이블 데이터를 만들어야 하므로, 데이터나 더 복잡한 프로그램들을 제어할때 이러한 기법들tricks은 매우 유용합니다.


Iterating Through Lists Using Control Sequences
 format 함수와 control sequence들은 사실상 프로그래밍 언어입니다.(사실, 많은 Lisper들은 domain-specific language라 부르며, 이를 17장에서 다시 보게 될 것입니다) 그리고, 대다수의 프로그래밍 언어와 같이, format은 데이터를 loop할 수 있습니다. ~{와 ~} control sequence를 이용하여 그 작업을 합니다.

 looping을 하기 위해, format 함수에 ~{와 ~}를 포함하는 control string과 리스트를 넣습니다. ~{와 ~} sequence들 사이에 있는 control string 부분은 loop의 몸통처럼 다루어집니다. 그 다음에 오는 리스트의 길이만큼 실행될 것입니다. format 함수는, 각 항목에 control string의 specified section을 적용한, 리스트를 iterate할 것입니다.

 예를들어, 테스트로 동물 리스트를 만들어 봅시다:
[REPL]

 이제 이 리스트를 loop하기 위해 ~{ ~} control sequence를 사용하였습니다:
[REPL]

 loop를 하기 위해, *animals* 변수를 format 함수에 통과시켰습니다. control string은 *animals* 각 맴버들을 위한 "I see a ~a" 문장으로 구성된 리스트를 통해 순환iterate됩니다.

 단일 iteration construct는 이 예제처럼 리스트로부터 하나 이상의 항목들을 받을 수 있습니다:
[REPL]

 여기서, 저희는 단일 looping construct에 두 ~a control sequences가 들어 있는 것을 보았습니다. 각 ~a는 리스트로부터 하나의 동물을 끌어오므로, 매번 loop를 돌때마다 두마리의 동물이 출력됩니다.


A Crazy Formatting Trick for Creating Pretty Tables of Data
 이미 봤던 control sequence 뿐만 아니라 새로운 것을 사용하는 마지막 format 예제를 살펴봅시다.  이 예제는 control sequence가 복잡한 행동을 하기 위해 어떻게 역여질 수 있는지 보여줄 것입니다.
[REPL]

 근사하게 형식화된 숫자 테이블을 만들기 위해선, loop 명령어에 의해 생성된 숫자 리스트를 iterate해야 하므로, 우선 ~{ ~} looping control sequence를 사용합니다. iteration과 함께, 이전에 사용했던 justification control sequence ~< ~>를 넣었습니다. 이번 경우에는, 그것을 text를 justify 하기위해 사용하지 않고, 대신에 결과 text를 조각으로 나누기 위해 사용하였습니다. 이것이 숫자 100개를 근사하고 깔끔한 10열로 바꾸는 방법입니다. justification control sequences ~< ~> 안에  동일한 길이의 조각으로 text를 나누는 ~:; control sequnece를 넣었습니다. justification내부에서 사용할 때, 이 sequence ~:; 앞에 오는 control string은(이번 경우 |~%|에서 일어난) 현재 커서 위치가, 두번째 인자로 33으로 정한 지점처럼, 특정 지점에 오면 반응할 것입니다. 다시말하자면, format 함수에게, "33개의 문자를 지니면, 새로운 라인을 시작해"라고 말하는 것입니다. |~%| control string은 라인을 종료하고 세로줄을 출력합니다. 출력된 숫자는, 두 문자 넓이로된 left-justified 숫자를 출력하는, ~2d를 사용하여 형식화된 것입니다.

NOTE 
 단일 control sequence의 모든 세부사항은, Common Lisp HyperSpec http://www.lispworks.com/documentation/HyperSpec/Front/index.htm 을 보시기 바랍니다.


Attack of the Robots!
[PIC]
 여기서, 여러분에게 악몽을 선사할 매우 두려운 게임을 보게됩니다: 이 게임에서, 로봇들이 세계를 지배하였으며, 여러분의 임무는 그들을 파괴시키는 것입니다. 이러한 구상도 소름끼치지만, 실재로 Lisp 프로그래머에게 악몽을 주는 부분은, 완전한 함수형 로봇전투게임으로 작성된게 아니라 코드 한page에 loop와 format명령어를 남용하였다는 것입니다! (이 프로그램은 이전 섹션에서 다루었던 "crazy formatting trick"을 이용하였습니다)

 이 코드의 기본적인 설명을 달아놨습니다. 어떻게 게임이 동작하는지 더 자세히 이해하기 원한다면, 이전 두개의 장의 대부분의 내용을 살펴봐야 합니다. 또한, 게임의 소스 코드를 다운받고 더욱 철두철미한 코드의 해설을 읽기 위해, http://landoflisp.com/ 에 방문할 수 있습니다.

 게임에서 이기기 위해선 모든 로봇들이 서로 부딧치도록 전략적으로 움직여야 합니다. 방향키는 QWE/ASD/ZXC입니다. 이 문자들 여러분의 키보드 왼쪽에 위, 아래, 좌, 우, 또 대각선으로 격자 형태를 이루고 있습니다. 또한 T키로 텔레포트를 할 수 있습니다.

 즐기세요!
[PIC]


What You’ve Learned
 사실 이번장에서 format 함수의 모든 기능에 다가서지는 못했습니다. 그러나, 다음에 배울 초석을 제공하였습니다:

z format 명령어의 첫번째 인자는, 출력을 REPL에 보낼지 스트림으로 보낼지 혹은 문자열로 반환할지 결정한다.
z format 명령어의 두번째 인자는, 데이터가 출력될 방식을 바꾸는 control string이다.
z control string은 그 자신이 마치 프로그래밍 언어처럼 행동하는 세련된 syntax를 가졌다.
z 나머지 format 인자들은 control string로부터 형식화된 출력의 내장된 값으로 참조될 수 있는 값이다.
z Lisp 값을 형식화된 문자열에 내장하여, ~s나 ~a control sequcne를 사용한다.
z 많은 control sequence들은 숫자의 모습을 바꾸어 출력하는데 이용될 수 있다.
z 또한 format 명령어는, 예를들어, 매우 다른 스타일로 구성된 format 테이블에 사용될 수 있는 복잡한 looping 능력을 가졌다.