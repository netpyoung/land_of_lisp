지금까지 배운 바로는, Lisp명령어는 각 명령어를 괄호로 감싸는 상당히 특이한방식으로 입력해야 합니다. 이번 장에서는, Lisp는 왜 이렇게 동작하는지에 대해 알아볼 것입니다.

프로그래밍 언어이든 인간 언어이든지 간에-어떤 언어를 이해하기 위한 방법으로, 언어학적 관점으로 두 개념부터 시작할 필요가 있습니다 : 문법과 의미.


Syntax and Semantics
여기 일반적인 영어 문장이 있습니다 :
My dog ate my homework.

 이 문장은 영어의 문장에서 적법한 문법을 지니고 있습니다. 글의 조각인 문법은 문장이 유효하기 위해 필요한 기본적인 규칙을 나타냅니다. 이 책이 준수하고 있는 영어 문장의 규칙 입니다:
z 문장의 끝에는 마침표를 찍습니다.
z 문장은 주어와 동사를 포함하고 있습니다.
z 문장은 (이집트의 상형문자(hieroglyphics) 혹은 슈메르 설형문자(cuneiform)와는 다른)영어 알파벳으로 이루어졌습니다.

 그러나, 문장에는 문법 이상의 것이 있습니다. 우리는 문장의 실제 의미가 무엇인지 살펴 보아야 합니다. 문장에서의 문법에 대해 말을 할때, 우리는 이것의 의미를 주목합니다. 예를들어, 여기 거의 유사한 의미를 가진 문장이 있습니다 :
My dog ate my homework.
The canine, which I possess, has consumed my school assignment.
Der Hund hat meine Hausarbeit gefressen.

처음 두 문장은 영어에서 동일한 것을 다른 방식으로 말할 것입니다. 세번째 문장은 독일어이지만, 여전히 같은 의미를 가집니다.

 이 두 idea의 동일한 차이가 프로그래밍 언어에서도 존재합니다. 예를들어, 여기에 C++로 쓰여진 코드가 있습니다 : 

 이 코드는 C++문법을 준수합니다. 주목할 점은, 다른 언어들과 다른 C++의 수많은 기괴한 문법을 넣었습니다. 만역 여러분이 다른 문법을 지닌 프로그래밍 언어로 코드를 작성한다면, 아마도 적법하지 않아 에러를 발생시킬 것입니다.

 물론 이 C++코드 또한 어떤 것을 의미할 것입니다. 만약 여러분이 C++프로그램안에 (적절한 문맥으로)이 코드를 넣어본다면, 여러분의 컴퓨터에서 어떠한 일을 수행할 것입니다. 프로그램의 수행하는 동작은 프로그램의 프로그램에 대한 의미 입니다. 일반적으로 다른 프로그래밍 언어에서 같은 의미를 지닌 프로그램을 작성하는 것이 가능합니다; 그럼으로써, 프로그램은 두 언어에서 같은 일을 할 것입니다.

 요약하자면, 대부분의 프로그래밍 언어들은 유사한 semantic power를 지니고 있다는 것입니다. 그러나, 기본적인 Lisp코드는 다른 주요 언어와는 달리 훨씬 간단한 문법을 지녔습니다.  간단한 문법을 지닌다는 것은 Lisp언어의 기능을 정의한다는 것입니다.


The Building Blocks of Lisp Syntax
 이전 섹션에 있는 괴상한 C++코드로부터 C++은 -이름공간표시, 포인터 역참조, cast연산, 맴버 함수 참조, Boolean 연산자, 기타등등을 위한- 많은 기괴한 문법들을 지녔다는 idea를 얻으실 수 있습니다.

 만약 여러분이 C++컴파일러를 작성한다면, 어떤 코드를 작성하기 전에 컴파일러가 이 코드를 읽을수 있으며 수많은 C++문법을 따라야 하기 때문에, 많은 노력이 필요할 것입니다.

 Lisp컴파일러/인터프리터를 작성하는것은 매우 쉽습니다. 코드를 읽는 Lisp컴파일러 혹은 인터프리터 부분(어떤 Lisper는 이것을 reader라 부릅니다)은 C++이나 다른 주요언어보다 훨씬 간단 합니다. Lisp코드의 일부를 가져왔습니다 :

 이 함수의 정의는 단순히 수를 재곱하는 함수를 만드는 것이며, 심볼(symbol)과 괄호만 구성되었습니다. 사실, 이것은 단지 괄호로 구분되어진 list들이 묶여 있는걸로 보여집니다.

 Lisp는 코드 조각을 구성하는 하나의 방법을 가지고 있습니다. 괄호를 이용해 list안에 있는 코드를 구성하는 것입니다.

 모든 기본 Lisp코드는 다음과 같은 간단한 문법을 사용합니다 :

 list에 어떤 것을 넣을 수 있을까요? 다른 list들 말고도, symbol들과 숫자 그리고 문자열도 코드에 넣을 수 있습니다. 여기서, Lisp를 사용할 기본 블록구성과 데이터형을 알아보겠습니다. (다음 장에서 Common Lisp의 다양한 데이터형에 대해 다룰 것입니다.)


Symbols
심볼은 Lisp에 있어 기본적인 데이터 형식이며 널리 쓰입니다. Lisp의 심볼은 stand-alone단어 입니다. 일반적으로 Common Lisp 심볼은 문자와, 숫자, 그리고 + - / * = < > ? ! _와 같은 기호의 구성입니다. Lisp심볼의 예에는 foo, ice9, my-killer-app27, 심지어 --<<==>>--이 있습니다.
 Common Lisp의 심볼은 대소문자를 구분하지 않습니다. 설명을 위해, eq함수가 두 심볼을 구분해 낼 수 있는지 보겠습니다 :

 여기서 볼 수 있듯이, 이 함수는 두 심볼이 동일한 것으로 간주하고 T를 반환하였습니다(지금은, 심볼앞에 붙어있는 쉼표는 무시하겠습니다. 곧 있을 데이터 모드를 다룰때 설명하겠습니다).



Numbers
 Lisp는 정수(integer)와 소수(floating-point number)를 지원합니다. 숫자를 쓸때 소숫점의 존재가 이것이 소수인지 정수인지를 나타냅니다. 1과 1.0은 Common Lisp에서 전혀 다른 두 수 입니다.
 예를 들어, 정수와 소수를 같이 사용하는 수학 함수를 사용한다면, 정수는 "소수점이 찍히고", 소수가 반환될 것입니다. 소수점에 관한 예가 있습니다 :

 반환된 2.0에 소수이 찍힌것은 이 수는 소수라는 것을 말해줍니다.

 Lisp는 수를 다룸에 있어 다른 언어들에 비해 놀랄만한 성능을 발휘합니다. 예를 들어, expt함수를 통해 53의 53승을 계산한 것이 있습니다 :

 멋지지 않습니까? 많은 언어들은 이와 같은 큰 숫자와 관련된 계산에 먹통이 될 것입니다. 마지막으로, 여러분은 두 정수를 나누기를 하면 어떻게 되는지 알고 있을 것입니다 :

 나누기 함수는 4를 6으로 나눕니다. 여러분이 예상했던 유리수(rational number)(0.66666...)와는 달리 두 정수 사이에 나누기 심볼을 넣음으로써 분수(fraction)를 반환합니다. 2/3의 결과는 유리수이지만, 이와 같이 분수로 표현하는것이 수학적으로 이상적인 방법입니다

 참고하자면 여기에 소수를 넣으면 다른 결과를 얻을 수 있습니다 :

 이전 예제에서, 소수점이 찍힌 수(4.0)로 인해 유리수를 결과로 내어 놓습니다.
 여러분이 수학쟁이가 아니라면 많이 사용하지는 않겠지만, 적어도 여러분은 여러분의 코딩하는 동안에 이런것을 보고 어떻게 동작하는지 알고 있습니다. 후에 다른 계산에서 이것을 사용할 때 수에 관해서는 Lisp가 옳은 일을 할꺼라는 확신이 있습니다. Lisp는 멋집니다.


Strings
 마지막 Lisp의 기본 블록 구성물은 문자열입니다. 비록 문자열이 실제 이론적인 관점에서 Lisp를 구성하고 있지는 않지만, 인간은 글로 소통하는 것을 선호함으로 프로그램에서는 일반적으로 문자열이 필요합니다.

 Lisp에서는 문자들을 쌍따옴표로 감싸므로써 문자열을 나타냅니다. 예를들어, "Tutti Frutti"는 알맞은 문자열 입니다.

 princ함수를 사용하여 화면에서 문자열을 볼 수 있습니다 :

참고하자면 REPL에서 글자를 출력하면 두번 반복하여 보여지게 됩니다. 첫번째, princ에 의해 실제 출력되어지는것을 봅니다. 그러나, REPL은 들어온 연산을 평가한 결과를 보여주기 때문에, 문자열이 다시금 보여집니다. pric함수는 원본 문자열을 반환하기 때문에 이러한 일이 발생합니다.

 문자열은 예외 처리한 문자(escaped characters)라 불리는것 역시 포함할 수 있습니다. 만약 문자열에 쌍따옴표나 역슬러쉬(backslash)를 포함하고 싶다면, 이러한 문자앞에 역슬러쉬를를 붙여야 됩니다. 예를들어, 이 문자열에는 두 예외 처리한 쌍따옴표가 있습니다 :

 여기서 볼 수 있듯이, 두 쌍따옴표 앞에있는 역슬러쉬는 Lisp에게 문자열에서 문자 그대로 쌍따옴표라는것을 말하고, 다른 문자처럼 화면에 표기됩니다.


How Lisp Distinguishes Between Code and Data
 Lisp프로그램을 작성할때, Lisp는 우리의 프로그램의 (실행될)코드와 데이터부분을 어떻게 구분할까요? Lisp의 문법은 이 둘을 구분할 특별한 방법을 지니고 있습니다.

 Common Lisp는 여러분의 code를 읽을때 두가지 방식(mode)을 사용합니다 : code mode과 data mode입니다. Lisp코드를 작성할때, 여러분은 이 두 mode를 전환할 수 있습니다.


Code Mode
Lisp REPL에 어떤것을 입력하면, 컴파일러는 여러분이 실행하기 원하는것을 입력했다고 가정합니다. 다른말로 하자면, Lisp는 여러분이 기본적으로 code mode으로 코드를 작성한다고 가정합니다.

 이미 다뤘듯이, Lisp는 들어온 Lisp코드를 list로 간주합니다. 그러나, code는 특별한 종류의 list가 될 수 있습니다 : form. 따라서 REPL에 명령어를 칠때와 같은 코드방식일때는, 여러분이 입력한 명령어들은 form으로 구성되어질 필요가 있습니다 :


 form은 특별한 명령어-보통 함수의 이름입니다-로 시작하는 간단한 list입니다.

 form을 읽을시, Lisp는 list에 있는 다른 것들을 함수의 인자로 보냅니다. 예를들어, REPL에 다음과 같이 쳐봅니다 :


 지수(exponent)를 계산하기 위해 expt를 호출한 결과는 2^3 = 8입니다. 이 명령어는 Lisp의 기본적인 방법으로 입력되었습니다: 함수 이름이 앞에 오는 form.

 Lisp가 명령어로부터 들어온 인자를 읽을때 code mode로 가정합니다. 한 예제가 있습니다 :

 이 예제는 두개의 중접된 form을 가지고 있습니다. Lisp는 처음 code mode에서 전체 표현식을 살펴봅니다 expt명령어를 위해 저희가 form을 입력하였다고 결정합니다. 그다음, Lisp는 code mode로 이 명령어의 인자를 살펴봅니다. 이 인자중 하나인 (+ 3 4)는 올바른 form입니다. 이 form이 실행되면서, 7을 산출합니다. 그후, 결과가 expt form으로 빠져 나오면서 실행됩니다.


Data Mode
 여러분이 예상한데로, data mode에서 써진것은 데이터로 여겨집니다. 이것은 컴퓨터가 "실행"을 시도하지 않을 것을 의미하며, 코드에 있는 정보를 데이터로 가질 수 있게 합니다.

 data mode의 행동에 대해 살펴봅시다. 이전 예제와 같은 form을 하나만 달리해서 입력할 것입니다 :


 이번에는, 따옴표를 list 앞에 놓았습니다. 2의 3제곱 대신에, Lisp는 표현식을 되풀이 할 것입니다. 따옴표는 Lisp에게 따옴표 이후 form을 데이터 덩어리로 취급하도록 지시합니다 - 단순한 list입니다. Lisp는 입력한 것에 대해 평가 결과를 반환하는데 list자체 그 자체입니다. 이것은 list에 있는 함수와 변수를 무시하고, 모든것을 데이터로 취급합니다.

 따옴표가 list앞에 있어 명령어로 평가하지 말라는 것을 quoting이라 부릅니다. quoting을 사용함으로써 Lisp에게 "다음 나올 부분은 명령어 명령어가 아니란다. 이것은 단지 내 프로그램의 데이터 덩어리야"라고 말합니다.


Lists in Lisp
List는 Lisp에서 중요한 특징입니다. 이것은 여러분의 Lisp 코드(와 데이터)를 한데 묵어줍니다
다음에 나오는 기본 Lisp코드를 보겠습니다 : 

 이 코드 조각은 심볼 (expt)와 두 수를 포함하고 있고, list로 묶여있으며, 괄호로 구분되어집니다.

 Lisp프로그램을 집이라 생각해 봅시다. Lisp에서 집을 짓는다면, 벽은 list로 만들어 집니다. 벽돌은 심볼, 숫자, 문자열로 만들어졌습니다 그러나, 벽은 벽돌을 서로 고정시킬 시맨트가 필요합니다. 이와 같은 방법으로, Lisp에서는 cons cells라 불리는 구조물로 list를 서로 묶어줍니다.


Cons Cells
 Lisp에서 list들은 cons cells로 한데 묶여 있습니다. cons cells와 list사이의 관계를 이해하는 것은 여러분에게 Lisp의 동작에 관한 더 낳은 idea를 줄 것입니다.

 cons cell은 이와 같이 생겼습니다 : 


 이것은 두 상자가 연결되어 만들어 졌고, 각각의 것들은 다른 것을 가리킬 수 있습니다. cons cell은 다른 cons cell이나 다른 Lisp데이터 형을 가리킬 수 있습니다. 서로 다른 두게를 가리킬 수 있음으로써,  list안에 있는 cons cells를 연결할 수 있습니다. 사실, Lisp에서 list는 단지 하나의 추상적인 환상입니다 -  모든것은 실제로 cons cells로 구성되어있습니다.

 예를들어, '(1 2 3)이라는 list를 만들었다고 가정합니다. 여기에 이 list가 컴퓨터 메모리상에 어떻게 반영되는지 나와 있습니다:


 이것은 세개의 cons cells을 사용해여 만들어 졌습니다. 각 cell은 숫자를 가리키고, 뿐만아니라 다음 cons cell도 가리킵니다. 마지막 cons cell은 nil을 가리키고, list를 종료합니다. (만약 다른 프로그래밍 언어에서 linked list를 사용해 본적이 있다면, 이것은 같은 개념입니다) 여러분은 이러한 배치를 여러분의 친구를 부르는 과정처럼 생각할 수 있습니다. "이번주 파티에, 나는 밥을 부를 것이고, 밥은 리사를 부를 것이고, 누구는 누구를 부를 것이고..." calling chain에 있는 각 사람들은 하나의 전화에만 반응하고, list에 있는 다음 전화를 활성화시킵니다.


List Functions
 list를 조작하는 것은 Lisp프로그래밍에 있어 매우 중요합니다. Lisp에서 cons cells을 조작하기 위한 세가지 기본 함수가 있습니다: cons, car, cdr.


The cons Function
 여러분이 Lisp프로그램에서 (유형에 관계없이)두 데이터 조각을 연결시키길 원한다면, cons함수를 쓰는것이 일반적인 방법입니다. cons를 호출하면, Lisp컴파일러는 일반적으로 자그마한 메모리 조각을 할당하고, 두 개의 객체를 참조할 수 있는 cons cell이 연결됩니다. (이상하게도, 두 개가 연결된 다음에 list가 됩니다) 예를들어, chicken심볼과 cat심볼을 연결하겠습니다 : 

 보시다싶이, cons는 괄호와 연결된 두 항목 사이의 점으로 표시하는 하나의 cons sell 객체를 반환합니다. 이것을 일반적인 list로 혼동하지 않길 바랍니다. 가운데 있는 점은 이것을 cons cell로 만들어 주며, 단순히 이 두 항목을 서로 연결시킵니다.

 두 데이터 조각 앞에 따옴표를 붙임으로써 Lisp가 이것을 data로 보고 그것을 코드로 보고 평가하려고 시도하지 않습니다.

 다른 데이터 조각 대신에, 리스트의 오른쪽에 nil 심볼을 붙이면, 어떤 특별한 일이 발생합니다 : 

 cat과 달리, 이번 출력 결과에서 nil은 보이지 않습니다. 여기에는 간단한 이유가 있습니다: nil은 Lisp에서 list를 끝낼때 사용하는 특별한 심볼입니다. 이것은, Lisp REPL은 간편한 방법을 택해서 chicken이란 하나의 아이템을 가진 list를 만들었다고 말합니다. 명시적으로 cons cell을 보임으로써 결과를 표시할 수 있고 출력하면 (CHICKEN . NIL)입니다. 그러나,  우연의 일치로 이런 결과는 list이며, 대신에 이것은 list표기법으로 보여지게 됩니다.

 여기서 배울수 있는것은 Lisp는 자신만의 방법으로 cons cells을 "숨긴다"라는 것입니다. 가능하면, list를 사용한 결과를 보여줍니다. list를 사용해 결과를 보여주는 방법이 없을 경우에만 (객체 사이에 점이 찍힌)cons cell로 볼 수 있습니다.

 이전 예제를 이렇게도 쓸 수 있습니다 : 

  Common Lisp에서 빈 list()는 nil심볼로 교체해서 사용되어질 수 있습니다. 빈 list의 의미를 갖고있는 list의 종결자를 생각해 봅니다. chiken에 빈 list를 추가함으로 어떤것을 얻었습니까? 단순히 chicken이 들어간 list였습니다. cons 함수는 list앞에 새로운 것을 추가 할 수 있습니다. 예를 들어 (beef chicken)를 포함하는 list앞에 pork를 추가하려면, 다음과 같이 cons를 사용합니다 : 

 Lisper가 cons를 사용하는 것에 대해 예기할때, 무언가를 consing한다고 말합니다. 예를 들면, beef와 chicken을 포함하는 list와 prok를 cons하였습니다.

 모든 list들이 cons cells로 만들어 졌기 때문에, (beef chiken)리스트는 두 cons cell을 가진 form으로 만들어 졌고, 아마도 이와 같을 것입니다 :

 이 두 예제를 조합해봤을때, 모든 list들을 cons들 처럼 볼 수 있습니다. 이것이 실제로 일어나는 것이 나와 있습니다:

 기본적으로, 이것은 세가지 항목을 list로 cons한다고 우리에게 말을 하며, 우리는는 세가지 항목을 가진 list를 얻습니다. 어떠한 대량의 데이터의 복사 혹은 삭제가 일어날 필요가 없습니다.

 REPL은 입력한 것들을 list로 보여주고, (pork beef chiken) , 이것은 우리가 입력한 것 만큼 정확한 것을 쉽게(아니면 조금 덜 편리한것을 통해) 출력할 수 있습니다 : (cons 'pork (cons 'beef (cons 'chicken ()))). 다른 것과 완벽히 일치합니다. Lisp에서, cons cells의 사슬과 list는 정확하게 같은 것입니다.


The car and cdr Functions
 list는 단순한 두 item cell의 chains입니다.
 car 함수는 cell의 첫번째에 있는 것을 얻어올때 사용합니다 :

 cdr함수는 두번째에 있는 값이나, 남아있는 list를 얻어옵니다 :

 저희는 car와 cdr을 cadr, cdar 혹은 cadadr과 같은 새로운 함수로 묶을수 있습니다. 이것으로 하여금 간결하고 정확하게 특정 데이터 조각을 복잡한 list에서 꺼내올 수 있습니다. cadr를 입력하는 것은 car와 cdr을 같이 사용하는 것과 같습니다 -이것은 list의 두번째 것을 반환합니다. (두번째 cons cell의 첫번째 slot이 갖고 있는 item) 이 예제를 살펴봅니다 : 

 여러분은 cdr이 list에서 첫번째 것을 버린다는 것을 알고있습니다. 만약 여러분이 짥은 list를 가졌고 car를 사용하면 , 첫번째 것이 들어있는 새로운 list를 얻을 것입니다.  그리고, 이 두 명령어를 같이 사용하면, 원래 list에서 두번째 것을 얻을수 있을 것입니다. 최종적으로, cadr명령어를 사용하면, car와 cdr을 함깨 사용한것과 같은 효과를 냅니다. 본질적으로, cadr명령어를 사용하는 것은 list에서 두번째 것을 얻고 싶다고 말하는 것과 같습니다.


The list Function
편의를 위해, Common Lisp는 기본 세가지-cons, car, cdr-를 기반으로한 많은 내장 함수를 갖고 있습니다. list함수의 유용성중 하나는, 모든 cons cell들을 만들고 list를 구성하는 더러운 작업 한번에 할 수 있다는 것입니다 : 


 list함수로 개별의 cons cell를 지정하여 만든 것과 따옴표를 사용해 data mode에서 만들어진 list간에 차이가 없다는 것을 명심합니다. 이것들은 모두 같은 동물 입니다 : 



Nested Lists
 list는 다른 lits들을 포함할 수 있습니다. 여기 한 예제가 있습니다 : 

 이 list는 세개의 item을 갖고 있습니다. list의 두번째 item은 (duck bat), list 그 자체 입니다. 중첩 list의 예제가 있습니다 : 

 그러나, 뚜껑을 열어보면, 이런 중첩된 list는 여전히 cons cell들로 구성되었습니다. 중첩된 list로부터 item을 끌어내는 예제를 살펴봅시다. 첫번째 item은 (peas carrots tomatoes) 이며, 두번째는 (pork beef chicken)입니다:

 car함수는 list의 첫번째 item을, 이번 경우에는 list를 돌려줍니다. 다음으로, 안쪽에 있는 list로부터 첫번째 것을 짤라내 (CARROTS TOMATOES)을 나오게 하기 위해 cdr명령어를 사용합니다. 이 명령어를 같이 사용해도 결과는 같습니다. 최종적으로, cdar를 사용하면 cdr과 car를 불리한 것과 같은 결과를 돌려줍니다.

이 예제를 보면, cons cell은 복잡한 구조를 만드는 것을 허용하며, 저희는 그것을 사용하여 중첩된 list를 구성하는데 사용하였습니다. 중첩된 list가 단지 cons cell로 이루어 졌다는 것을 증명하기 위해, 여기 cons명령어만 사용하여 중첩된 list를 만드는 것이 있습니다:

 데이터 구조에서 사용할 수 있는 car와 cdr을 기반으로한 몇몇 예제들이 있습니다:
 
  Common Lisp는 여러분을 위한 이러한 함수들이 이미 모두 정의되어 있습니다. 여러분은 최대 4단계까지 c*r이란 이름의 어떤 함수를 바로 사용할 수 있습니다. 다시 말하자면, cadadr은 이미 여러분을 위해 존재하지만, cadadar(5단계에 있는)는 그렇지 않습니다(필요하다면 스스로 작성해야 합니다). 이 함수들은 Lisp에서 cons cells기반 구조를, 아무리 복잡하더라도 , 조작하는 것을 쉽게 만들어 줍니다.


What You’ve Learned
이번 장에서는, Lisp의 기본 문법에 대해 배웠습니다.
저희가 배운것을 나열해보면 : 
z Lisp에서 괄호는 문법의 양을 최소한으로 유지시켜준다.
z List는 cons cell로 만들어졌다.
z cons cell과 cons명령어로 list를 만들 수 있다.
z car와 cdr로 list 조각을 살펴볼 수 있다.
