DICE OF DOOM, A GAME WRITTEN IN THE FUNCTIONAL STYLE
15장. 함수형 스타일로 작성된 운명의 주사위 게임

 이제 저희는 더욱 세련된(그리고 재밋는) 함수형 스타일의 컴퓨터 프로그램을 만들 준비가 되었습니다. 책의 나머지 부분에서 이 프로그램을 확장시키면서, 우수한 성능을 유지며 우아한 함수형 코드를 작성하는 기법을 배울 것입니다.
[pic]

The Rules of Dice of Doom
 Dice of Doom 은 Risk, Dice Wars (http://www.gamedesign.jp/flash/dice/dice.html), 그리고 KDice (http://kdice.com/)류의 게임입니다. 처음에는 정신을-멍하게 만드는 Dice of Doom의 규칙을 단순하게 할 것입니다. 나중 장에서는 게임이 Dice Wars와 매우 유사하게 될때까지 이 규칙을 확장할 것입니다.

 여기 저희가 다룰 단순한게된 규칙이 있습니다:
z 두 플레이어(A와 B)는 6각형 영역을 차지한다. 각 영역은 6면의 주사위를 가지고 있다.
z 턴이 진행되는 동안, 플레이어는 몇 번이고나 움직일 수 있지만 적어도 한번은 움직여야 한다. 플레이어가 움직일 수 없다면, 게임이 끝난다.
z 움직임은 적의 영토를 공격함으로 이루어진다. 플레이어는 이웃 지역을 공격하기 위해선 더 많은 주사위를 가져야만 합니다. 당분간은 모든 공격이 자동적으로 승리를 이끌 것입니다. 나중에 변화하면서, 실제로 주사위 전쟁을 할 것입니다. 그러나 지금은 더 많은 주사위를 지닌 플레이어가 자동적으로 승리합니다.
z 전투에서 이긴 후에는, 패배자의 주사위는 보드에서 사라지며, 하나를 제외한 승자의 주사위는 새롭게 이긴 영역으로 이동한다.
z 플레이어가 움직임이 끝난 후에는 플레이어의 주사위 병력을 충원한다. 플레이어가 점령한 지역에 대해 충원은 좌측-상단 구석에서 시작하여 대각선 아래로 한번에 한 주사위씩 추가한다. 턴을 완료하여 충원에 의해 추가되는 최대 주사위 숫자는 플레이어에서 적의 것을 제한것 보다 하나가 적다.
z 플레이어가 턴을 넘겨받지 못하면, 게임은 끝난다. 이때 많은 수의 지역을 점령한 플레이어가 승자가 된다(또한 비기는거도 가능합니다.)


A Sample Game of Dice of Doom
 Dice of Doom의 구현에서 AI 플레이어를 포함할 것이기에, 매우 작은 보드 크기로 시작할 것입니다. 아마 여러분이 아시다시피, AI 코드는 매우 계산 집약적??(very computationally intensive)이 될 수 있습니다. 초벌 버전의 게임에서, 2x2보다 큰 보드는 CLISP를 멈추게 할 것입니다!

 여기 작은 2x2보드에서 플레이하는 완성된 게임이 있습니다:
[pic]

 게임이 시작해서, (검은 색으로 표기된)플레이어 A는 각각 3개의 주사위를 지닌 상단 두 지역을 보유합니다. (흰색으로 표기된)플레이어 B는 각각 3개, 1개의 주사위를 지닌 하단 줄을 차지하였습니다. 플레이어 A는 그의 주사위로 다른 하나의 주사위를 공격합니다. 공격이 끝난 후, 플레이어 A는 하나의 주사위는 뒤에 남기며 다른 것들은 이긴 지역으로 이동합니다. 그런 다음 플레이어 A의 턴을 넘깁니다.
[pic]

 이제 플레이어 B는 3개의 더미로 플레이어 A의 2개의 주사위를 공격합니다. 그런 다음 플레이어 B는 턴을 넘깁니다. 이 시점에서, 왼쪽 지역에서 플레이어 B는 하나를 충원받습니다. 플레이어 A의 주사위 2개를 죽였기 때문입니다. 충원은 규칙중 하나로써 죽인 주사위의 수에서 하나를 뺀 것으로 구성됩니다.
[pic]

 이제 플레이어 A는 주사위 3개로 공격을 하고 턴을 넘깁니다. 역시, 하나를 충원받습니다.
[pic]

 이제 플레이어 B는 2개로 하나를 공격하는 방법 만이 남아있습니다.
[pic]

 이제 플레이어 A는 플레이어 B의 남아있는 주사위를 모두 죽임으로써 승리를 취합니다. 보시다시피, 플레이어 A는 턴을 넘기기 전에 다양한 공격을 할 수 있었습니다. 플레이어 A가 승자가 됨으로써 이 게임은 끝나게 됩니다.


Implementing Dice of Doom, Version 1
 Lisp로 이 게임을 코딩해봅시다. 이전 장에서 다루었듯이, 이 게임은 clean하며 함수형 코드와 dirty하며 imperative한 코드를 포함할 것입니다. 여러분은 옆에 있는 "clean/functional" 혹은 "dirty/imperative" 아이콘으로 어떤 코드 뭉치인지 알 수 있습니다.


Defining Some Global Variables
 우선, 저희 게임의 기본 인자를 정의하는 몇몇 전역 변수를 만들 것입니다:
[source]

 3개의 주사위를 갖는 두명의 플레이어로 시작할 것이며, 보드는 2x2가 될 것입니다. Dice of Doom의 나중 버전에서는 더욱 긴박한challenging 게임을 위해 이 인자들을 증가시킬 것입니다.

 또한 현재 보드 크기에 대해 모든 숫자와 6각형을 아는 것이 유용하기 때문에, *board-hexnum*을 정의하였습니다. 영역이 비록 육각형으로 만들어졌지만, 육각형의 수는 사각형의 grid 면과 동일하기 때문에, 이는 기본적으로 정사각형 영역입니다

NOTE
 이번 장에서, 모든 코드 샘플은 dirty, imperative 혹은 clean, functional코드로 만들어졌는지를 나타내는 아이콘과 연결되었습니다. 이번 장의 끝부분에서, 각 스타일의 이점에 대한 평가와 차이점에 대해 쉽게 말할 수 있을 것입니다.


Representing the Game Board
 저희는 간단한 리스트를 이용하여 게임 보드를 표현할 것입니다. 좌측 상단부터 시작해서 대각선 아래로 이동하는 6각형들이 이 리스트에 저장될 것입니다. 각 6각형은 두 항목으로 리스트에 저장될 것입니다: 하나는 현재 점령한 6각형을 나타내며, 다른 하나는 그 지점에 있는 주사위 수를 나타냅니다.

 예를들어, 여기 게임 보드와 이것을 encode한 리스트의 한 예가 있습니다:
[pic]

 대부분의 Lisp 프로그래머들은 0부터 수를 세는 것을 선호합니다. 그러므로, 플래이어 A와 B는 숫자 0과 1로 표시되었습니다. 이 리스트는 플레이어 A가 첫번째 지역에 3개, 두번째에 3개의 주사위를 지닌 것을 나타냅니다. 플레이어 B는 세번째 지역에 3개, 네번째 지역에 하나를 지녔습니다.

 저희가 AI플레이어를 만들때, 보드에 있는 많은 지역을 매우 빠르게 살펴볼 필요가 있습니다. 때문에, 두번째 표현으론 배열 형식으로 생성할 것입니다. 리스트에 있는 숫자로된 지역을 확인하기 위해 잠재적으로 느린 nth함수가 필요합니다. 반면, 배열은 보드의 넓이가 매우 크더라도 지정한 지역에 대해 매우 빠른 탐색이 가능합니다.

 board-array는 리스트로 나타낸 보드를 저희가 필요한 배열로 변환합니다:
[source]

 게임을 개시할때, 무작위로된 보드로 시작할 것입니다. 여기 무작위 보드를 생성하는 그 함수가 있습니다:
[source]

 (아이콘에서 보여지듯이) 이 함수는 함수형 스타일이 아니므로, 매 호출마다 다양하며 무작위 결과를 생성합니다. 이는 보드를 리스트로 생성한다음 board-array를 이용하여 보다 빠른 배열 형식으로 바꿉니다.

 이는 Lisp 함수 random을 이용하여 무작위 값을 생성합니다. 이 함수는 집어넣은 수보다 적고 0보다 크거나 같은 매번 다양한 무작위 정수를 생성합니다. 전역변수 *num-players*와 *max-dice*를 사용하여 각 육각형에 무작위 값을 생성합니다.

 gen-board 함수를 테스트해봅시다:
[source]

 해쉬 마크(#)가 리스트가 아닌 저희가 생성한 배열을 나타낸다는 것을 명심하시기 바랍니다.

 저희는 (더 많은 플레이어를 도입하기 전까지, A와 B) 문자를 이용하여 플레이어를 이름 지울 것입니다. 여기 플레이어 번호를 문자로 변환시키는 함수가 있습니다:
[source]

 code-char 함수는 ASCII 코드를 적절한 문자로 변환합니다. 결과를 확인하기 위해 플레이어 1에 대해 이를 호출해 봅시다:
[source]

 마지막으로, 부호화된 보드를 취해 화면에 예쁘게 뿌려줄 함수를 만들어 봅시다. 저희 그림과 동일한 방식으로 보드를 기울일 것이기 때문에, 주어진 육면체에 맞닥들이는 여섯개의 육면체들이 확실해집니다.
[source]

 draw-board 함수의 목적은 콘솔로 먼가를 표시하는 것이기 때문에, 이는 분명 함수형이 아닙니다. 이 함수를 더욱 자세히 살펴봅시다.

 외부 loop는 변수 y에 저장된 보드의 모든 열을 통해 돕니다. 내부에 두개의 loop가 있습니다. 첫번째 내부 loop는 보드에 기울임을 주기위해 왼편에 들여쓰기를 추가합니다. 두번째 내부 loop는 변수 x에 저장된 행을 통해 돕니다. 그런 다음 적절한 hex 번호를 계산하기 위해 x와 y를 이용하고, aref를 사용하여 보드 배열로부터 hex를 받아옵니다. 최종적으로, 데이터를 육각형으로 출력합니다.

 여기 draw-board 함수의 결과물과 이와 비교할 그림이 있습니다:
[output]
[pic]


Decoupling Dice of Doom’s Rules from the Rest of the Game
 이제 저희는 첫번째 Dice of Doom 구현의 핵심을 고려한 코드를 작성할 준비가 되었습니다. 이를 코드로 작성하기 위해, 강력한 함수형 기술을 채용할 것입니다: 함수 파이프라인(function pipeline). 이는 저희 게임이, 이 방식을 따르는 구조로  수정될 게임 보드의 표현을 담을 큰 데이터 덩어리에 대해, 하나 다음에 다른 하나를 동작시키는 함수의 연속으로 이루어 진다는 것을 의미합니다. 함수 파이프라인은 나머지 게임 코드로부터 100% 분리된 게임 규칙 엔진을 만들도록 해 줄것입니다. 이것이 왜 매우 멋진 것인지 이해하기 위해, 우선 영리한 AI 플레이어와 보드 게임을 작성하는것과 관련된 것이 무엇인지 살펴봅시다.

 우선 보드 게임의 구현에 인간 플레이어의 움직임을 다룰 코드가 필요합니다. 이 부분의 코드는 게임 보드의 규칙을 알아야 하며 움직이기 전에 인간 플레이어의 움직임이 적절하다는걸 확인해야 합니다.

 저희는 또한 AI코드를 작성해야 합니다. 그리고 AI 플레이어를 선택해 움직이기 전에 게임 보드의 규칙을 모두 알아야 합니다.

 먼가 알아차리셨나요? 저희 게임 엔진의 이러한 분리된 부분 모두 게임 규칙의 이해가 필요합니다! 저희가 원하는 것은 분명히 게임 코드를 세개의 큰 조각으로 나누는 것입니다:

z 인간의 움직임을 처리
z AI 플레이어
z 규칙 엔진(The rule engine)

 하나는 플레이어의 움직임을 다루는 조각입니다. 다른 하나는 AI 플레이어를 위한 코드입니다. 그런 다음 이것들은 일종의 "rule engine"의 규칙을 이해하는 코드에게 말합니다. 어떠한 설계가 가능할까요?

 전통적인 imperative 프로그래밍 스타일에서는, 이 처럼 프로그램을 작성하는 것은 매우 어렵습니다. imperative 언어에서 완전히 분리된 요소들을 작성하는데 있어 복잡성 때문에, 대다수의 imperative 게임 엔진은 "understands the rules" 코드를 복사합니다. 보드 게임이 수많은 context를 요구하기 때문입니다 - 모든 움직임은 이것 이전에 무엇이 움직였나에 달려 있습니다. 이는 매번 AI 모듈 혹은 플레이어를-다루는 모듈은 이 규칙을 확인해야 하며 "rule code"에게 현재 세부 context를 알려야 한다는걸 의미합니다. 이 둘은 "이것은 누구누구 플레이어의 턴이며 게임보드는 이러이러한 것처럼 보인다"라는걸 rule code에게 알려야만 합니다. 이러한 정보가 없다면, rule code는 움직임이 적법하다고 알릴 수 없게됩니다.

 이러한 context를 통과시키는 것은 지루한 bookkeeping(안내서와 같은) 코드를 요구하며 에러가-유발되기쉬우며, 비효율적입니다. 이는 naive 설계로 인해 비효율적이기에, 플레이어를-다루는 code는 AI 코드가 이미 움직였는지 적당한 곳을 찾았는지에 대해 움직임의 적법성을 검사합니다

 그러나, 함수형 프로그래밍을 이용하면 저희 프로그램에 전반적으로 관여하는 이 세가지를 나눌수 있습니다. bookkeeping 코드 없이 어떤 합법적인 계산의 중복을 피하는 방법으로 이러한 일을 할 수 있습니다.

NOTE
 저희가 사용하는 기본 접근 방식 -게임을 lazy game tree와 function pipeline을 이용한 함수형 스타일로  프로그래밍하는것- 은 John Hughes의 "Why Functional Programming Matters"에 기술되어 있습니다.

 저희는 이번 장에서 아직은 lazy가 아닌 game tree를 만들 것입니다. lazy 프로그래밍과 lazy game tree가 무엇인지 이해하기 위해 18장까지 기다릴 것입니다. 또한 그때에는 이러한 디자인이 실제로 얼마나 멋진지 완전히 깨닫게 될 것입니다.
[pic]


Generating a Game Tree
 게임의 모든 규칙은 다음에 나오는 master함수에 encode됩니다.
[source]

 game-tree 함수는 특정 시작 설정을 준 moves가 가능한 tree를 만듭니다. 이 함수는 게임을 시작할때 단 한번만 호출됩니다. 그리고, 재귀적으로 마지막에 최종 승리 지점으로 내려가는 게임을 위한 moves가 가능한 tree를 구성합니다. 그리고 저희 게임의 다른 부분은 게임 규칙을 따르기 위해 이 트리를 우아하게 순회할 것입니다.

 주어진 context로부터 적법한 움직임인지 계산하기 위해, 이 함수는 인자로 4개의 데이터 조각이 필요합니다:

z 보드가 어떻게 보일것인가
z 현재 플레이어
z 게임의 일부로써 병력충원의 계산이 필요한 현재 턴에, 플레이어가 얼마나 많은 주사위를 지니고 있는가
z 적어도 한번 움직여야 턴을 넘길수 있기 때문에, 현재 움직임이 플레이어의 첫번째 움직임인가

 game-tree 함수는 트리를 생성하며, 이는 매 가지마다 현재 보드와 현재 플레이어에 관한 정보를 집어 넣습니다. 그리고나면 하위 가지는 현재 가지로부터 모든 적법한 다음 이동 장소를 붙들고 있게 됩니다:
[pic]

 플레이어에게 2가지 종류의 적법한 moves이 가능한것이 있습니다: 6각형을 공격하거나, (적어도 한번은 이미 공격했다고 가정하고)다음 플레이어로 턴을 넘기는 것. passing move는 add-passing-move 함수를 통해 적법한 움직임의 리스트에 저장됩니다. attacking-moves 함수를 통해 attacking moves은 리스트에 추가됩니다. 다음으로 넘어가서 이 함수들을 살펴봅시다.


Calculating Passing Moves
 여기 passing move를 게임 트리에 더하는 함수가 있습니다:
[source]

 이 함수의 일은 passing이 허용된다면 tally of moves에 passing move를 더하는 것입니다. 현재 moves의 리스트는 이 함수로 통과되며, 이 함수는 확장된 moves의 리스트를 반환합니다. 만약 move가 플레이어 턴에 첫번째 move라면, passing은 허가되지 않으며 단지 변환되지 않은 list를 반환합니다. 그렇지 않다면, 새로운 move를 리스트에 추가합니다.

 저희 게임 트리에서 모든 move는 두 부분으로 구성되었습니다:

z  첫번째 부분은 move의 서술부입니다. 이 move에 있어 passing만 하기에, 서술부를 nil로 설정할 것입니다.

z move의 두번째 부분은 이 움직임 후에 가능한 모든 움직임을 지닌 완전히 새로운 게임 트리입니다. game-tree 를 다시 재귀적으로 호출함으로써 이를 생성합니다. 플레이어의 턴이 끝낫기 때문에, 플레이어는 충원으로 주사위를 받게됩니다. 따라서, 새로운 game-tree를 호출과 add-new-dice 함수에게 보내진 보드를 갱신합니다.

 물론, 새로운 이의 턴이 지금 시작 되므로, 현재 플레이어를 바꿔야 합니다. 저희는 하나를 현재 플래이어 수에 더하고 전체 플레이어 수를 분모로 하는 결과모듈을 취함으로써 이를 행합니다. 이러한 고수준fancy의 방법으로 플레이어를 교체하는것은 나중 버전의 게임에서 플레이어의 수가 증가하더라도 코드가 동작하게 해줍니다.


Calculating Attacking Moves
 이것은 possible attacking moves를 game tree에 추가하는 함수입니다:
[source]

 attacking-moves 함수는 add-passing-move함수보다 조금 더 복잡합니다. 현재 게임 보드를 scanning 해야하며 현재 플레이어에게 적법하게 허용된 움직임이 어떤 것인지 밝혀내야합니다.

 주어진 6각형에 있는 플레이어가 누구인지 밝혀내는데 많은 시간이 소비되므로, 저희는 우선, 플레이어에 의해 호출되며 주어진 보드 위치에서 플레이어를 반환하는 player라는 편리한 함수를 작성할 것입니다. 저희는 주어진 6각형의 주사위 갯수를 얻기위해 유사한 함수를 작성할 것입니다.

 다음으로, 저희는 보드의 상단에서 하단으로 scan하여 현재 플레이어가 어떤 사각형을 점령했는지 찾아야합니다. 각 점령된 4각형에는, 하나 혹은 더 많은 그 지점에서의 적법한 공격 시작지가 있을 것입니다. 어떤 6각형에서 공격의 수는 다양하기 때문에, 보드를 scan 하기 위해 mapcan을 이용하였습니다. mapcan은 저희가 스캔한 각 6각형에 대해 리스트로 결과를 반한다는 것을 기억하십니요. 그런 다음 mapcan 이 리스트를 서로 concatenate합니다. 이리하여, 스캔된 6각형에서 어떠한 것은 0을 n moves에 리스트로 넣을 수 있습니다.

 모든 6각형을 얻기 위해 호출하는 mapcan에서 사용된 lambda 함수로, 우선 현재 플레이어가 이 6각형을 점령했는지를 확인하기 원합니다. 그런 다음, 공격 가능성이 있는지 확인하기 위해 모든 이웃들을 조사합니다. 또다른 mapcan으로 이러한 일을 합니다. 저희는 짧게 작성하게될 neighbors 함수를 이용하여 이 6각형에 대한 이웃을 밝혀낼 것입니다.

 6각형이 공격 목적지가 된다면 어떻게 해야 할까요? 그렇다면, 이는 이전에 소유하지 않았던 6각형이여 하며, 더욱이 (규칙에 의해) 원본 6각형은 목적지 6각형보다 더 많은 주사위를 가져야만 됩니다. 적법한 공격 move를 찾았다면, move를 기술describe합니다. 이 기술은 단순한 원래 위치와 목적지 위치에 대한 리스트입니다. 그런 다음, (passing moves와 마찬가지로) 재귀적으로 move가 일어나면 어떤 일이 벌어졌는지 기술하는 또다른 게임 트리를 생성합니다.


Finding the Neighbors
 다음으로, 주어진 6각형에 이웃하는 6각형을 계산하는 함수를 만들어 봅시다:
[source]

 보드에 있는 모든 6각형은, 아마 6개 혹은 6각형이 보드의 가장자리에 있다면 더 적은 이웃들을 지닐 것입니다. loop에서 가능한 이웃 리스트를 만든다음, 보드의 가장자리 부분이 아닌 위치 번호를 수집할 것입니다. 또한, 위치 번호는 열과 열로 싸여져 있으므로, 보드의 왼편 가장자리라면 왼편을 보지않으며 오른쪽 가장자리면 오른편을 보지 않도록 해야합니다.

 이 함수는 clean 표시가 되어있지만(이는 함수형 스타일), loop를 포함하고 있습니다. 보통, looping은 함수형 프로그래밍의 교리에 위배됩니다. 그러나, 많은 Lisper들은, 이것이 행하는게 어떤 값을 모으는 것이라면,  실제로 이것은 어떤 값들을 mutating하거나 다른 side effects를 발생하지 않기 때문에, 함수형 코드에서 loop를 사용하는 것이 합법적이라 여깁니다. 그러므로, 함수형-스타일 부분에서 이와 같은 loop의 사용을 허용할 겁니다.

 neighbors 함수를 돌려봅시다:
[source]
[pic]

 보시다시피, 이는 정확하게 6각형 2의 이웃이 6각형 0과 3이라는 것을 알려줍니다.


Attacking
 이제 board-attack 함수를 작성해봅시다:
[source]

 이는 6각형 src가 dst를 공격하면 어떤 일이 발생하는지 밝혀내는 함수입니다. 보드를 looping하고, 현재 위치와 그 지점에 있는 6각형에 있는 내용을 추적함으로써 이러한 일을 합니다. 현재 6각형이 출발지라면, 그 지점에 하나의 주사위를 놓습니다; 룰에 의해, 공격 후에 하나의 주사위가 남게됩니다. 현재 6각형이 목적지라면, 뒤에 남아있는 하나를 뺀 남아있는 주사위를 놓습니다. 다른 경우에는, hex 그 자체를 담습니다.

 board-attack 함수를 돌려봅시다:
[pic]

 보시다 시피, 6각형 1이 3을 공격하는 것은 적절하게 게임 보드를 갱신하는 board-attack을 야기하여, 따라서 예전 사각형엔 하나의 주사위가 남게되며 2개가 새로 점령한 4각형에 있게됩니다.

NOTE
 이번 장에 있는 많은 함수들은 단순함을 유지하기 위해 비효율성을 지니고 있습니다. 나중 버전에서 이러한 것들을 고칠 것입니다


Reinforcements
 보드에 충원물을 추가하기위해선,  게임 보드 전체를 scan하여 또다른 주사위를 수용할수 있는 점령된 지점을 찾아 그곳에 주사위를 추가해야 합니다. 물론 충원수는 플레이어가 마지막 턴에 쥐고 있던 적의 주사위 얼마나 많은지에 기반하여 제한됩니다. 이렇게 때문에, 남아있는 충원 주사위의 양을 기록해야 합니다.


 가장 명백한 방법은 remaining-dice 변수가 가지게될 남아있는 주사위를 추적하는 것이며, 주사위가 놓여질 때마다 이를 감소시키는 것입니다. 그러나, 줄어드는(변형되는) 주사위를 가진다는 것은 함수형 스타일을 따르지 않는 것입니다.

 그러므로, 대신에 저희는 돌아가고있는 주사위의 숫자를 유지하는 지역 재귀 함수를 이용한 add-new-dice 함수를 작성할 것입니다.

 이것이 add-new-dice 함수입니다:
[source]

 add-new-dice가 하는 첫번째 일은 지역 함수 f를 정의하는 것입니다. 이 함수는 보드의 6각형에 대한 list-eater 가 될 것이며, 충원을 포함하는 새로운 리스트를 내뱉습니다. 효율성의 이유로 실제로 보드가 배열에 저장될 것이기에, f를 호출하기 전에 coerce 함수로 배열을 리스트로 변환합니다.

 함수 f내부에서, 저희는 3가지 상황을 고려해야만 합니다:

z 보드의 끝에 있다. 이번 경우, 보드 충원이 완료된 것이며 따라서 nil을 반환합니다.
z 충원으로 더해지기 위해 추가될 spare-dice를 벗어났다. 이러한 경우, 보드의 나머지는 이전 것과 동일해 질것이며, 따라서 새로운 보드로 리스트의 나머지를 반환합니다.
z 앞의 경우가 아닌 경우. 다른 모든 경우에는, 현재 6각형을 분석해야하며 어떤 충원이
이것에 추가될 것인지 결정해야합니다. 현재 플레이어가 그 6각형을 점령했는지, 그 4각형에서 있는 최대 주사위 갯수보다 적게 가졌는지를 확인합니다. 이러한 경우 6각형에 새로운 주사위를 더하며 그리고 f를 보드의 나머지에 대해 재귀적으로 호출합니다. 그렇지 않으면, 현재 6각형을 바꾸지 않고 놔루고 보드의 나머지에 대해 f를 재귀적으로 호출하여 처리합니다.

 보드에 충원물을 추가해 봅시다:
[source]

 보시다시피, add-new-dice는 적절하게 2개의 충원 주사위를 플레이어 A(플레이어 0)에게 놓았습니다.


Trying Out Our New game-tree Function
 저희는 이제 Dice of Doom의 단순화된 버전의 포괄적인 게임 트리를 생성하는데 필요한 모든 코드를 작성하였습니다. 그러나 주의하십시요! 대다수의 보드 게임의 게임 트리는 굉장히 큽니다. 2x2보드라도, 저게임은 수백개 움직임이 가능합니다. 플레이가 거의 끝난 게임 보드에만 game-tree 함수를 호출하기 원할것이며, 그렇지 않으면게임을 진행함에 있어 모든 가능한 방법을 보여주는 어마어마한 양의 트리가 CLISP REPL에 출력한 것을 보고만 있어야 할 것입니다.

 여기 테스트 해보기에 안전한 보드 위치가 있습니다.
[pic]
[output]

 게임 트리는 우선 현재 플레이어 숫자, 보드의 배치 그 context를 위한 접법한 moves를 나열합니다. 플레이어 A의 턴이 시작 됬을때 초기 보드 위치에선, 오직 하나의 가능한 move가 있습니다: 플레이어는 플레이어 B의 주사위를 함락시키기 위해 6각형 2에서 3으로 갈 수 있습니다. 그런 다음 플레이어는 턴을 넘길 수 있습니다. 플레이어 B는 이제 움직일 수 있는 곳이 없게 되었습니다. 플레이어의 게임 트리가 움직임이 가능한 moves listed를 가지지 못했기 때문에, 플레이어 A가 이김으로 게임이 끝납니다.


Playing Dice of Doom Against Another Human
 이제 저희는 방대한 game-tree 함수에서 Dice of Doom의 세계를 완전히 이해했으므로,
인간대 인간 버전의 게임을 만들기는 쉽습니다. 우선 우리가 해야할 일은 플레이어가 그의 move를 선택하는 것처럼 게임트리를 추적해 나가는 몇몇 함수를 만드는 것입니다


The Main Loop
 여기 2인용 Dice of Doom의 게임 트리를 탐색하는 함수가 있습니다:
[source]

 play-vs-human 함수는 저희 게임의 main loop입니다. 이는 보드의 시작 지점을 기술하는 트리를 받아들입니다.

 우선 이는 현재 게임의 상태에 대한 다른 유용한 정보와 함께 화면에 보드를 그리는 print-info 함수를 호출합니다. 그 다음, 다음 나오는 moves가 존재하는지 확인해야 합니다. 이 다음에 나오는 moves는 게임트리의 caddr 위치에서 시작하는 리스트 되었습니다.

 다음 나오는 moves가 가능하면, 새로운 moves을 집도록 현재 플레이어와 상호작용하는 handle-human함수를 호출합니다. 그런 다음 이 handle-human 함수는 플레이어의 선택을 반영하는 게임 트리의 하위 가지를 리턴합니다. 그런 다음 게임을 진행시키기 위해 재귀적으로 이 하위 가지를 play-vs-human으로 통과 시킵니다

 다음에 나오는 moves중 이용가능한게 없다면, 게임은 공식적으로 끝이 나게 됩니다. 그러면 적절하게 승자를 공표하는 announce-winner 함수를 호출합니다.


Giving Information About the State of the Game
 여기 게임 트리에서 현재 노드의 상태를 기술하는 print-info 함수가 있습니다:
[source]

 이 함수는 REPL에서 두가지 중요한 정보 조각을 보여줍니다. 하나는, 이는 현재 플레이어가 누구인지 보여줍니다. 다음엔 draw-board 함수로 예쁜 버전의 게임 보드 를 출력합니다.


Handling Input from Human Players
 다음은 사람이 다음 move를 선택하도록 하는 함수입니다. 이는 매우 유용하면서 동시에 플레이어가 선택할 수 있는 숫자로된 유효한 현재 moves의 목록을 보여줍니다.
[source]

  move가 가능한 리스트를 보여주기 위해 이용가능한 모든 moves를 탐색하는 loop를 이용하고, 각각에 대한 서술을 출력합니다. 이 loop는 플레이어가 읽을수 있도록 화면에 무언가를 출력하기에 함수형이 아닙니다. loop안에서 1부터 셈을 하는 변수 n을 이용하여 각 move앞에 counting 숫자를 출력합니다.

 각 move은 이와 관련된 하나의 행동action 값를 지닙니다. action이 nil이 아니라면, 그 action은 공격이며 그 값은 공격의 출발지와 목적지를 기술합니다. 이와 같은 공격 행동을 format 명령어를 이용하여 출력합니다.

 비어있는 행동 값을 이용하여 passing move를 표현합니다. 이번엔, 이 움직임을 기술하기 위해 단지 "end turn"을 출력하였습니다.

 이동 가능한 move가 출력된 후에, 플레이어의 선택을 읽어오기위해 read를 이용합니다. 그런 다음 nth 함수로 게임 트리를 선택하여 handle-human 함수로부터 이를 반환합니다


Determining the Winner
 승자를 발표하는 작업은 깔끔하게 clean/functional와 dirty/imperative한 부분으로 나눌 수 있습니다.

 clean 부분은 승자를 계산하는 작업을 담당합니다. 저희는 나중에 더 많은 이를 허용해야 하기 때문에 2인용 이상을 다룰 수 있도록 계산되길 원합니다. 또한, 함수는 무승부가 될 가능성을 인지해야 합니다.

 이러한 일을 하기 위해, 게임이 끝날시 6각형을 많이 보유하고 있는 하나 혹은 더 많은 플레이어의 리스트를 반환하는 winners 함수를 작성할 것입니다. 만일 무승부라면, 모든 플레이어에 대한 점령된 공간의 총합에 대해 단순히 처음 지점을 공유하는 모든 플레이어를 반환할 것입니다. 이러한 설계로, 함수는 어떠한 플레이어의 수라도 동작하며 우아하게 무승부가 되는 경우를 처리할 것입니다. winners 함수는 다름 처럼 생겼습니다:
[source]

 저희는 4단계로 주어진 ending board position에 대한 승자를 계산합니다: 

z 첫번째로, 보드의 각 6각형에 대해 누가 점령했는지에 대한 tally를 구성합니다. loop 구조를 통해, ending board 배열을 직접 탐색할수 있으며 각 6각형의 점령자를 모을 수 있습니다.
z 두번째로, 각 플레이어가 지닌 4각형의 수의 전체를 이 tally를 이용하여 세야 합니다. totals 변수는 player->spaces 쌍의 alist가 될 것입니다. remove-duplicates로 tally에 적어도 하나의 entry를 가진 모든 플레이어를 검색함으로써 이러한 alist를 생성합니다. 저희는 이것에 map을 할 수 있으며 각 점령자의 count를 생성할 수 있습니다.
z 세번째로, 단일 플레이어에 대해 점령된 6각형의 최대 갯수를 밝혀내야 합니다. 리스트에 cdr로 mapping하여 alist로부터 counts를 때어내어 이러한 일을 합니다. 그런다음 가장 많은 수의 공간을 점령한 단일 플레이어를 찾기 위해 이 리스트에 max를 적용시킵니다.
z 마지막으로, "베스트" 플레이어 목록을 만들어야 합니다. remove-if 함수를 이용하여 totals에서 베스트가 아닌 것들을 모두 때어내어 이러한 일을 합니다. 그런 다음 bests 리스트에 car를 mapping하여 베스트 플레이어의 플레이어번호를 빼냅니다.

 다음으로가서, dirty announce-winner 함수를 작성해 봅시다:
[source]

 이 함수는 보다 간단합니다. 우선, 이전 함수를 호출하여 승자를 구합니다. 그런 다음, 승자가 1명 이상인지 확인합니다(무승부). 무승부라면, 특별한 메시지를 출력합니다. 그렇지 않으면, 한명의 승자를 발표합니다.


Trying Out the Human vs. Human Version of Dice of Doom
 이제 저희는 완벽하게 플레이가 가능한 dice of doom게임을 지녔습니다. 여기 게임의 시작부터 끝까지 예가 있습니다:
[output]


Creating an Intelligent Computer Opponent
 Dice of Doom의 게임 트리 코드를 설계할때 다루었다싶이, 분리된 게임 트리 생성자를 갖는 것은 AI 플레이어를 게임 엔진에 추가하는것을 쉽게 만듭니다. 사실, 저희는 이제 단지 23 추가 코드라인으로 완벽한 게임이 가능한 컴퓨터 플레이어를 추가할 것입니다!

 그러면 어떻게 AI 플레이어가 움직임을 결정할까요? 저희는 다음 전략을 이용할 것입니다:

1. 움직임이 가능한 곳을 찾는다.
2. 각 움직임으로부터 보드 position resulting에 point rating을 준다.
3. 최대 point rating의 move를 집는다.

 이는 단순한 계획처럼 보이지만, 이 알고리즘에는 어려운 단계가 하나 있습니다.: 주어진 보드 위치의 최선의 point rating을 계산해 내는 것

 만일 move가 승리를 즉시 이끈다면, 승리의 move에 point rating을 주는 것은 쉬울 것입니다 - 승리의 move는 명백히 매우 높은 point rating을 보장합니다. 그러나 게임속 대다수의 moves는 즉시 승리를 이끌지 못합니다. 이러한 경우, moves의 set의 결과가 좋은 point rating을 받을 자격이 있는지 결정하기 위해 적 플레이어가 어떤 반응을 보일지 밝혀내야 합니다.

 그러나, 적 플레이어가 행동하기로 결정한 것을 저희가 어떻게 알 수 있을까요? 만일 저희가 주의하지 않는다면, 주어진 보드 위치에 의미 있는 point 값을 계산하기 위해 심각한 교착상태에 빠질 것입니다. "그는 이렇게 할것이고 나는 이렇게 하고 그는 또 이렇게하고 ..." 어떻게 적의 행동을 저희가 골머리 싸맬 필요없이 밝혀낼 수 있을까요?
[pic]


The Minimax Algorithm
 2인용 보드 게임에 대해 적이 무얼 할 것인지 구상하는 단순한 방법이 존재합니다. "무엇이 나의 적에게 좋고 나에겐 나쁜지"라는 truism를 받아들일 것 입니다. 이는 적의 move 구상하는데에 다음 접근법을 이용할 수 있다는 것을 의미합니다

1. move가 가능한 곳을 살핀다.
2. 각 move로부터 point rating을 board position resulting에 준다
3. 최소 Point rating을 지닌 move를 꺼낸다.

 적이 무얼 할 것인지 추측하는 이 알고리즘은, 3번째 단계에서 최대 rating 대신 최소로 move를 꺼낸점을 제외하면 primary 플레이어에 사용된 것과 동일합니다. minimax 알고리즘이라 불리는 이러한 접근법의 이점은 적의 moves를 산출해 낼때 약간의 조정으로 3번째 단계를 수정하였지만 primary AI 플레이어에 사용된것과 동일한 point ratings를 이용한다는 점입니다.

 이는 중요합니다: 게임에서 적에게 한것처럼 자신에게 대한 개별적인 rating의 계산을 피할 수 있다면, 게임 트리에서 좋은 moves를 찾는 것은 극적으로 쉽고 빨라 진다는 것입니다.

NOTE
 기본적인 minimax 알고리즘은 오직 2인용 게임에만 동작합니다. 3 혹은 더 많은 플레이어가 게임에 참여할 때에는, "어떤것이 내 적에 좋고 나에게 나쁜지"를 더이상 참이라고 확실히 말할 수 없습니다.

 추가 truism은 중요하기 때문입니다: "나의 적의 적은 내 친구이다"

 비록 저희에게는 직접적으로 영향을 미치지 않지만, 가끔씩 저희의 적이 공공의 적에게 해를 끼치는 moves를 행함으로써 동맹처럼 행동하는 것을 의미합니다. 20장에서 이러한 issue에 대해 다룰 것입니다.


Turning Minimax into Actual Code
 이제 저희는 다음처럼 minimax idea를 실천할 준비가 되었습니다:
[source]

 rate-position 함수는 주어진 게임 트리 가지에 numeric point rating을 생성합니다. 이를위해, 우선 저희는 주어진 위치에서 moves가 가능한지 밝혀야 합니다.(만일 그렇다면, 현재 move는 게임에 있어 ending move가 아닙니다)

 만일 moves가 가능하다면, 현재 지점의 rate가 얼마인지 결정하기 위해 모든 subsequent moves를 살펴봐야합니다. 각 움직임에 대한 point rating을 반환하는 get-ratings를 호출함으로써 이러한 일을 행합니다. 그런 다음 minimax를 따라서, rated 되는 move가 AI 플레이어를 위한 것인지 이의 적을 위한 것인지에 달린 다음에 나오는 moves의  최선의 (최대) 이나 최악의 (최소) rating을 집을 것입니다.

 그렇지 않고 다음에 나오는 moves가 없다면, 현재 보드 위치에서 누가 승자인지 확인해야 합니니다. 플레이어가 그 위치의 승자가 아니라면, 그 위치에게 최소 rating인 0을 줄 수 있습니다. 그렇지않다면, rating을 판별하기 위해 승자의 수에 역수를 취할 것입니다. 이리하여, 무승부를 위한 의미있는 rating을 제공합니다.
 만일 단독 승자이면 이 공식에서 사용된 rating은  최대 값인 1이 될 것입니다. 2인용에서 무승부라면, 이 rating은 0.5가 될것입니다.

 여기 get-ratings 함수가 나와 있습니다:
[source]

 이 함수는 단순히 주어진 트리의 가지에 대한 각 다음 나올 move에 대해 rate-position을 maps합니다


Creating a Game Loop with an AI Player
 이전에서, 저희는 게임에서 움직임을 결정하기 위해 인간과 상호작용하는 handle-human 함수를 작성하였습니다. 여기에 하나의 유사한, 움직임을 고르기위해 AI 플레이어와 상호작용하는 handle-computer 함수가 있습니다:
[source]

 이 handle-computer 함수는 매우 단순합니다. 우선 move가 가능한 각각의 rating을 얻습니다. 그런 다음 최대의 rate가 된 move를 집습니다

 마지막으로, 컴퓨터에 대항하기 위해 playing하는 main loop를 다루는 함수를 만들어 봅시다. 이는 예전의 play-vs-human함수와 유사합니다:
[source]

 play-vs-human 함수처럼 play-vs-computer는 우선 현재 게임의 상태 정보를 출력합니다. 그런 다음 moves가 가능하지 않다면, announce-winner 함수를 호출합니다

 다음으로, 현재 플레이어가 누군지 확인해야 합니다. 관례상 저희는 플레이어 A(player 0)이란 인간을 소유할 것입니다. 만일 플레이어의 숫자가 0이라면, 인간이 그의 움직임을 결정하도록 예전 handle-human 함수를 호출 합니다. 그렇지 않으면 플레이어를 AI 플레이어로 다루며 move를 결정하기 위해 handle-computer 함수를 이용합니다.

 저희는 이제 Dice of Doom을 위한 완벽한 함수형 AI 엔진을 작성하였습니다.


Playing Our First Human vs. Computer Game
 다음 나오는 것은 컴퓨터 AI에 맞서는 예제 게임 입니다 컴퓨터는 최적화된optimal 게임을 하며 승리합니다.
[output]


Making Dice of Doom Faster
 적어도 초급 프로그래머의 손에선, 함수형 프로그래밍 스타일은 느린 코드를 야기할 수 있습니다. 저희는 Dice of Doom의 코어를 개발하기 위해 함수형 스타일을 사용하였습니다. 이러한 까닥에서, 저희 게임의 처음 버전은 극도로 비 효율적입니다. 저희는 게임을 플레이 가능한 2x2 보드로 제한 하였습니다. 그러나 이젠 저희는, 저희 게임 엔진을 최적화하여, 저희 보드 크기를 3x3으로 늘릴 수 있습니다.

 이러한 일을 하기 위해 보드 크기를 조정하는 인자수를 늘려봅시다. 여러분이 극도록 참을성 있거나 컴퓨터가 초기 게임트리를 생성하고 움직임을 결정하는데 드는 시간에 신경쓰지 않는 사람이 아니라면, 이 장의 나머지를 거치면서
모든 최적화를 구현하기 전까지 이러한 새로운 크기의 게임을 플레이 하기 원하지 않을 것입니다.
[source]

 3x3으로 보드 크기를 늘린 것이 있습니다.

 이 장의 나머지에서 함수형 코드를 최적화하는 몇몇 중요한 기술들을 다룰 것입니다. 이러한 기술들은 Dice of Doom을 포함하여 함수형 스타일로 작성된 모든 프로그램에 적용할 수 있습니다. 나머지 장에서, 저희는 다른 최적화를 추가할 것입니다. 결국에는 함수형 스타일로 작성된 우아한 코드를 유지하면서 더 넓은 보드에서 AI 플레이어에 대항해 플레이 할 수 있게 될 것입니다.


Closures
 Dice of Doom의 최적화를 시작하기 이전에, 중요한 프로그래밍 개념을 다뤄야할 필요가 있습니다: closures. Closure는 lambda 함수가 만들어질때마다 잡혀있는 외부 세계로부터온 추가 데이터 bits 입니다. 어떻게 그리고 왜 closure에 변수가 잡혀있는지 이해하기 위해, 다음 예제를 곰곰히 살펴봅시다:
[output]

 이 예제에서, 저희는 새로운 이름없는 함수를 생성하였고, 이 함수와 *foo*를 동일하게 설정하였습니다. 다음으로 이 함수를 funcall 명령어를 이용하여 호출하였습니다. 예상처럼, 이 함수에 의해 반환된 값은 5입니다. lambda 함수가 행하는 일은 이 숫자를 반환 하는 것입니다.

 다음으로, 더욱 흥미 있는 예제를 살펴봅시다:
[output]

 5로 설정된 지역 변수 c를 선언했다는 점을 제외하면, 이 버전의 foo는 이전 버전의 *foo*와 매우 같습니다. 게다가, lambda 의 몸체에서 x를 반환하였습니다. 자, 여러분은 이 새로운 버전의 *foo*를 호출할때 어떤 일이 벌어졌다고 생각하십니까?

 이것이 어려운 질문인 이유는 x가 "지역"변수로써 선되었기 때문입니다. 그러면 let 표현식의 본체의 평가하는 지점을 이미 지나쳤기 때문에 *foo*를 한번 호출하면 x가 더이상 존재하지 않아야 합니다.

 한번 해보고 무슨 일이 생기는지 살펴봅시다:
[output]

 이럴수가(Holy cow)! 왜그런지 모르겠지만 저희가 생성된 lambda 표현식은 이것이 생성되었을 시점에 x가 무엇인지 기억하였습니다. 이전에 지역 변수라고 생각했던 변수 x는 어찌된 영문인지 이것이 생성되었을 때의 과거의 영역에서 살아가는게 가능합니다.

 2장에서 let 표현식을 처음 다루었을 때,  숙련된 Lisper는 let 표현식으로 생성된 lexical 변수를 호출하는 것을 선호한다고 배웠습니다. 이제 저희는 왜 그런지 알 수 있습니다: 이러한 방식으로 생성된 변수는 closure안에 잡혀있으면 lambda 표현식에 있는 변수를 이용하여 local이 될 필요가 없습니다.

 closures가 어떻게 동작하는지 이해하기 위해, Lisp는 garbage collection을 사용한 다는 것을 기억합시다. 사실, 이러한 기능을 갖는 것은 first language입니다 Garbage collection은 (C 프로그래밍에서 행했던 것처럼) "자유분방한" 변수를 가질 수 없다는 것을 의미합니다. Lisp 컴파일러/인터프리터는 언제 변수가 더이상 사용되지 않는지 아는데 있어 충분히 영리하며 자동으로 그들을 파괴시킵니다.

 Garbage collection은 let 표현식을 빠져나온 후에 임의의 시간에 발생됩니다. 주기적으로, Lisp는 어떠한 곳에서 더이상 참조되지 않는 메모리의 항목을 찾으므로 안전하게 파괴시킬 수 있습니다. Lisp가 let에서 정의된 변수가 더 이상 사용되지 않다는 것을 알아차린다면, 그 변수를 파괴시킬 것입니다.

 그러나, 만일 let 표현식에 lambda 표현식을을 생성한다면, 그 변수는 lambda 표현식에 참조되기에, 그 변수는 살아 있는게 가능합니다. 이러한 경우, garbage collector는 그 변수를 남겨둘 것입니다. 근본적으로 여러분은 사용하지 않고  garbage collect되지 않는한 적어도 lambda 표현식만큼 영구적인 변수를 생성하였습니다.

 closures를 이용하여 수많은 멋진 일들을 해낼 수 있습니다. 이는 함수의 이용간에 작은 정보조각을 캐쉬하는데 종종 사용됩니다. 예를들어, 여기 현재 출력된 라인 넘버가 무엇인지 기억하는 함수가 있습니다:
[output]

 라인 넘버의 track을 추적하기 위해, 우선 line-number라는 lexical 변수를 만들었습니다. 다음으로, let의 안에서 defun을 이용하여 my-print 함수를 선언하였습니다. 이 명령어는 scenes아레 lambda 함수를 만드므로, clsure를 생성하도록 만듭니다.

  my-print 함수 본체에서 라인 넘버를 출력하고, incf를 이용하여 이를 mutate합니다.(incf는 변수에 1을 더합니다) line-number 변수가 closure에 의해 잡혀있기 때문에, 이는 라인 넘버를 세도록 해주는 my-print의 호출 간에 "살아 있을" 수 있습니다


Memoization
 저희가 수행할 첫번째 최적화는 memoization이라 불립니다. 이 기법은 closures를 이용합니다. memoization은 함수형 스타일로 작성된 함수에만 동작합니다. 아시다시피, 함수형 스타일의 함수의 행동은 오직 이 안으로 들어온 인자에 기반합니다. 또한 함수형 스타일의 유일한 행동은 값을 계산하여 caller에게 반환하는 것입니다.

 이는 분명한obvious 최적화를 시사합니다: 인자와 이 함수의 각 호출의 결과를 기억한다면 어떨까요? 그렇다면, 만일 함수가 동일한 인자로 또다시 호출된다면, 결과를 재계산하지 않아도 됩니다. 대신, 단순히 미리 계산된 결과를 반환 할 수 있습니다.

 Dice of Doom의 몇몇 함수들은 memoization으로부터 이익을 얻을 수 있습니다.


Memoizing the neighbors Function
 보드에 있는 어떤 6각형이 주어진 장소로부터 공격받을 수 있는지 알게 해주는 neighbors 함수부터 시작해봅시다:
[output]

 neighbors가 저희에게 말해주는 것은, (새로운 3x3 보드 크기에 기반하여) 만일 저희가 0에서 보드에 있는 다른 6각형 공격하기 원한다면 오직 6각형 3, 1 혹은 4로만 갈 수 있다는 것입니다.

 기억하시다시피, neighbors 함수는 가장자리에 있는 6각형은 그들이 6각형을 공격함에 있어 한계가 있기에, 모든 보드의 가장자리라부터 최악의 경우를 검사하는게 필요로 합니다. 그러나, 보드의 형태가 게임 중간에 바뀌지 않기 때문에, 주어진 보드 위치로부터 이 숫자는 절대 변하지 않을 것입니다. 이러한 것이 neighbors를 memoization의 완벽한 후보자로 만들어줍니다! 여기 이러한 일을 수행하는 코드가 있습니다:
[source]

 어떤 일이 일어나는지 이해하기 위해 이 코드를 파해쳐 봅시다. 우선, old-neighbors란 지역 변수에 이전 버전의 neighbors 함수를 저장합니다. symbol-function 명령어는 간단하게 symbol로써 함수를 받습니다. 여기서 symbol-function 을 이용하는 것은, 곧 하게될 것처럼 심지어 동일한 이름의 새로운 함수를 정의 하더라도, neighbors의 예전 값에 접근을 유지하도록 합니다.

 다음으로, 예전 인자들과 함수가 예전에 보였던 결과들을 붙들고 있을 지역 변수 previous를 정의합니다. 이는 인자들이 해쉬 키이며 결과과 값인 해쉬 테이블로써 나타낼 수 도 있습니다. 이제 저희는 예전 버전의 neighbors를 덮어버릴 새로운 neighbors 함수를 작성하였습니다. 이 새로운 정의는 예전 버전의 함수에 memoization을 추가할 것입니다. 그런다음 해쉬 테이블의 인자 위치를 살펴볼 것이며 가능하다면 이를 반환할 것입니다. 그렇지 않으면, 예전 함수의 정의를 호출하여 (이는 왜 old-neighbors lexical 변수를 만들어야 하는지에 대한 이유입니다) 새로운 인자/결과 쌍을 해쉬 테이블에 추가합니다. setf는 set이 되는 값을 반환하기 때문에, 이 명령어 또한 neighbors의 호출자로 반환될 새로이 계산된 결과를 야기합니다

NOTE
 원래 버전의 함수를 재정의 하지 않은체로, neighbors 함수의 memoized 버전의 선언을 한번이상 하지 않게 주의하십시요. 그렇지 않으면, neighbors 함수는 memoization이 이미 수행됬는지 확인하지 않기 때문에, 다수의 보기 흉한 memoization의 레이어로 덮어져 버릴 것입니다.


Memoizing the Game Tree
 프로그램에서 memoization에 대한 가장 큰 이익을 얻는 겄은 game-tree 함수일 것입니다. 보드 게임이 어떻게 동작하는지에 대해 생각한다면, 이는 이치에 맞습니다. 매우 자주, 여러분은 다른 것과 미세하게 다른 동일한 움직임을 수행함으로써 보드 게임에서 동일한 보드 위치를 얻을 수 있을 것입니다.

 기존 game-tree 함수의 버전에서 각 move sequence는, 반복적이며 비효율적인 방식으로 만드는 완전히 다른 게임트리branch를 유도하였습니다. game-tree 코드의 memoized 버전에선, 이 함수는 자기 자신에게 "이봐, 나는 이전에 보드 위치를 봤었다고!"라고 말할 수 있어 게임 트리의 branchs를 공유할 수 있습니다. 여기 이러한 일을 하는 memoized 버전의 game-tree가 있습니다:
[source]

 보시다시피, memoization은 사실상 전에 neighbors 함수에서 사용했던 것과 동일합니다. 하나의 차이점이 있다면 해쉬 테이블을 설정할때, 키에 대해 테스트를 하기 위해 (기본으로된) eql대신 equalp를 이용했다는 것입니다.

 이는 (game-tree의 인자인) 키가 배열의 형태로 게임 보드를 포함하고 있기 때문입니다. test 함수를 equalp로 바꾸면, Lisp는 보드에 있는 모든 6각형에 대해 확인할 것이며 이전 계산을 이용하기 전에 이것이 일치하는지 확인할 것입니다.


Memoizing the rate-position Function
 memoization으로부터 굉장한 이익을 얻을 또 다른 함수는 rate-position 함수 입니다. 여기 memoized된 게 있습니다:
[source]

 rate-position을 거치는 트리 인자로 인해, 정확히 동작하기 위해 이 함수의 memoization을 위해 조금 특별한 무언가를 해야 합니다. 게임 트리가 커질 가능성이 있기에, equal로(혹은 비슷하게 큰 리스트에서 느린 comparison함수) 게임 트리 오브젝트를 비교해서는 안됩니다. 대신, eql로 이를 비교하길 원합니다. 이러한 연유로, rate-position의 두 인자의 memoization을 각각 다루어야 합니다. 중첩된 해쉬 테이블를 가지게 함으로써 이를 해낼 것입니다.

 우선, 기본 eql 테스트로 바깥에 해쉬 테이블을 만듭니다. 그런 다음 내부 해쉬 테이블을 받기 위해, 바깥에 있는 해쉬테이블에 있는 변수중 하나(player)를 살펴볼 tab 변수를 정의합니다. 외부 해쉬 테이블에서 tab을 찾지 못한다면, 새로운 외부 태이블에 동일한 키를 갖고 저장될 빈 내부 해쉬 테이블을 하나 만듭니다. 함수의 나머지 부분은 게임 트리 인자를 키로 이용하는 내부 해쉬 테이블을 이용한다는 점을 제외하면 이전 예제와 유사합니다.

 memoization은 Dice of Doom의 보드를 더욱 재밋고 커지게 하는데 있어 한발작 더 다가서게 합니다.

NOTE 
 여러분은 함수형 스타일로 작성된 코드 성능의 최적화를 위해 memoization을 사용하였습니다. 그러나 memoization코드 그 자체로는 함수형 스타일로 작성된 것이 아닙니다. target 함수에 대한 이전 호출 테이블을 업데이트하고 유지하도록 하기에 이는 그렇게 될 수 없습니다.


Tail Call Optimization
 함수형 프로그램을 최적화 하기 위해 사용하게될 다음 기법은 tail call optimization이라 합니다. 이 개념을 이해하기 위해, 리스트의 길이를 계산하는 간단한 함수를 살펴봅시다:
[output]

 my-length 함수는 이 시점에선 이해하기가 매우 쉽습니다. 우선 이는 리스트가 비어있는지 확인합니다. 만일 그렇지 않다면, 리스트의 꼬리부분에 대해 재귀적으로 그 자신을 호출하며 최종 결과에 1+ 함수를 이용하여 하나를 더합니다. 리스트가 비어있다면, 함수는 단순히 0만 반환합니다. 

 이 함수는 실제로 매우 비효율적이라는게 밝혀졌습니다. 매우 큰 리스트에 대해 이를 이용함으로써 이를 쉽게 할 수 있습니다:
[output]

 CLISP에서 이 함수를 호출하면 프로그램은 crash될 것입니다! (다른 Common Lisp 컴파일러/인터프리터는 아마 컴파일러 작성자가 Lisp 코드에 있어 이러한 위험을 예상하여 어떤 특별한 트릭을 사용하여 잘 처리할 수 도 있습니다)

 이러한 일은  1+ 함수로 인해 발생됩니다. 이는 Lisp에게 "우선, 짧은 리스트의 길이를 밝혀내고, 그런 다음 결과에 1+을 호출해라" 라고 말합니다.

 문제는 매번 my-length를 재귀적으로 호출할때, Lisp는 리스트의 나머지의 길이를 구한 다음 나중에 그 결과에 1을 더해야 한다는 것을 기억한다는 것입니다. 리스트가 100,000개의 항목을 지녔다면, 하나의 덧셈을 수행하기 전에 99,999 번이나 이를 기억해야 합니다! CLISP 인터프리터는 이러한 덧셈을 위해 남아있는 것들을 결국엔 오버플로우나 프로그램이 crash되도록 프로그램 스택에 놓습니다.

 그러면 어떻게 이러한 문제점을 피할 수 있을까요? my-length 함수를 다음처럼 다시 작성하면 됩니다:
[output]

 여기선, list-eater처럼 행동하는 지역 함수 f를 정의하였습니다. 이 함수는 종종 accumulator라 불리는, 여기선 짧게 acc로, 추가 인자를 취합니다. 이 acc 인자는 이전에 만났던 리스트에 있는 얼마나 많은 항목이 있는지에 대한 running count를 유지합니다. 함수 f를 처음 호출할때, acc를 0으로 설정합니다.

 이 accumulator를 이용가능케 만든다는 것은, f 가 자기 자신을 재귀적으로 더이상 호출할때 결과에 1을 더하지 않아도 된다는 것을 의미합니다(it now longer ==> it no longer). 대신에 이는 단지 accumulator에 1을 더합니다. 리스트의 끝에 도달하면(list가 nil이면), acc는 리스트에 있는 항목의 수와 동일해질것이며 이를 반환 할 수 있습니다.

 여기서 중요한 것은 함수 f가 행한 가장 마지막에 리스트에 많은 항목이 있있때 자기 자신을 재귀적로 호출한 일입니다. (표현식이 참으로 평가되지 않으면 그 부분이 호출되지 않기 때문에, statement에 있는 추가 라인은 세지 않을 것입니다.) 가장 마지막에 행했던 것처럼 Lisp에서 함수가 재귀적으로 호출하는 것을
tail call이라 부릅니다. tail call을 볼수 있는 똑똑한 Lisp 컴파일러는 자기 자신에게 이렇게 말할 수 있습니다 "이봐, f 를 다시 호출하는것 말고는 아무것도 할 필요가 없어서, 스텍에 현재 프로그램 context를 집어넣을 필요없이 f만 쓸 꺼야"

 이는 실제로 BASIC의 GOTO나 C++의 longjmp가 수행하는 것과 비슷합니다. 이러한 경우엔, 매우 빠르고 스택을 망치지thrash 않고 단지 어디서 왔는지 "잊어버립니다" 그러나 Lisp에서 tail call의 경우 이는 매우perfectly 안전합니다. GOTO나 longmp를 사용했던 사람들은 결코 그것이 안전하지 않다는 것을 알고 있습니다!

 이전 예제 코드에 존재하는 lst를 위한 두가지 다른 정의가 있습니다. 하나는 my-length 함수의 인자이며, 다른 하나는 함수 f의 인자입니다. 이 프로그램 실행처럼 두 lst 인자의 값들은 벗어나게될deviate것이며, f는 재귀적으로 호출될 것입니다. 그러나, 함수 f에선 자신의 인자 리스트를 갖는 이 버전은 우선권을 취할 것입니다.우선권을 통해 어떤 변수를 감추는 과정을 variable shadowing이라 부릅니다.


NOTE
 my-length 함수에 가려진 변수를 이용하였고 이는 f 함수 내부의 코드를 작성할시에 우연치않게 "잘못된 리스트"의 사용이 불가능해 지도록 합니다. 다른 값을 지니며 비슷하게 명명된 변수를 갖는 것은 혼란을 야기할 수 있으므로, 다른 프로그래머들은 이 기법을 싫어합니다 여러분은 어떤 인자들이 가장 여러분을 확신시켜주는지, variable shadowing을 사용해야 하는지를 결정해야 합니다


Support for Tail Calls in Common Lisp
 불행하게도, 여러분은  Common Lisp의 컴파일러/인터프리터가 tail call optimization을 수행한다고 100% 보장할 순 없습니다. ANSI Common Lisp 표준에선 필수적인게 아닙니다. (Scheme은 tail call optimization의 필요성을 고수하기에, Scheme 방언에 있어 이러한 현상은 매우 다르게 나타납니다.)

 그러나, 저희 예제 함수를 포함하여 몇몇 함수들에 tail call optimization가 동작하게 만들기 위해 비록 CLSIP 몇몇 매혹적인것을 필요로 하지만, 대다수의 Common Lisp 컴파일러들은 이러한 기능을 지원합니다. 이러한 이유는 몇몇 난해한esoteric 경우 tail calls는 실제로 성능적 문재를 야기시킬수 있기 때문입니다. 또한, 프로그램을 디버그할때 전체 콜 스택을 살펴 볼수 있는게 낫습니다; tail call optimization은 태생적으로 가능한 스택에 정보를 최소화 하기에 이를 못합니다.

 여기 CLISP가 tail call optimize my-length 함수를 갖게하는 추가 단계가 있습니다.
[source]

 이 함수의 호출은 CLISP에게 tail code optimization 단계를 포함하는 전체full 컴파일러를 통하여 my-length 함수가 돌아간다고 알려줍니다. 이제 엄청큰 리스트에 대해 my-length를 돌릴 수 있습니다.
[output]


Tail Call Optimization in Dice of Doom
 저희 게임에서 tail call optimization으로부터 분명히 이익을 얻을 함수는
add-new-dice 함수입니다. 여기 완벽히 최적화된 버전이 있습니다:
[source]

 전에 accumulator를 지닌 f라 불리는 함수에서 list-eating을 수행하였습니다. 그러나 이번에는 acc 변수는 여분 주사위와 새롭게 업데이트된 6각형들의 리스트를 담을 것입니다. 이제 새로운 6각형을 acc 변수로 cons 하는 두 장소에서 tail call position에 있는 f를 호출 할 수 있습니다.

 보드에 있는 6각형 전체 리스트를 지니면 acc를 반환할 수 있습니다. 그러나, 리스트로 했던것처럼 어떠한 것을stuff acc로 cons하였기 때문에, 실제로 acc는 역방향이 될 것입니다. 그러므로, 매우 끝에서 뒤집는 추가 호출 작업을 해야합니다

 지금까지now 저희는 함수형 스타일로 작성된 컴퓨터 프로그램의 최적화를 위한 몇몇 기본적인 기법을 탐험하였습니다.


A Sample Game on the 3-by-3 Board
 이제 노력의 결실을 맛봅시다. 다음 나오는 것은 3x3보드에 있는 AI 플레이어에 대항하는 게임입니다. 보시다시피, 동등하게 시작된 보드에선 컴퓨터는 이제 실질적으로 이길 수 없습니다.
[output]


What You’ve Learned
 이번 장에서, 함수형 프로그래밍 지식을 이용하여 AI및 보드 게임을 개발하였습니다. 이러한 과정을 거치며 다음에 나온 것들을 배웠습니다:
 
z 함수형 프로그래밍 기법은 나머지 코드에서 분리된 "rule engine"의 게임 프로그램을 작성케 한다. 함수 파이프 라인과 게임 프로세스로 게임 코드의 다른 부분으로부터 독립적으로 탐색하는 게임 트리를 만듬으로써 이를 행할 수 있습니다.
z minimax 알고리즘을 이용하여 2인용 게임을 위한 AI 플레이어를 만들 수 있다.
이 알고리즘은 "어떤게 적에 좋고, 어떤게 내게 해가되는지"에 대한 truism에 기반하였습니다. 이는 2인용 플레이어 보드 게임에 있어 효율적으로 위치position를 평가rate하도록 해줍니다.
z (저희가 이제까지 local 변수라 부른) Lexical 변수는 그 form이 만일 lambda 표현식에 의해 참조되도록 만들어 졌다면 과거(past)에서 살 수 있습니다. 이러한 방식으로 변수를 잡는capture것을 closure를 생성하는creating것이라 합니다.
z 함수형 프로그램은 함수에 의해 계산된 이전 결과를 캐쉬하는 memoization을 이용하여 최적화될 수 있다.
z 또한, call stack이 남용되지 않는다는걸 보장하는 tail call 최적화를 이용하여 함수형 프로그램을 향상 시킬 수 있다. list-eater 함수의 tail call 위치에서 보이는 함수를 조정함으로써 이러한 일을 합니다.