8장. 이것은 여러분 아버지(시대)의 WUMPUS가 아닙니다.


 이전 장에서, 저희는 간단한 게임에서 수학적 그래프를 다루었습니다. 그러나, 어린시절 괴짜였던 제가 이 그래프를 보고 생각난 것은 고전 게임 Hunt the Wumpus입니다. 제가 9살이였을때, TI-99/4A 앞에 앉아서 이 게임을 하는것보다 행복했던것은 없었다고 생각합니다.


[PIC]
 여기 실제 타이틀 화면이 있습니다: Hunt the Wumpus, 여러분은 신비한 몬스터, 전설의 Wumpus를 찾아 동굴을 뒤지는 사냥꾼입니다. 이 과정에서, 박쥐와 타르 연못을 넘어야 했습니다. 아, 그리운 시절이였습니다!
 그러나 불행히도, 좋은 시절은 지나갔습니다. 저희는 지금 새로운 천년에 있고, 이 못난 그래픽에 감명받을 사람은 아무도 없습니다. 그리고 스토리라인도 현대 기준에서 매우 진부합니다. 저는 Hunt the Wumpus가 개선이 필요한 심각한 상태에 있다는것에 여러분 모두 동의한다고 생각합니다. 어려운 문제이지만, 잘 해쳐나갈 수 있을거라 생각합니다.
 자, 여러분에게 소개하겠습니다...
[PIC]


Grand Theft Wumpus
 새로운 버전의 Hunt the Wumpus에서 여러분은 Lisp 외계인입니다. 여러분과 Wumpus는 주류판매소(술가게)를 습격해서 돈을 흠쳐 달아났습니다. 그러나, 도망치는 동안, Wumpus는 여러분을 배신하고 차와 돈을 갖고 튀었습니다. 그가 떠나기 전에, 간신히 그의 신장을 두어번 맞췄습니다.
[PIC]

 이제 여러분은 상당히 곤란한 상황에 놓여 있습니다. 차나 어떠한 돈도 가지고 있지 않고있으며 배신자를 찾을 방법도 없습니다. 그러나 선택의 여지가 없습니다. Wumpus를 잡으러 가기로 마음을 가다듬었습니다. 여러분은 그가 상처때문에 멀리 갈 수 없다는 것을 알고 있습니다. 그는 회복하기 위해 며칠간 숨어지낼것이며, 이는 Congestion City(혼잡 도시)어딘가에 그가 있을 것이라는 것입니다. 문제는 여러분과 같은 외지사람에게 유달히 이 도시의 길들이 말도안되게 난해하고 주변에 사람을 찾을 수 없다는 점입니다. 어떻게 이 난해한 미로에서 Wumpus를 찾을 수 있을까요?
[PIC]

 다행히도, Lisp 외계인된 여러분은 항상 충성스러운 휴대용 컴퓨터를 지니고 다녔습니다. Lisp와 그래프 유틸리티를 이용하여, Congestion City내 도로와 교차로와 같은 복잡한 데이터를 분석할 만발에 준비가 되어있습니다. 분명, 여러분은 이 난해한 도로 체계를 정복할 도구를 가졌습니다.
[PIC]

 여러분의 동료였던 Wumpus와 지금까지 범죄를 저질러 왔기 때문에, 그의 습관(MO, modus operandi)을 매우 잘 알고있습니다. 그는 항상 조심스럽게 새로운 장소를 몰색합니다. 그리고 그는 부상당했기에, 숨어있는 장소로에서 하나 혹은 두 블럭떨어진 곳에는 숨길 수 없는 단서가 있습니다: 그의 혈흔입니다.
 문제는 그가 여전히 그의 AK-47을 신뢰하고 있는데 반해, 여러분은 단 한발의 권총을 지녔다는 것입니다. 만일 여러분이 그를 찾아 나선다면, 그를 찾아낼 절대적인 확신이 필요합니다. 여러분은 그의 은신처로 돌격하여 그를 재빠르게 쏴야하며, 단 한번의 기회밖에 가지지 못했습니다.
[PIC]

 유감스럽게도, 여러분과 Wumpus는 이 도시에서 유일한 악당들이 아닙니다. Congestion City에서 가장 두려운 악의 무리는 Gruesome Glowworm Gang(섬뜩한 반딧불이 유충;;)입니다. 이 녀석들은 무자비한 유괴범들의 집단입니다. 만일 여러분이 그들을 만나기라도 한다면, 그들은 여러분을 납치하여, 마구 패고, 뺏고, 눈을 가린후, 차 밖으로 걷어차 도시 어딘가에 내버릴 것입니다.
 다행히도, (이름처럼)그들의 발광하는 thoraxes((곤충의) 흉부[가슴])를 살펴봐서 피할 수 있습니다. 만일 여러분이 깜빡이는 불꽃을 보게 된다면, 이들이 여러분의 위치에서 하나의 거리만큼 떨어져 있다는 것을 알 수 있습니다. 또한, 여러분은 이 갱이 정확히 세 팀으로으로 나누어 이 도시의 세 구역을 관리한다는 것을 알고 있습니다.
[pic]

 마지막으로, 경찰들을 여전히 주의해야 합니다. 여러분과 Wumpus를 잡기 위해 그들이 아마도 도시에 길목차단기를 설치할 것입니다. Congestion City에 위치한 어떠한 지역도 방문 할 수 있지만 이동경로를 주의해야할 필요가 있습니다. (다른 말로 하자면, 길을 잘못들면 경찰에 체포될 것입니다) 불행히도, 여러분은 얼마나 많은 길목차단기가 설치됬는지 모릅니다.
 보시다시피, Wumpus를 찾아 돈과 차를 돌려받는 것은 매우 힘이 들 것입니다. 만일 여러분 스스로 Wumpus를 충분히 잡을 수 있는 Lisp 외계인이라고 생각한다면, 이 게임을 작성하여 그를 때려눕혀봅시다!


Congestion City의 간선 정의하기
 Congestion City지도는 *congestion-city-nodes*변수에 저장된 각 노드마다 데이터를 지니고 있는 무방향그래프가 될 것입니다. 각 노드가 될만한 데이터에는 Wunpus, Glowworm 팀, 다양한 위험 신호들이 있습니다.
 *congestion-city-edges*에 저장된 간선들은 노드들을 연결할 것이며, 이 간선들과 연결된 데이터는 경찰의 길목차단기의 존재를 경고할 것입니다. 이들과 다른 전역변수들을 defprameter를 사용하여 프로그램 상단에 선언하였습니다.
[source]

 우선 load명령어로 그래프유틸리티를 불러와서 (이전 장에서 만든)graph-util.lisp에 있는 모든 코드들을 평가하면, 그래프유틸리티 함수들을 사용할 수 있습니다. Congestion City는 (*node-num*으로 정의된 노드)30개의 장소들, (*edge-num*으로 정의된 간선)45개의 도로, (*worm-num*으로 정의된)3개의 벌레팀이 있다는 것을 알려드립니다. 각 도로에는 (*cop-odds*로 정의된)1/15 확률로 길목차단기기 있습니다.


무작위 간선들을 생성하기
 다음으로, 모든 노드들을 연결시킬 무작위 간선 리스트를 만듭니다.
[SOURCE]

 우선, 무작위 노드 식별자를 반환하는 random-node함수를 선언합니다. random 함수는 무작위로 넣은 수보다 하나 작은 자연수를 반환합니다. 사용자 인터페이스에서 노드식별자를 보여주기 위해서 (*node-num*변수가 30으로 설정되었기 때문에) 0부터 29까지 대신에 1+함수를 사용하여 1부터 30까지 숫자를 매깁니다.
 make-edge-list함수는 실제 무작위 간선리스트를 생성합니다. *edge-num*번만큼 순환하기 위해 loop명령어를 사용하여 필요한 간선들을 모읍니다. 다음 단락에서 loop명령어에 대해 자세히 다룰 것입니다. 도시 그래프는 방향을 갖지 않기에, edge-pair 함수는 무작위로 선택된 노드간에 양뱡향성 간선를 생성하는 도움함수로 작용합니다. 추가로 명심해야 할 것으로는 무방향그래프의 무방향간선은 방향그래프의 두 반대 방향간선 각각에 대응된다는 것입니다. (나중에 이번장에서 간선들을 alist에 넣을때, 이 단계는 리스트가 적절한 형식을 지닌다는 것을 보장할 것입니다.)
[PIC]

 CLISP REPL에서 make-edge-list함수를 테스트 해봅시다.
[REPL]

 간선을 구성하는 노드의 숫자쌍을 볼 수 있습니다. 이 간선 쌍을 담고 있는 리스트는 Congestion City 도로 체계의 뼈대를 구성할 것입니다.


loop 명령어로 looping을
 make-edge-list함수는 다양한 데이터형식을 순환시킬때 사용할 수 있는 강력한 loop명령어를 채용하였습니다. 10장에서 loop에 대해 더욱 자세히 살펴볼 것이지만, 저희 게임에서 loop를 조금 사용할 것이기에, 간단한 예제로 이것이 어떻게 동작하는지 살펴봅시다.
 loop를 가지고 할 수 있는것 중 하나는 숫자리스트를 생성하는 것입니다. 예를들어, 다음 명령어는 1이 10개 있는 리스트를 생성합니다.
[REPL]

 loop명령어로 얼마나 많이 반복할지를 지정하고 매 loop마다 (이번 경우에서는 1) 모을 객체를 지정합니다.
 때때로, 저희는 looping중에 looping count를 증가시키고자 할 것입니다. 다음과 같은 문법으로 이를 수행할 수 있습니다:
[REPL]

 이번 예제에서, n이 1부터 10까지 loop를 돌라고 합니다. 각 n을 모은 후, 이를 리스트로 반환합니다.
 실제로, Lisp 코드를 loop의 collect부분에 넣을 수 있습니다. 다음 예제에서 저희는 수집할때 마다 100씩 더하였습니다.
[REPL]


섬 방지하기
 이제 저희는 무작위 간선을 생성할 수 있습니다. 물론, 단순히 무작위 노드들을 간선으로 연결 한다면, 모두 무작위이기 때문에 Congestion City의 모든것이 연결되었다는 보증이 없습니다. 예를들어 도시의 일부분이 주 도로 체계에 어떠한 연결도 없는 섬을 형성하고 있다고 합시다.
[PIC]

 이를 방지하기위해, 간선리스트를 취하여 연결되지 않은 노드를 찾을 것이며, 다음 코드를 이용하여 이 섬을 도시망의 나머지에 연결할 것입니다:
[SOURCE]

 우선, 간선리스트에서 주어진 노드로 시작하는 모든 간선들을 찾는 유틸리티 함수 direct-edges를 선언하였습니다. (remove-if-not을 사용하여) car위치에 현재 노드를 갖지 않은 간선들을 제거하여, 새로운 리스트를 생성함으로써 이를 행할 수 있습니다.
 섬을 찾기 위해, get-connected 함수를 작성하였습니다. 이 함수는 간선리스트와 출발지 노드를 받아, 출발지와 연결된 모든 노드 리스트를 생성합니다.
 연결된 노드를 찾는 일반적인 방식으로는, visited 리스트에서 시작하여 출발지 노드와 연결된 노드에 대한 탐색을 수행하는 것입니다. 새롭게 찾은 노드들은 push명령어로 방문했던 리스트에 추가됩니다. 또한, mapc를 사용하여 이 찾은 노드의 자식들로 이동합니다.
 게다가, 만약 이미 방문했던 노드와 맏닥들인다면 무시할 수 있습니다. 검색이 완료되면, visited 리스트는 모두 연결된 노드로 구성될 것입니다. 
 이제 저희는 연결된 노드를 찾는 함수를 가졌고, 이것을 이용하여 저희 그래프에서 모든 섬을 찾는 함수를 만들 수 있습니다. find-islands함수는 우선 find-island라 불리는 지역 함수를 정의합니다. 이 함수는 connected 변수를 이용하여 노드리스트에서 첫번째 노드가 어떤 노드와 연결되었는지 확인합니다. 그 다음 set-difference 함수를 이용하여 전체 노드리스트에서 이 노드들을 뺍니다 (set-differnce는 두 리스트를 취해 첫번째 리스트에 있고 두번째에는 없는 모든 항목을 반환합니다).
 남아있는 노드들은 연결되지 않았다고 여겨지게 됩니다. 연결되지 않은 노드가 존재한다면, 추가로 섬을 찾기위해 find-islands함수를 재귀적으로 다시 호출합니다.
 모든 섬을 찾았다면, 그들을 서로 연결해줄 방법이 필요합니다. 이것이 connect-with-bridges함수의 일입니다. 이것은 모든 섬이 서로 연결되어 추가된 간선리스트를 반환합니다. 이를 수행하기 위해선, 섬 리스트를 취한 다음 리스트에 cdr이 존재 하는지 확인합니다. 만약에 있다면, 다리로 연결할 수 있는 적어도 두개 이상의 섬이 존재한다는 것입니다. 추가 다리가 필요한 경우, edge-pair함수를 이용하여 다리를 생성하고, 섬리스트의 꼬리 부분에서 재귀적으로 자기 자신을 호출합니다.
 마지막으로, connect-all-islands함수를 이용하여 섬을 없에는 함수들을 모두를 서로 묶습니다. find-islands를 사용하여 모든 땅덩이를 찾은다음, connect-with-bridges를 호출하여 적절한 다리를 건설합니다. 그 다음, 최종적으로 모두 연결된 땅덩어리를 생성하기 위해 이러한 다리들을 초기의 간선리스트에 더합니다.


Congestion City를 위한 마지막 간선 만들기
 Congestion City의 간선들을 완성시키기 위해선, 간선들을 간선리스트에서 alist로 변환시켜야 합니다. 또한 몇몇 간선에 무작위로 경찰의 길목차단기를 추가해야만 합니다. 이 작업을 수행하기 위해, make-city-edges, edges-to-alist, 그리고 add-cops함수를 만들어야 합니다:
[SOURCE]

 이것은 Grand Theft Wumpus에서 가장 길고 복잡한 함수입니다. 자세히 살펴 봅시다.


make-city-edges 함수
 우선, make-city-edge함수는 loop를 이용하여 노드 리스트를 생성합니다 (이것은 단순히 1부터 *node-num*까지의 숫자 리스트입니다.) 다음으로, make-edge-list와 connect-edge-list함수를 호출함으로써 무작위(그렇지만 완전히 연결된) 간선리스트를 생성합니다. 이 결과는 edge-list 변수에 저장됩니다. 그 다음 경찰을 포함한 무작위 간선리스트를 만듭니다. 이전에 정의한 변수들을 참조할 수 있는 let*명령어로 이 변수들을 정의합니다.
 다음 예제는 let과 let*으로 정의된 변수의 차이점을 보여줍니다:
[REPL]

 보시다시피, let은 다른곳에 정의된 변수를 참조 할 수 없습니다(변수 b는 a의 값을 참조 할 수 없습니다). 반면, let*으로 변수를 정의하면, 이런 참조를 허용합니다. 저희 목적에서, let*을 사용하는 것은 edge-list를 참조를 포함하는 cops의 정의를 가능케 합니다.
 간선리스트를 만들고 경찰이 어디에 있는지 결정하였다면, 간선리스트를 alist로 변환하고 경찰을 추가해야 합니다. 이 간선들은 edges-to-alist함수로 alist로 변환되고, 경찰들은 add-cops함수로 추가될 것입니다.


edges-to-alist 함수
 edge-to-alist함수는 간선 리스트를 간선 alist로 변환시킵니다. 예를들어, 다음과 같은 오직 세개의 장소와 연결된 두개의 간선을 지닌 도시가 있다고 가정해 봅시다:
[pic]

 이를 간선리스트를 이용하여 '((1 . 2) (2 . 1) (2 . 3) (3 . 2))로 기술할 수 있습니다. 간선들이 무방향이며 양방향으로도 사용할 수 있기에, 각 edge들이 반복해서 나타나는 것을 주목하시기 바랍니다. 만일 이와 같은 도시를 alist로 기술한다면, 어떻게 보여질까요?
 alist는 키(이번 예제에서, 도시의 세개의 노드중 하나)를 살펴봐서 그 키(이번 경우에, 이와 연결된 도로리스트)와 연관된 정보를 찾는 리스트라는 것을 기억하시기바랍니다. 이 작은 도시의 alist는 '((1 (2)) (2 (1) (3)) (3 (2)))가 될 것입니다.
 이러한 alist를 만들기 위해, edges-to-list함수는 우선 간선리스트에서 찾은 노드들을 mapcar합니다. 노드 리스트를 만들기 위해, 리스트에서 중복된 항목을 없에주는 remove-duplicates함수를 사용합니다. 기본적으로, remove-duplicates는 동일한지 확인하기 위해 eql함수를 사용하지만, :test keyword 매개변수를 이용하여 다른 테스트 함수 또한 사용할 수 있습니다. make-city-edges 함수에서 cons 쌍이 동일한지 확인해야 하기에, :test를 #'equal로 설정하였습니다.
 외부 mapcar안에서, 모든 direct-edges를 노드에 map하기위해 또 다른 mapcar를 사용하였습니다. 이 중첩된 mapcar함수들이 뭉처 edge-to-alist가 도시의 간선들을 alist로 변환하게 만듭니다.


add-cops 함수
 make-city-edges함수를 작성할때, 경찰의 존재를 알리기 위해 무작위로 몇몇 간선들을 표시해야합니다. 이제 저희는 경찰 간선리스트를 이용하여 alist에 cops을 포함하는 간선들을 표시할 수 있습니다. 이것이 add-cops함수의 일입니다.
 이 일을 수행하기 위해, 각 노드에 대응하는 간선들을 map하기 위해 중첩된 mapcar 명령어를 사용합니다. 그 다음 intersection함수를 사용해서, 주어진 간선에 경찰이 있는지를 확인합니다.(intersection함수는 두 리스트간에 어떤 항목 공유되었는지 알려줍니다)
 add-cops함수가 하는 일을 정확히 이해하기 위해, 세개의 장소와 두 거리를 지닌 도시를 다시금 상상해 보는 것이 도움이 될 것입니다. 이번 예제에서, 거리 중 하나에 경찰이 있습니다:
[PIC]

 add-cops에 의해 생성된 이 도시의 alist는 이와 같을 것입니다:
[SOURCE]

 이는 사실 중첩된 alist입니다. 바깥 alist는 첫번째 노드에 기반하여 구성되었고, 안쪽 alist는 두번째 노드에 기반하여 구성되었습니다.
 (cdr (assoc node1 edges))를 호출함으로써, 이러한 형식으로 된 간선에서 주어진 노드에 연결된 모든 간선들을 쉽게 찾을수 있습니다. 주어진 간선이 cops를 포함하는지를 보기 위해, 두 노드 사이의 간선에 연결된 실제 데이터를 얻는 두 단계 아래로 내려가는 (cdr (assoc node2 (cdr (assoc node1 edges))))를 호출 할 수 있습니다. (이 중첩된 alist 형식을 사용하는 것의 추가적인 이점으로는 저희의 그래프라이브러리와 완벽히 호환한다는 것입니다.)


Congestion City의 노드 생성하기
 이제 저희는 도시 노드 alist를 만들 것입니다. 이 노드들은 Wumpus나 Glowworms 혹은 혈흔, 불빛, 싸이렌과 같은 다양한 단서들을 포함합니다.
 게임에서의 대부분의 단서들은 다른 노드와 가까움에 기반하며, 따라서 도시 그래프에서 두 노드가 얼마만큼의 노드가 떨어졌는지를 알려주는 몇몇 함수들 작성해야 합니다. neighbors함수는 간선alist를 이용하여 노드의 이웃을 살펴봅니다. 만일  그 리스트에 두번째 노드가 있다면, 하나만큼 떨어져 있다는 것을 알게될 것입니다.
[SOURCE]

 우선, 이 함수는 neighbors로 간선 alist에 있는 첫번째 노드 (a)를 살펴봅니다. 그 후 다른 노드 (b)가 이 노드들을 경유하는지 확인하기 위해 member를 사용합니다.
 두 노드 만큼 떨어진 곳에서 Wumpus의 혈흔 또한 나타날 수 있습니다. 이와 같은 두 노드를 확인하기 위한 두번째 함수를 작성 할 수 있습니다.
[source]

 하나 혹은 둘만큼 떨어져 있을 수 있기에, 우선 목표 노드로부터 하나만큼 떨어져 있는지 확인합니다. 다음으로, 하나만큼 떨어진 모든 노드들을 추출합니다 (within-one 함수에서 행했던 것과 유사합니다). 마지막으로, 이 새로운 노드들 중에 어떤 것이 하나만큼 떨어졌는지 둘만큼 떨어져 있는지를 확인합니다.
 이제 저희는 유틸리티 함수들을 갖게되었으며, 마지막으로 노드 alist(본질적으로, 도시의 최종 지도)를 만드는 함수를 작성해 봅시다. 여기 나와있습니다:
[SOURCE]

 make-city-nodes함수는 우선 무작위 Wumpus와 Glowworms의 노드를 집어서, 노드 번호에 따라 동작하도록 loop를 이용합니다. 노드에 따라 동작하므로, 이는 다양한 출발지가 서로 append된, 도시의 각 노드를 기술하는 alist를 생성합니다. append를 사용함으로써 이 노드들을 기술하는 코드의 각 부분은, 자식 리스트에 다양한 항목을 생성함으로, 서술을 위한 다양한 항목을 고를 수 있습니다.
 리스트앞 부분에, 노드 이름을 넣습니다. 현재 노드에 Wumpus가 있다면, Wumpus라는 단어를 추가합니다. 두 노드안에  Wumpus가 있으면, blood를 보여줍니다. 노드에 Glowworm 갱이 있다면, 이를 보게될 것이며, Glowworm 갱이 노드 하나만큼 떨어져 있다면, lights를 보여줍니다. 마지막으로, 노드의 간선에 cops가 있다면, sirens이 들리도록 합니다.
 sirens 단서를 확인하기 위해, 간단히 간선에 (cdr (assoc n edges))을 잡아서 이 노드가 cdr에 값을 가졌는지 봅니다. cops 심볼은 간선의 cdr에 추가될 것입니다. 게임에서 간선에 관한 오직 하나의 데이터 지점만을 지니기에, cdr의 존재를 살펴보는 것은 cops의 존재를 확인하기에 적합합니다. 예를들어, cops가 있는 예전의 alist 예제를 이용해본다면:
[REPL]

 리스트에 있는 간선이 cop을 포함한다면, cdr은  nil이 아닌 값이 될 것이라는 것을 확인 할 수 있을 것입니다. cops가 없는 간선은 cdr에 nil이 오게 될 것입니다.
[pic]



Grand Theft Wumpus 새로운 게임의 초기화작업
 그래프를 생성하는 것이 끝났으므로, 새로운 Grand Theft Wumpus게임을 초기화하는 간단한 함수를 작성할 수 있습니다:
[source]

 여기 새로운 두 함수가 있습니다. find-empty-node함수는 플레이어가 게임 시작시에 나쁜놈들 위에 놓여지지 않는다는 것을 보장합니다. 여기 이 함수의 코드가 있습니다:
[SOURCE]

 find-empty-node함수는 매우 간단합니다. 우선, 플레이어의 시작 지점을 결정할 무작위 노드를 집습니다. 그후, 이것이 완전히 비어있는 노드인지를 확인합니다. 그 노드에 무언가가 있다면, 자신을 다시한번 호출하고 다른 무작위 지점에서 시도해봅니다.

WARNING  
 게임을 나쁜 놈들로 가득차게 수정하였다면, 비어 있는 노드가 어디에도 없는 상황에 처할 수 있습니다. 이러한 상황을 감지하는 어떤 검사도 넣지 않았기에, 그러한 경우에는 이 함수는 영원히 찾게되고 REPL은 잠길것입니다.

 새로운 게임 명령어중 또 다른 새로운 함수는 다음에 작성할 draw-city입니다.


도시 지도 그리기
 마침내 저희는 도시의 지도를 그릴 준비가 되었습니다. 저희는 그래프 데이터위한 표준 형식을 사용하였으며, 따라서 이 함수를 작성하는 것은 식은죽 먹기입니다.
[SOURCE]

 이전 장에서 그래프라이브러리의 일부로써 ugraph-png함수 만들었습니다. 이제 REPL에서 (new-game)을 호출하고, city.dot.png 그림을 웹 브라우저에서 열어보시기 바랍니다:
[PIC]

NOTE 
 저희 코드로 생성된 모든 도시 지도들은 고유하기에, 여러준의 지도는 이 그림에 나온 것과는 완전히 다르게 보일것입니다.
 
 마침내, 저희는 도시 계획 결과에 놀라게 될 것입니다.


부분적인 지식만으로 도시를 그리기
 물론, 사냥을 시작하기 전에 누군가가 있는 곳을 이미 알고 있다면 사냥하는 것은 정말 지루할 것입니다. 이 문제를 해결하기 위해, 오직 전에 방문했던 노드만을 보여주는 도시 지도를 원합니다. 이를 위해, 처음에는 플레이어의 위치를 설정하는 전역리스트 *visited-nodes*를 이용하였습니다. *visited-nodes*변수의 사용은, 저희가 도시의 알고 있는 일부분만을 포함하는 작은 그래프를 계산 할 수 있도록 해줍니다.


알려진 노드
 우선, 저희는 알려진 노드 alist를 만들어야 합니다.
[SOURCE]

 known-city-nodes 아랫부분에서, 저희가 위치한 곳에 기반하여 "볼" 수 있는 node가 어떤 것인지 밝혀내야 합니다. 방문했던 모든 노드들을 확인하고자 하며, 또한 방문했던 노드중 하나로부터 모든 노드들을 찾아갈 수 있기를 원합니다. (mapcan 함수를 짥게 다룰 것입니다.) 이전에 within-one함수에서 다루었던것과 유사한 코드를 이용하여 "하나만큼 떨어진것이" 어느것인지 를 계산합니다.
 다음으로, 노드 연관 리스트 전체에 걸쳐 각각 처리하는 mapcar를 합니다. 현재 노드에 플레이어가 있다면, 별표로 표시할 것입니다. 만약 아직 방문하지 않은 노드라면, 물음표로 표시할 것입니다.


알려진 간선
 이제, 경찰의 사이렌을 표시하는 alist를 생성할 필요가 있습니다:
[SOURCE]

 이 함수는 known-city-nodes함수와 유사합니다. 주목할만한 코드라인은 간선 리스트로부터 cdr을 노출시키는 부분이며, 간선의 끝이며 경찰이 있는 노드를 방문한다면 cops는 지도 노드에 나타나게될 것입니다.


mapcan 함수
 known-city-nodes에서 사용한 mapcan함수는 mapcar의 변종입니다. 그러나, mapcar와는 달리, mapcan은 mapping 함수에 의해 생성된 값들이 모두 서로 덧붙일수 있는 리스트라 가정합니다. 이는 리스트에 있는 항목과 여러분이 생성하기 원하는 결과가 일-대-일 대응이 아닐때 유용합니다.
 예를들어, 햄버거 가게로 달려가서 세가지 종류의 버거를 판매한다고 가정해봅시다: 싱글, 더블, 더블치즈. 햄버거 리스트를 패티와 치즈 슬라이스 리스트로 변환하기 위해 다음과 같은 함수를 작성 할 수 있습니다.
[REPL]


도시의 알려진 부분만 그리기
 알려진 노드와 간선에 대한 정보를 생성할 수 있는 함수를 가졌기에, 다음과 같이 이 정보를 그림으로 바꾸어주는 함수를 작성 할 수 있습니다.
[SOURCE]

 게임이 시작할때 알려진 도시를 그리기 위해 new-game함수를 재정의 해봅시다!
[SOURCE]

 이 함수는 오직 도시의 알려진 부분만으로 구성된 그림을 생성한다는 점을 빼면 이전 버전 new-game과 거의 정확하게 일치합니다.
 이제 여러분이 REPL에서 new-game함수를 호출한다면 브라우저에서 볼 수 있는 known-city.dot.png라 이름붙은 새로운 그림을 얻을 것입니다. 이것은 이와 비슷하게 보여집니다.
[PIC]

 이제 저희는 Congestion City의 지도를 돌아다닐 준비가 되었습니다.


도시 주변을 둘러보기
 도시의 노드 사이를 탐험할 두 함수가 필요합니다: 평범하게 걸어(walk)가는 함수와 Wumpus를 찾았다고 생각했을때 마지막 총알로 그 장소를 급습(charge)하는 함수. 이 두 함수가 매우 유사하기에, 공통 handle-directon로 작업의 대부분의 대변하도록 할 것입니다.
[SOURCE]

 이 두 함수의 유일한 차이점은 이동의 종류에 달려있는 handle-direction에 넣을 nil이나 t로 설정되는 표기입니다.
 handle-direction함수의 주요한 일은 도시의 간선들을 확인해봄으로써 이동이 합법적인지 확인하는것 입니다:
[SOURCE]

 우선, 이 함수는 플레이어가 현재 장소에서 이동할 수 있는 합법적인 방향을 찾습니다. 플레이어가 이동하기 원하는 위치를 이용하여 가능한 방향 리스트에 있는지 살펴봅니다. (플레이어의 현재 위치의 간선를 공유하는 노드번호)방향이 적법하다고 결정되면, 이 새로운 장소로 이동하는 동안, 다음에 만들 handle-new-place함수를 사용하여 놀랄만한 어떠한 것이 기다리고 있는지를 밝혀내야 합니다. 그렇지 않다면, 에러 메시지를 보여줍니다.
 이제 플레이어가 새로운 장소로 이동했을때 호출되어지는 handle-new-place함수를 만들어 봅시다:
[SOURCE]

 우선, 저희는 노드 alist로부터 이동하려는 노드를 받아야합니다. 다음, 노드가 Glowworm 갱을 포함하는지 밝혀내야 합니다. 그들은 단 한번만 공격하기 때문에, 이미 방문했던 노드라면 갱을 무시합니다.
 다음으로, (리스트에 새로운 지점을 추가하는)handle-new-place함수는 *visited-nodes*와 *player-pos*를 갱신합니다. 이제 새로운 장소를 알게 되었음으로 draw-known-city를 다시 호출합니다.
 다음으로 간선에 경찰이 있는지 Wumpus가 지점에 있는지를 확인합니다. 만일 플레이어가 Wumpus와 마주친다면, handle-new-place함수는 저희가 공격할 지점을 알아야 합니다. 만일 저희가 Wumpus를 공격한다면, 게임에서 이길것입니다. 그렇지 않으면, Wumpus는 저희를 죽일 것이며 게임은 끝납니다.
 반면, 만일 Wumpus가 있지 않은 장소를 공격한다면, 한발의 총알을 낭비하게 될것이며 게임에서 또한 패배하게 됩니다. 마지막으로, 이전에 Glowworm갱을 만나지 않은 장소라면, handle-new-place 재귀적으로 호출하여, 새로운 장소로 넘어가게 될것입니다.
 이제 저희의 게임을 완성하였습니다!


Wumpus를 잡아보자!
 게임을 플레이하기 위해, 저희가 만든 탐험 명령어 (walk and charge)를 REPL에 입력하고, 브라우저로 전환 후 다음번 이동을 계획하기 위해 known-city.dot.png를 갱신합니다.
 예로, 여기 샘플 게임의 일부분이 있습니다:
[PIC]

 어떠한 단서도 없으므로, 이 노드들이 방문하기에 안전하다는 것을 알 수 있습니다. (walk 20)이라 해 봅시다:
[PIC]

 우 오! 여기에 피가 있습니다. 이것이 의미하는 것은 Wumpus가 두 노드 떨어진 곳에 있다는 것입니다! 단 하나의 노드만이 있기에 (walk 11)로 이동하는것은 여전히 안전합니다:
[PIC]

 오 안돼! 이 거리중 하나에 경찰의 길목차단기가 있습니다. (walk 20) (walk 19)로 되돌아가면, (walk 7)을 할 수 있습니다.
[pic]

 이런! 이제 Wumpus와 Glowworms가 가까이 있습니다. 모험을 해봅시다 (walk 10):
[PIC]

 흠, 이 길의 아레에 경찰들이 있으므로, 이것은 유용하지 않습니다. 그러나, 노드 10은 오직 하나의 탐험하지 않은 거리를 가지고 있기 때문에, 1과 10사이에 경찰이 있다고 확실하게 말할 수 있습니다.
 Grand Theft Wumpus을 마스터하기 위해선 생각을 신중히 해야한다는 것을 알 수 있습니다. new-game함수를 이용해서 항상 새로운 맵에 새로운 게임을 시작할 수 있다는 것을 기억하시기 바랍니다. Wumpus를 따라잡았으면, charge함수를 사용하여 그를 공격하시기 바랍니다.
 기본 버전의 게임을 마스터하셨다면, 더 어려운 게임을 위해 노드, 간선, 경찰, Glowworms의 수를 늘려봅시다.


저희가 배운것
 이번 장에서, 저희는 더욱 정교한 게임을 만들기 위해 그래프유틸리티를 이용하였습니다. 이러한 과정을 거치며, 다음과 같은 것들을 배웠습니다:

z loop함수는 다양한 데이터형식의 순환을 허용한다. 이것은 10장에서 더욱 자세히 다룰것입니다.
z set-difference함수는 특정 list에서 어떤 항목이 다른 list에 존재하지 않는지 알려준다.
z intersection함수는 list들이 공유하는 항목들을 알려준다.
z remove-duplicates함수는 list에서 중복되는 항목을 지운다.