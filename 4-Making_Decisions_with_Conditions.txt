Section II: Lisp Is Symmetry 
2막-Lisp는 대칭이다.


4장.조건으로 결정내리기


 이전 장에서, 여러분은 기본적인 Lisp명령어 뿐만 아니라 몇몇 Lisp의 철학에 대해서 배웠습니다. 이번 장에서는, 조건을 다루는 명령어에 대해 자세히 살펴볼 것입니다. 우아한 이 명령어는 색다른 철학과 실용적인 이점을 지닌 Lisp의 설계을 보여줍니다.


nil과 ()의 대칭
 Lisp명령어와 데이터 구조의 일을 살펴볼때 유독 한가지가 눈에 들어옵니다: 모든 가능한 방법들이 대칭(Symmetry)으로 가득차 있습니다. 이 대칭은 다른 언어들이 가지지 못한 우아함을 여러분의 Lisp코드에 줄 수 있으며, Lisp의 간단한 문법은 이러한 대칭을 가능케 만들어 주는 중요한 요인입니다.


비어있는 것은 false와 같다
 Lisp철학은 정보의 저장과 조작을 위해 list의 사용을 강력하게 강조하기에, Common Lisp의 설계가 이와 같은 list를 자르고 가르는 것을 쉽게 만드는 행위를 장려하는 것은 놀랄 만한 일이 아닙니다. Common Lisp를 만듬에 있어 list에 관한 가장 심오한 설계 결정으로는, 조건문에서 평가할때 빈 list를 자동적으로 false 값으로 다루도록하는 것입니다 :
[REPL]

 이 예제는 if 문에 비어있는 list ()를 넣으면 false 값으로 평가되며, 항목을 담고 있는 list는 true로 평가됩니다.
 쉽게 빈 list를 쉽게 찾을 수 있게 때문에, 재귀를 사용함으로써 list를 를 처리할 수 있습니다. 이 기법은, list의 앞쪽 item을 취하고 list가 빈 상태가 될때까지 나머지 list를 같은 함수로 보냅니다. (이것은 비어있는 list를 찾기 매우 쉽기에 괜찮은 방법이며, 따라서 List의 많은 함수들이 list-eaters가 되게됩니다.)
 list의 길이를 구하는 일반적인 list-eating함수를 살펴봅시다.
[REPL]

 이 함수는 전통적인 Lisp형식으로 쓰여졌습니다. 이것은 자기자신을 재귀적으로 호출하여 list의 앞부분을 잘라 먹습니다. 이런 방법으로 자신을 호출하는 것은 오직 Lisp만이 허용하는 것은 아니지만, 이는 주로 강력히 권장되어 집니다. Lisp에서의 list는 재귀적이며(cons의 cons의 cons . . .), 따라서 list를 소비하는 행동은 자연스럽게 재귀함수와 연결됩니다.

NOTE 재귀적으로 스스로 호출하는 것은 종종 느린 코드를 야기할 수 있습니다. 14장에서, 저희는 특별하고 잠제적으로 빠른 재귀를 이용하여 my-lenght 함수를 다시 작성할 것입니다.


()의 4가지 변신
 비어있는 list만이 false로 평가되는게 아니라, Common Lisp의 false 값도 그러합니다. 비어있는 list와 동일한 값이 없다면 true 값으로 간주됩니다. 이는 이전 예제에서 다뤄진 표현식 '(1)이 왜 true인지 설명해줍니다. 그러나, Lisp에는 비어있는 list를 가장한 다른 표현식이 있습니다:
[PIC]

 이 테이블에 있는 표현식을 서로 비교하여 동일하다는 것을 확인 할 수 있습니다.
[CODE]

 좌측에 있는 따옴표가된 list와 비교할때 테이블에서 평범하게 보이는 값은 하나입니다. 다른 3개는 모두 이전 장에서 다룬 Lisp form의 규칙을 깨는 것처럼 보입니다.
 특히 처음 두 예제가 의심스럽습니다. "이봐, 이 항목은 코드가 아니라 데이터 조각이야"라고 Lisp 환경에 말해주는 따옴표가 없습니다. nil의 경우엔, 임의의 값을 담을 수 있는 변수의 이름이라 추측할 수 있습니다. 따옴표가 없는 ()인 경우, 어떤 일이 벌어질지 알 방법이 없습니다. 괄호가 평가되어야 하는 코드의 형태처럼 보이지만, Lisp form은 항상 앞에 이것이 무얼 할지 말해주는 심볼을 갖습니다. form안에 아무것도 없을때 무슨 일이 벌어질까요?
 핵심은, Common Lisp가 프로그램에서 이 4개의 값들을 사용할시 비어있는 list와 같다라는 배경으로 설계되었다는 것이며, 대부분의 Lisp조건들을 우아한 간결성으로 작성되어졌다는 것입니다. 예를들어, 그 자체로 평가되며 첫번째 경우처럼 따옴표가 생략이 가능한 nil이란 이름의 상수가 있습니다. 두번째 경우는 Common Lisp가 비어있는 form을 parse하는데에서 나온 자연스런 부산물입니다. 세번째인 경우는 ()과 nil은 동일하게 다루어야 한다는 Common Lisp spec의 요구사항 때문입니다.
 이러한 것들이 모두 동일한 값을 가진다는 특별한 아름다움이 있지만, 모든 Lisper들이 이러한 정서에 동의하는 것은 아닙니다. 무엇보다도, false와 비어있는 list는 실제로 동일한 것처럼 보이십니까? 다른 유명한 Lisp의 dialect의 Scheme의 제작자는 이러한 이슈에 대해 다르게 생각하며, 코드 간결성이라는 미세한 비용에도, 거짓이란 개념과 비어있는 list를 완전히 분리시키는걸 선호합니다.


조건들 : if와 그외
 이제 저희는 어떻게 Lisp가 true와 false를 다루는지 이해했으며, if와 다른 조건 명령어들을 살펴봅시다.


if로 한번에 하나씩
 if 명령어는 (이와 같은 1 + 2 = 3)true나 (이와 같은 1 + 2 = 4)false인 경우를 다룰 때 사용합니다.
[REPL]

 if 명령어는 또한 리스트가 비었는지 확인하는데 이용됩니다:
[REPL]

 더욱이, 여러분이 살펴본 if 명령어는 오직 하나의 조건 가지branch만을 지닙니다.
[REPL]

 여기저 저희가 하는 일은 숫자 5가 홀수인지 검사하여, 결과에 기반해서, if form안에 있는 다음 두 표현식중 하나를 평가하는 것입니다. 5가 홀수이기에, 이는 처음 표현식을 평가하며, form은 odd-number를 리턴합니다
 (보기에는)해가없을것같은 이 자그마한 명령어에서 많은 (Lisp를 이해하는 데 중요한 것)일들이 벌어집니다. 여기 두가지 중요한 의견(observations)이 있습니다:

z if 다음 오직 하나의 표현식만이 실제로 평가된다.
z if 문에 있는 것 중 하나만 할 수 있다.

 보통, Lisp에서 함수가 평가되면, 함수 자체가 평가되기 전에 함수 이름 다음에 오는 모든 표현식이 평가됩니다. 그러나, if는 이와 갈은 규칙을 따르지 안습니다. 이를 확인해보기 위해, 다음 예제를 살펴봅시다:
[REPL]

 이 코드를 실행시키려 시도한다면, 여러분이 0으로 나누려 하기에, 자기를-존중하며, 법을-준수하는 Lisp 함수는 여러분의 엉덩이를 밖으로 차버릴 것입니다.
  그러나 if는 단순한 함수가 아닙니다. 이는 인자들을 일반적인 방식으로 평가하지 않을 권리를 지닌 특별한 form입니다. 조건의 요점은 어떠한 것을 실행시키고 다른 것은 실행하지 않는 것이기에 이는 이치에 맞습니다. 이러한 경우, 홀수일 경우에만 적용되는 branch에 있기에, 아무렇지도 않게 0으로 나누는 것을 무시합니다. Lisp의 조건 명령어들은 대게 특별한 form입니다.
[PIC]

NOTE 몇몇 조건 명령어들은 사용자가-만든 특별한 form과 같은 매크로입니다. 특별한 form이 된다는 것은 보통, 명령어가 곧 언어로 된다는 것을 암시합니다. 16장에서, 여러분은 이와 같은 매크로를 작성하는 법을 배울 것입니다.

 if 안에 있는 하나의 표현식만이 평가되기에, 두개 혹은 더많은 분기를 수행하는 것은 불가능합니다. 실제로 이것을 좋은 것이라 여기는 (14장에서 다룰, 함수형 프로그래밍이라 불리는) 똑똑한 프로그래밍 스타일이 있습니다. 그러나, 하나 이상의 것들을 원한다면, 하나의 표현식안에 추가 명령어를 껴넣는 특별한 명령어 progn을 사용할 수 있습니다. progn에서 나중에 평가된 것이 전체 표현식의 값으로 반환됩니다. 예를들어, 다음 예제에서, 조건 branch에서 특별한 전역 변수를 직접 설정하기 위해 이 명령어를 사용했습니다.
[REPL]
[PIC]


if를 넘어서: when과 unless 대안책
 if 내부에서 다수의 것을 수행하기 원할 때마다 progn을 매번 사용하는 것은 고통스럽기에, Lisp는 암시적으로 progn을 포함하는 다른 명령어들을 지녔습니다. 이러한 것 중 가장 기본적인 것은 when과 unless입니다:
[REPL]

 조건이 true인 경우, when으로 둘러싸인 모든 표현식이 평가됩니다. 조건이 false인 경우, unless으로 둘러싸인 모든 표현식이 평가됩니다. 이러한 명령어들은 반대 조건으로 평가되면 아무런 일도 하지않습니다; nil을 반환하고 아무것도 하지 않습니다.


이 모든 일을 수행하는 명령어 : cond
 그러나 여러분이 이 모든 것을 원하는 코더라면 어떻게 할까요? 아마 여러분은 타협할 마음이 없으며 모든 일을 할 수 있는 함수를 원할 것입니다! Lisp는 여러분을 도와줄 것입니다.
[PIC]

 cond form은 Lisp에서 버팀목 역활을 하는 고전방식입니다. 괄호사용의 자유로움을 통해, 이는 암시적인 progn을 허용하며, 하나의 분기보다 많은 것을 다룰 수 있으며, 심지어 다수의 조건들도 훌륭하게 평가할 수 있습니다. Lisp 석기시대부터 cond는 널려 있었기에, 이는 능력에 있어 포괄적이며, 많은 Lisper 프로그래머들이 이것이 진정한 Lisp의 조건(conditional)이라 여기고 있습니다.

 여기 한 예가 있습니다:
[REPL]
[PIC]

 보시다시피, cond의 본체는 다양한 조건 branch를 분리하기 위해 괄호 층을 이용합니다. 각 괄호로된 부분중 첫번째 표현식은 branch를 활성화 시키는 조건을 포함하고 있습니다. 저희 예제에서, 푸딩 도둑의 각 타입에 대한 다양한 분기를 지녔습니다: 하나는 Henry, 하나는 Johnny를 위한것, 그리고 다른 하나는 아무 누군가. 제공받은 사람의 이름과 각 잠재적인 범인과 비교하기 위해 eq를 사용했습니다.
 cond form에서의 조건은 항상 위에서 아래로 확인되어지며, 따라서 처음 일치하는 것대로 행동합니다. 이번 예제에서 마지막 분기는 최소한 마지막 분기가 항상 평가되어진다는 것을 보장하는 조건 t를 지닙니다. 이는 평범한 cond 관용구(idiom)입니다.
 when과 unless처럼 암시적인 progn이기에, 동작된 분기는 하나 이상의 명령어를 포함할 것입니다. 이러한 경우, 처음 두 분기는, 값을 반환하며, 추가 *arch-enemy* 변수를 설정할 것입니다.


case로 분기하기
 마지막 Lisp 명령어를 살펴봅시다: case form. 조건문에서 eq 함수를 사용하는 것은 일반적이며, case는 서로 비교할 수 있도록 해줍니다. case를 이용하여, 여러분은 이전 예제를 다음과 같이 다시 작성할 수 있습니다:
[REPL]

이 버전의 code는 아주 쉬워 보입니다. 각 case문에 의해 다루어 지는 사람의 이름이 훨씬 더 잘보입니다 - 동일성 검사에 의해 숨겨지지 않았습니다. 여러분이 사용하는 Lisp의 버전에 따라,  특히 많은 수의 case가 다루어지는 긴 명령문를 가진곳에서, 이와 같은 case문는 좀더 효율적일 수 도 있습니다.

WARNING case 명령어가 비교를 위해 eq를 이용하기에, 이것이 symbol 값에 대해 분기하기 위해 사용되는 것은 당연합니다. 문자열값에 대해 분기하기 위해는 사용될 수 없습니다. 62쪽에 있는 "Comparing Stuff: eq, equal, and More"를 참조하시기 바랍니다.


조건문을 이용한 멋진 트릭
 Lisp의 함수형 디자인은 몇몇 단순한 명령어들로부터 많은 이점을 얻도록 해줍니다. 특별히, Lisp의 조건과 관계된 직관적이지 않은 트릭은 여러분이 더욱 깔끔한 코드를 작성하도록 도와줄 수 있습니다. 첫번째 것은 두 새로운 조건 명령어와 관계되어있습니다. 두번째 것은 true와 false에 대한 Lisp의 간결한 개념을 이용합니다.


비밀 조건 and와 or 사용하기
 조건 and 와 or는, 덧셈과 뺄셈을 이용하여 숫자를 다루는 것과 동일한 방식으로 부울값을 다루는 단순한 수학적 연산자입니다.
 예를들어, 여기 3개의 숫자가 홀수인지 확인하기 위해 이를 어떻게 사용하는지 나와있습니다:
[REPL]

 5, 7, 9가 홀수이기에, 전체 표현식은 true로 평가합니다.
 유사하게, 여러분은 적어도 숫자들 중 하나가 홀수인지 확인하기 위해 or를 사용할 수 있습니다:
[REPL]

 4와 8이 홀수임에도 불구하고, 7이 홀수이기에, or 명령어도 역시 true로 평가합니다.
 그러나 and와 or에 관해서, 여러분이 처음 두 예제를 보았음에도 알아차리지 못한 더욱 흥미로운 것이 있습니다. 더욱이 이 두 명령어는 평범한 수학 연산자처럼 보입니다; if나 cond처럼 조건 명령어처럼 보이지 않습니다. 그러나 이것은 조건을 다루기 위해 이용될 수 있습니다.
 예를들어 여기, 숫자가 짝수일 경우에만 전역 변수를 true설정하는 조건에, 이를 어떻게 사용할 수 있는지가 나왔습니다:
[REPL]

 홀수에도 똑같이 한다면, 변수는 바뀌지 않은체로 남아있을 것입니다:
[REPL]

 이 예제는 Lisp가 shortcut Boolean evaluation을 이용한다는 것을 예증합니다. 이는 list에 있는 앞선 명령문 값이 true라고 Lisp가 판단하면, true를 반환하고 남아있는 명령문을 평가하는데 신경쓰지 않는다는 것을 의미합니다. 이와 유사하게, list에 있는 앞선 명령문이나 값이 false라고 Lisp가 판단하면, 남아있는 명령문을 평가하는데 신경쓰지 않고 멈추게 됩니다.
 마이너하고 소수만 즐기는 정보(observation)처럼 보일지라도, 대다수의 경우에 이는 실제로 매우 유용할 수 있습니다. 예를들어, 파일이 수정되고 사용자가 이를 저장하기 원하는 경우에만, 파일을 디스크에 저장하기 원한다고 가정해 보시기 바랍니다. 기본 구조는 다음과 같이 작성될 수 있을 것입니다:
[CODE]

 여기서, 함수 ask-user-about-saving은 파일에 관해 사용자에게 물어보는 것이며,사용자의 바램에 기반하여 true나 false를 반환합니다. 그러나, Common Lisp와 대다수의 Lisp 방언에서 shortcut Boolean evaluation은 부울연산자의 사용을 보장하기에, 이를 이처럼 작성할 수 있습니다:
[CODE]

 여러분이 일반적인 부울연산자의 사용이 단순한 수학 연산자라고 생각한다면,
이러한 깔끔한 스타일의 조건 코드 평가의 사용이 가능합니다. 이 form은 세개의 표현식간에 몇몇 Lisper들이 좋아할만한 우아한 대칭을 지닙니다. 그러나, 여러분의 코드를 읽는사람이 (save-file)이 내부적으로 부울값을 반환한다는 사실을 놓치기 쉽다는 쟁점이 있을지도 모릅니다. and와 or가 실제로 무얼 의미하는지에 대한 더욱-일반적인 개념에 대해 여러분의 생각를 정리할 시간이 필요할 것입니다.
 이전 접근법을 절중한 세번째 방식으로 작성한 코드는 다음과 갈습니다:
[CODE]

 조건의 일부로 다루어지는 표현식들이 부울값을 반환하는게 명확하게 보이기에, 많은 숙련된 Lisper들은 이 버전이 이전 두 버전보다 조금 더 깔끔하다고 여길 것입니다.


단순한 참보다 많은것을 반환하는 함수 사용
 이제 Lisp의 true와 false에 대해 생각하는 간편한 방식의 또다른 이점을 살펴봅시다. 이미 다루었듯이, (nil의 다양한 변종을 제외한) Common Lisp의 값은 true입니다. 이는 조건에 일반적으로 사용되는 함수는 true를 반환하는 것보다 많은 반환 옵션을 지닌다는 것을 의미합니다.
예를들어, Lisp 명령어 member는 list의 항목을 확인하는데 사용될 수 있습니다:
[REPL]

 이는 매우 직관적입니다. 그러나 또 다시 화면 밖에서 여러분이 예상치 못한 일이 발생하였습니다. member 명령어를 따로 분리하여 돌려봅니다:
[REPL]

 도대채 어떤일이 여기서 일어난 것일까요? 왜 이것은 (1 5)를 반환할까요?
 사실, 이를 완벽하게 합리적으로 설명할 수 있습니다. Lisper가 true와 false를 반환하는 함수를 작성할때, 그는 스스로 이렇게 생각할 것입니다 "t가 아닌 다른 값을 반환할 수 없을까?" Common Lisp에서 nil-이 아닌 값은 모두 true로 평가하기에, 다른 값을 반환하는 것은 근본적으로 자유롭습니다. member 함수의 구현자는 어딘가에 살고 있는 어떤 미친 Lisper가 이 함수를 사용한 어떤 계산에 대해 list의 꼬리에 있는 값을 보고자 할거라고 여겼습니다.

NOTE 3장에서 list '(3 4 1 5)는 중첩된 (cons 3 (cons 4 (cons 1 (cons 5 nil))))와 같다고 한 것을 기억하시기 바랍니다. 이로써 member 함수가 반환하는게 왜 값 (cons 1 (cons 5 nil))인지 분명해졌습니다.

 그러나 왜 tail대신 발견한 값을 반환하지 않을까요? 사실, 이와 같은 방법으로 다른 함수로 원래 값을 넘길 수 있기에, member 함수를 정의하는데 있어 이것은 유용한 방법이 될 수 있을 것입니다. 불행히도, 특정 상황에서는 이러한 계획이 틀어질 수 있습니다:
[REPL]

 이 예제에서 볼 수 있듯이, nil을 인자로 찾을 지라도 member 함수는 여전히 정확한 답을 줍니다! member 함수가 실제로 (다른 말로, 저희가 찾고자한 값) nil을 반환한다면, 이는 false로 평가될 것이며, 예제는 nil이 list에 있지 않다고 틀리게 말할 것입니다. 그러나, member 함수가 항목을 찾은 시점에서 list의 tail을 반환하기에, 항상 true값이 될것이란게 보증됩니다. 요구된 값을 성공적으로 발견하면 항상 하나 이상의 값을 가진 list를 반환할 것이며, 저희는 이것이 항상 true로 평가된다는 것을 알게됩니다.
 실제 값을 반환하는 함수는 아레 나와 있는 find-if 입니다
[REPL]

 사실 find-if 함수는 인자로 다른 함수, 이번 경우 oddp를 취합니다. find-if 는 oddp가 true를 반환하는 list에 있는 첫번째 값을 찾을 것입니다. 이러한 경우, (만약 있다면)홀수인 숫자를 발견할 것입니다.
 여러분은 어떻게 find-if가 두개의 배역을 맡을 수 있는지 알 수 있습니다: 일치하는 상수 값을 받아오는 것과 조건 내부의 true/false 값.

NOTE 이번 예제의 oddp앞에 있는 이상한 hash 마크(#)에 대해 걱정하지 마시기 바랍니다. 7장과 14장에서 더욱 자세하게 find-if 함수와 다른 것들을 다룰 것입니다 - higher-order 함수.

 유감스럽게도, find-if 함수의 우아한 대칭은 하나의 작고 못생긴 사마귀(wart)를 지녔습니다. 만일 nil 값을 찾으려 한다면 실망스런 결과를 얻게 될 것입니다:
[REPL]

 nil값에 대해 true를 반환하는 null 함수는 정확히 nil을 찾아냅니다. 불행히도, 이러한 짜증나는 경우에 있어선, 확실하게 값이 발견됬음에도 false로 평가된 결과가 반환되기에 find-if 조건문에서 사용해서는 안됩니다. 대칭이 깨졌습니다.
 이러한 자그마한 것들이, 성숙한 Lisper라 할지라도 눈가에 이슬이 맺히도록 만듭니다.


비교하는 것: eq, equal, 기타 등등
 Lisp에는 수 많은 아름다운 대칭이 있습니다. 하지만 비교하는 명령어와 관련해서, Lisp의 어느 일부분은 아름답지만은 않습니다.
 Lisp에서 두 값이 "동일한지" 밝혀내기 위해 비교하고자 한다면, 뒤죽박죽으로 이를 수행한다고 주장하는 다양한 함수들을 발견할 것입니다. 이런 종류로는 equal, eql, eq, =, string-equal, equalp가 가장 흔히 쓰입니다. 값을 올바르게 비교하는 법을 알기위해, Lisper는 반드시 이러한 함수들의 미묘함을 가슴 깊이 이해해야 합니다.
[PIC]

 이러한 madness를 분석하기 앞서, 저는 여러분에게 무언가를 비교하는 Conrad의 경험 법칙을 알려드리겠습니다. 다음에 나오는 규칙을 준수한다면, 세상에서 가장 깔끔한 Lisp코드를 작성하지 못할 지라도, 경험많은 Lisper들의 (횟불과 농기구를 집어들어 도시밖으로)내몰침 없이, 여러분은 몇몇 샘플들을 뉴스그룹에 게시할 수 있으실 것입니다.
[PIC]

 심볼은 항상 eq로 비교해야 합니다: 
[REPL]

 eq 함수는 모든 Lisp 비교 함수중에 가장 단순하며 매우 빠릅니다. 심볼 외에 다른 항목을 비교하는 것에는 올바르게 동작하지 않지만, 여러분이 심볼이 Lisp의 중심이라고 여긴다면, 여러분은 얼마나 이 함수가 유용할 수 있는지를 깨달을것입니다. 숙련된 Lisper들은 eq가 아닌 다른 걸로 심볼로 보이는 두개를 비교하는 코드를 얕잡아볼 것입니다.

NOTE eq는 또한 (cons 명령어로 만들어진 link) cons를 비교할 때 사용할 수 있습니다. 그러나, 동일한 cons 호출에 의해 만들어진 자기 자신과 비교되어 질 때에만, true값을 반환합니다. 이는 "보기"에는 동일해 보이지만 관계가 없는 두 cons은 eq test에서 실패할 수 있습니다. eq가 자기 자신에 대해서만 cons cell을 확인 할 수 있기에, cons에 eq를 사용하는 것은 실제로 초보자에게 유용하지 않습니다. 그러나, 숙련된 Lisper는 특정 상황에서 cons를 서로 비교하기 원할 것입니다.

 심볼을 다루지 않는다면, equal을 이용해야합니다. 이 명령어는 여러분에게 두개가 ("보기에 같다"는 것을 의미하는) 같은 모양인지를 알려줍니다. 아래 나온 것처럼, 이는 모든 Lisp 기본 데이터형식에 적합합니다:
[REPL]

 보시다시피, (다음장에서 다룰) 문자열과 문자를 포함하여, Lisp에 있는 대다수의 항목들을 equal로 효율적으로 비교할 수 있습니다
 다음 칵테일 파티를 통해, 혼란스럽게 만드는 Lisp의 비교에 대해 최소한은 알게 됬으므로, 이제 다른 비교 명령어들을 살펴봅시다.
[PIC]

 eql 명령어는 eq 명령어와 비슷하지만, eq와 다르게 숫자와 문자의 비교도 다룹니다.
[REPL]

 equalp 명령어는, 약간의 추가 정교함을 지닌 다양한 비교 case를 다룰 수 있다는 점을 제외하면, 본질적으로 equal 명령어와 같습니다. 예를들어, 이는 대소문자가 있는 다양한 문자열을 비교할 수 있으며, 정수와 부동-소수점이있는 숫자를 비교할 수 있습니다:
[REPL]

 나머지 비교 명령어들은 특정 데이터형식을 위해 특화된 것들 입니다. 게다가, equal과 유사합니다. 예를들어, (동일 표시) = 함수는  숫자를 다루며, string-equal은 문자열을 다루며, char-equal은 문자를 다룹니다.
  이제 저는 여러분이 Lisper들이 비교를 아주 심각하게 받아들이는지 이해할 수 있을거라 희망합니다.


여러분이 배운것
 이번장에선, Lisp에서 어떻게 조건이 동작하는지에 대해 다루었습니다. 이러한 과정속에서, 다음과 같은 것을 배웠습니다:

z Common Lisp에서 값 nil, 'nil, (), '()은 기본적으로 동일한 것이다.
z Lisp는 비어있는 list를 확인하는게 쉽다. 이는 lister-eater를 작성하는 것을 쉽게 만들어 줍니다.
z if명령어와 같은 Lisp 조건들은 올바른 조건일 경우에만 Lisp코드가 평가되게 한다.
z 모든것을 수행할 조건 명령어가 필요하다면, cond를 사용해야 한다.
z Lisp에서 어떠한 것을 비교하는 것은 복잡하지만, 여러분은 심볼을 비교하는데 eq를 사용하고 그외에 것들에 대해선 equal을 사용한다면, 처리해낼 수 있다.