DOMAIN-SPECIFIC LANGUAGES
17. Domain-Specific Language

 매크로를 사용하는 주된 이유중 하나는 domain-specific language (DSL) 프로그래밍을 하기 위해서 입니다. DSL 프로그래밍은 특별한 목적에 최적화하기 위해 Lisp 코드 구조와 모양을 바꿔 어려운 프로그래밍 문제를 해결하게 만들어주는 진보된 매크로 프로그래밍 기법입니다. 엄밀히 말해 매크로가 DSL프로그래밍을 수행하는데 있어 필요로 하지 않을지라도, 매크로 set을 작성함으로 여러분은 쉽게 Lisp에서 DSL을 만들 수 있습니다.


What Is a Domain?
 2000 US Census에 따르면, 미국에 있는 가족들은 평균 1.86명의 자녀를 가졌습니다. 각각의 가족이 정확히 1.86명의 자녀를 가진 것이 아니기에, 평균에 확실하고 정확히 들어맞는 가족은 없습니다. 이와 같은 마찬가지로,  평균 컴퓨터 프로그램같은 같은 것은 어디에도 없습니다. 모든 프로그램은 특정 문제와 인간 주변의 조사나 영역을 해결하기 위해 고안되었고, 주어진 area에 있어 문제를 해결하는 프로그램에 영향을 주는 고유한 요구사항을 지닙니다. DSL로,  여러분은 domain-specific 요구 사항 고려하여 프로그래밍 언어의 핵심을 강화시킬 수 있으며, 잠재적으로 여러분의 결과 코드를 작성하고 이해하기 쉽게 만들어 줍니다.

 몇몇 특화된 domain을 살펴보고 Lisp를 이용하여 이러한 domain들을 쉽게 처리할수 있게 만드는 DSL을 만들어 봅시다. 이번장에서, 저희는 두 DSL을 만들 것입니다. 우선, scalable vector graphics (SVG) 파일을 작성하기 위한 DSL을 만들 것입니다. 그런 다음 텍스트 어드벤쳐의 명령어를 생성하기 위한 DSL을 작성할 것입니다 - 최종적으로 5와 6장에서의 저희 Wizard's Adventure Game을 충분히 즐길 수 있도록 업데이트 할 것입니다!


Writing SVG Files
[pic]
 SVG 포맷은 그림을 그리기 위한 file format입니다. 이 format에 원과 폴리곤와 같은 오브젝트들을 명시하고, 그런 다음 이들을 보이기 위해 호환 가능한 컴퓨터 프로그램에 넣습니다. SVG 포맷은 raw 픽셀 대신 순수한 math 함수를 이용하여 그림을 명시하오, 이 포맷에서의 이미지를 쉽게 scalable하게 만들기에, 어떠한 크기의 SVG 이미지를 만드는 것은 쉽습니다

 SVG 포맷은 현재 웹 개발자로부터 많은 관심을 받고 있습니다. (마이크로소프트 InternetExplorer를 제외한) 근대 모든 브라우저들은 SVG를 자체적으로 지원합니다. 최근 구글은, Internet Explorer일지라도 SVG를 적절히 지원하는 SVG Web이라 불리는 라이브러리 set을 릴리즈 하였습니다. 이는 SVG를 현재 웹 브라우저의 90퍼센트 이상에서 동작하게 합니다. 결국, 웹사이트에서 삽화를 그려넣는데 있어 SVG는 현실적이며 효율적인 선택이되었습니다.

 SVG 포맷은 XML 포맷위에 구성되었습니다. 여기 완성된 SVG 파일이 어떻게 보여지는지에 대한 예가 있습니다
[source]

 간단하게 이 text 복사하고 example.svg파일에 넣습니다(혹은 http://landoflisp.com/에서 이 파일을 다운로드 합니다), 그런 다음 여러분은 이 파일을 Firefox 웹 브라우저에서 파일을 열 수 있습니다(사파리, 크롬, 오페라에서도 동작 합니다).

 여기 여러분이 보게 될 빨강과 파랑색원이 있습니다:
[pic]

 이제, 이와 같은 그림을 Common Lisp에서 바로 생성하는 매크로와 함수를 작성해 봅시다!


Creating XML and HTML with the tag Macro
 (마치 HTML 데이터 포맷과 같은) XML 데이터 포맷은 주로 중첩된 태그로 구성됩니다:
[source]

 모든 태그는 일치하는matching 끝마침closing 태그를 지닙니다. closing tag는 동일한 이름을 지녔고, 앞에 슬래쉬가 붙었습니다. 추가로, tag들은 속성attribute들을 포함할 수 있습니다:
[source]

 이 예제에서, 저희는 blue가 된다는 attribute와 높이가 9인 mytag란 태그를 생성하였습니다.


Writing a Macro Helper Function
 작업을 처리하려 매크로를 작성할때, 여러분은 종종 매크로가 해야하는 일 대신 함수에 의해 다뤄질 수 있는 일들이 많다는 것을 발견할 것입니다. 이러한 연유로, 처음  매크로가 필요로하는 많은 일들을 수행하는 helper 함수를 작성하는 것에 신중해야 합니다. 그런 다음 helper 함수에 의해, 가능한 단순함을 유지하는 매크로를 작성합니다. 이것이 Lisp에서 XML-style tags를 생성하는 매크로를 작성하기 위해 여러분이 해야만 하는 일입니다.

 여기 하나의 opening(혹은 closing) 태그를 출력하는 print-tag라 불리는 helper 함수가 있습니다:
[source]

 우선, print-tag 함수는 opening 꺽쇠괄호를 출력합니다. 한 문자이기에, #을 괄호 앞에 붙여넣어 literal 문자 syntax를 이용합니다. 그런 다음 predicate closingp를 확인합니다. 만약 참이라면, tag는 슬러쉬를 closing tag앞에 놓아야 합니다. 그런 다음 string-downcase 함수로 소문자로 변환된 tag의 이름을 출력합니다. 그 다음, alist에 있는 모든 attribute들을 순환iterate하고 각 attribute/value 쌍을 출력합니다.

 마지막으로, closing 꺽쇠괄호를 넣음으로써 끝이납니다. 다음은 print-tag 함수의 사용 예 입니다. 이는 매크로가 아닌 평범한 함수이므로, REPL에서 디버그하기에 쉽습니다. 이것이 매크로를 만들때 왜 help 함수가 좋은 idea인지에 대한 또 다른 이유입니다.
[source]

 보시다시피, 이 함수는 XML tag를 출력하는 일을 잘 수행합니다. 그러나, 이러한 방식으로 모든 태그를 생성한다면 실로 지루한 작업일 것입니다. 이것이 왜 저희가 다음에 tag 매크로를 작성하는지에 대한 이유입니다.


Creating the tag Macro
 저희가 만들 tag 매크로는 Paul Graham의 Arc Lisp 방언에 동일한 이름의 매크로에서 채택하였습니다. 이는 매크로를 지니지 않고는 처리할 수 없는 모든 것들에 대해, several crucial 한 방식으로print-tag 함수를 향상시킵니다:

z tag들은 항상 쌍을 이룬다. 그러나, 중첩된 tag를 원한다면, 함수 내부에서 출력되는 tag로 둘러싸인 tag를 출력할 수 없을 것입니다. 이는 중첩된 태그가 평가되기 이전과 이후에 코드의 실행을 필요로하기 때문입니다. 매크로로 이러한 일이 가능하지만, 함수로는 아닙니다.

z Tag 이름과 attribute 이름은 보통 동적인 방식으로 바뀔 필요가 없다. 이러한 연유로, tag이름에 단일 quote를 붙이는게 필요치 않습니다. 다시 말하자면, tag이름은 data모드에 있는 것처럼 default 로 다루어져야 합니다.

z tag이름과는 달리, attribute의 value는 동적으로 생성되는게 매우 바랍직하다. 저희 매크로는 attrivute 값을 code 모드로 넣는 syntax를 지닐 것이며, 이로써 이 값을 이주populate시키는 Lisp 코드를 실행 시킬 수 있습니다

 이는 REPL에서 이를 사용할때 tag 매크로가 이론상 어떻게 동작하는지에 대한 것입니다:
[source]

 tag 이름과 attribute 리스트는 그 앞에 quote가 더이상 필요치 않습니다. 추가로, 이제 Lisp 코드에서 attribute를 계산하는게 극적으로 쉬워졌습니다. 이번 경우, height를 4 더하기 5로하여 계산하였습니다.

 여기 이러한 작업을 수행한 매크로가 있습니다:
[source]

 예상대로, 매크로는 처음 opening tag를 생성하기 위해print-tag를 호출합니다. 저희는 attribue의 값이 code 모드에 있는걸 원하기에, print-tag를 위한 attribute의 alist를 생성하는 것은 조금 까다롭습니다. 리스트를 이용하여 attributes를 wrapping 함으로써 이를 수행할 것입니다. 그런 다음 pairs 함수로 쌍으로 만든 attributes를 통해 mapcar합니다. (이전 장의 끝부분에서 pairs 함수를 만들었다는 것을 기억하십시요) 각 attribute 쌍에대해, attribute의 값 앞에 quotation 마크 없이 cons로 이루어진 리스트로 code 조각을 생성하여, 저희는 이를 동적으로 계산할 수 있습니다.

 다음으로, tag 매크로 내부에 중첩된 모든 코드를 넣음으로써, 이는 opening tag 이후에 호출 됩니다. 마지막으로, closing tag를 생성합니다.

 이 매크로가 attribute 리스트를 어떻게 다루는지 이해하기 위해, 저희 예제의 결과물을 macroexpand로 통과시켜봅시다.
[source]

 매크로 확장을 살펴보면, 어떻게 tag 매크로 attribute 리스트를 만드는지, print-tag를 통과하여 height attribute처럼 어떻게 동적으로 attribute 값의 생성을 허용하는지가 명백해집니다.

 여기, 이번엔 두개의 내부 tag를 지닌 이 매크로를 사용한 또다른 예제가 있습니다:
[source]

 이것이 어떻게 정확하게 내부 중첩 tag를 적절한 XML openning과 closing tags로 감싸는지 주목하기 바랍니다. 명확성을 위해 출력에 줄바꿈과 들여쓰기를 추가하였다는 것을 알립니다. tag 함수의 실제 output은 줄바꿈과 들여쓰기 없이 항상 한줄의 라인으로 출력됩니다.


Using the tag Macro to Generate HTML
 tag 매크로는 XML이나 HTML을 생성하는데 사용됩니다. 예를들어, 다음에 나오는 "Hello World" HTML 문서를 생성할 수 있습니다.:
[REPL]

 (어떠한 태그 이름이 가능한 XML과는 달리) HTML은 미리 정의된 tag를 사용하기에, Lisp로 HTML을 좀더 쉽게 만들어주는 특정 HTML 태그를 위한 단순한 매크로를 작성할 수 있습니다. 예를들어, 여기 html과 body매크로 예제가 있습니다:
[source]

이제 저희는 좀더 우하하게 "Hello World" HTML 예제를 작성할 수 있습니다:
[REPL]

 그러나, 저희는 대신 tag매크로를 SVG 그림 생성에 이용하길 원합니다. 그러므로 저희 DSL을 SVG domain으로 확장시켜봅시다.


Creating SVG-Specific Macros and Functions
 우선, 전체 SVG 이미지를 포함embodies하는 svg 매크로를 작성해봅시다. 여기 그러한 것이 나와 있습니다:
[source]

 svg 매크로는 tag매크로를 기반으로 합니다. 저희 목적을 위해, SVG 이미지는 두가지 특별한 attribute의 생성을 필요로 합니다.

z xmlns attribute는 SVG 뷰어(저희 경우엔, Firefox 웹 브라우저)에게 SVG 포맷을 위한 적절한 문서를 어디서 찾을 수 있는지 말해줍니다.

z second attribute는 그림속의 하이퍼링크를 가능케 합니다. 이 하이퍼 링크 기능은 다음장 시작부에 더욱 진보된 예제에서 사용될 것입니다.

 그림을 그리기 위해선, 색상을 다룰 필요가 있습니다. 이를 단순화시키기 위해, 색상을 리스트 RGB triple로 저장하여 나타낼 것입니다. 예를들어, 색상 (255 0 0)은 밝은 빨간색입니다.

 이는 보통 밝거나 어두운 다양한 특정 색상을 생성하는데 있어 유용합니다. 다음에 나오는 brightness 함수는 이러한 일을 합니다:
[source]

 밝은 빨간색을 이 함수에 넣고 밝기를 -100으로 설정한다면, 어두운 빨간색이 생성되는걸 보게될 것입니다:
[REPL]

 다음으로, SVG 그림 요소의 스타일을 설정하는 함수를 생성해 봅시다:
[soruce]

 svg-style 함수는 색깔을 받은다음, 그림 요소의 채움과 stroke(윤곽선)을 설정합니다. brightness 함수를 이용하여, 윤곽선을 어둡게 만들 수 있습니다. 이러한 방식으로, 여러분은 여러분의 그림의 모든 요소에 대해 단일 색상을 지정하면 되며, 근사한 외형이 유지됩니다.

 이제 원을 그리는 함수를 만들어 봅시다. circle 내부에 중첩된 다른 SVG 태그가 필요치 않으므로, circle을 그리기 위한 매크로를 작성할 필요가 없습니다 - 함수로 충분합니다.
[source]


 저희는 각 원의 중점, 반지름, 색상을 지정하고자 합니다. 중점은 SVG circle attribute cx와 cy로 할당되었습니다. 반지름은 attribute r에 놓여졌습니다. svg-style 함수로 원의 스타일을 설정합니다.
 
 이제 저희는 새로운 DSL을 이용하여 이전에서 봤던 두 원을 지닌 간단한 SVG 그림을 그릴 준비가 되었습니다! 여기 이를 어떻게 하는지가 나와 있습니다:
[REPL]

 이제 저희는 함수형 SVG DSL을 지녔습니다. DSL이 프로그램에 주는 힘을 느껴보기위해, DSL에 더 많은 기능들을 추가 해 봅시다.


Building a More Complicated SVG Example
 임의의 폴리곤을 쉽게 그리게 만들어주는 새로운 함수를 SVG DSL에 추가해 봅시다:
[source]

 SVG 폴리곤은 point attribute에 모든 폴리곤의 꼭지점을 저장합니다. point 리스트를 ~{ ~} control string을 포함하는 format 선언문을 이용하여 구성합니다. 11장에서 이 control string이 format 함수 내부에서 리스트를 통해 순환했던것을 기억하시기 바랍니다. 이번 경우, point 리스트를 순환할 것입니다. 그런 다음 mapcar 이후에 append를 이용하는 것과 같은, mapcan을 이용하여 point 리스트를 깨부십니다.

 이번 예제에선, 저희는 random walks를 그릴 것입니다. random walk는 매순간 동전을 뒤집어 위 혹은 아래로 움직이는것을 결정하였을때 얻을 수 있는 그래프입니다. Random walks는 주식 시장에 있는 주식과 매우 유사합니다. 이는 주로 재정 모델링을 위한 starting point로 사용됩니다. 여기 random walk를 생성하는 함수가 있습니다:
[source]

 이 함수는 value 인자에서 출발하는 수의 리스트를 만듭니다. 그런 다음 무작위로 이 값을 증가시키거나 감소시킵니다. random 함수를 이용하여 어떤 방향으로 움직이는지 선택합니다. (재귀적 호출 후에 cons가 발생하기에, 단순함을 유지하기 위해 이 함수는 tail call 최적화를 하지 않았습니다.)

 여기 random-walk 함수를 어떻게 사용하는지에 대한 예가 있습니다:
[REPL]

 이제 그림에서 다수의 random walks를 그리도록 SVG DSL을 이용해봅시다:
[source]

 이번 예제에서 만든 데이터의 양이 매우 방대하기에, 데이터를 REPL로 출력하는 대신 곧바로 (random_walk.svg란 이름의) 파일로 덤핑할 것입니다. 12장에서 소개된 기법인 *standard-output* 동적 변수를 redirecting함으로써 이러한 일을 수행합니다. DSL 명령어로 Lisp 코드를 어떻게 자유롭게 다루mix는지 주목하시기 바랍니다. 예를들어, 한번에 10개의 폴리곤을 생성하기 위해 SVG 매크로 내부에서 곧 바로 loop할 수 있습니다.


 그래프를 예쁘게 만들기 위해, 색이 입혀진 각 그래프 안쪽 영역을 체워 넣을 것입니다. 이러한 일을 하기위해, 도형을 완성하기 위한 점을 포함한 (y-좌표 200의) 그래프의 하단 기본baseline라인과 폴리곤을 이용하여, 각 라인을 나타낼 것입니다:
[pic]

 이는 각 폴리곤을 생성하는 동안, 왜 좌측-하단과 우측-하단 모서리를 지정하는 점을 추가해야하는지에 대한 이유입니다. 좀 더 많은 재미를 위해, 각 그래프 라인의 색상을 무작위로 설정하였습니다.

 여기 매우 간단한 DSL 코드로 생성된 무작위 그래프 예제가 있습니다:
[pic]

 이제 Lisp로 얼마나 쉽게 XML, HTML, SVG의 DSL을 작성할 수 있는지 보았으므로,
완전히 다른 종류의 DSL을 만들어 봅시다! - 5장과 6장에서 다룬 Wizard's Adventure Game의 사용자 게임 명령어를 만들어 주는 것


Creating Custom Game Commands for Wizard’s Adventure Game
[pic]

 5장과 6장에 마법사와 제자가 주연인 게임을 마지막으로 봤을때를 기억한다면, 저희는 세계를 돌아다니며 물건을 집을 수 있었습니다. 그러나, 실제로 다른 흥미롭고 재미있는 행동을 수행할 수 없었습니다. 게임을 재미있게 만들기 위해선 게임의 특정 물건, 특정 지점에서 수행되는 특별한 행동을 포함해야 합니다. 저희는 뽀뽀 할 수 있는 개구리, 싸울 수 있는 용, 심지어 구출 할 수 있는 아가씨를 필요로 합니다!

 게임에서 이러한 흥미로운 활동을 생성하는 것은 특별한unique 도전을 제기합니다. 반면, 이와 같은 다양한 게임 행동에 많은 유사성이 있습니다. 예를들어, 이들 대다수는 저희가 저희만의 물건을 가지도록 요구할 것입니다. 한편으론, 고유하며 색다른 (명령어-특화된 Lisp 코드를 통해 활성화된)특징을 가져야 하며, 그렇지 않으면 게임은 지루하게 될 것입니다. 앞으로 보게될 것 처럼, DSL은 여러분이 게임에 이와 같이 많은 고유한 명령어의 추가하는 것을 도울 수 있습니다

 여기서부터 이 장의 끝까지의 code를 돌리기 위해, 5장과 6장의 모든 게임 코드를 이용할 것입니다. 일단 이번 장의 코드를 wizards_game.lisp파일에 넣습니다 (혹은 http://landoflisp.com/에서 wizards_game.lisp를 다운받습니다). 게임이 로드되자마자, 여러분은 CLISP REPL에서 게임 명령어를 입력할 수 있습니다. 아니면, 더욱 세련된 게임 경험을 얻기 위해 6장에서 만든 game-repl 명령어를 이용할 수 있습니다. quit 명령어는 게임 REPL에서 빠져나가게 한다는 것을 명심하시기 바랍니다.

 여기 REPL에 게임 코드를 로드하고 동작 게임 명령어를 실행하기 위해 여러분이 무엇을 해야하는지가 나와 있습니다:
[REPL]


Creating New Game Commands by Hand
 그러면 저희 게임 DSL은 어떤 모습을 지녔을까요? 이를 실로 느끼는 유일한 방법으론, 우선 직접 몇몇 명령어를 만들어 보는 것입니다. 그리하면, 저희는 다양한 명령어 사이에 저희 DSL의 기초로 사용될 수 있는 어떤 특정 패턴이 있다는 것을 보게될 것입니다


A Command for Welding
[pic]
 마법사의 저택 다락방에는 용접기welding machine가 있습니다. 사슬을 바구니을 이 지점에 가지고 오면 이를 플레이어가 용접할 수 있도록 만들어 봅시다. 여기 이러한 일을 해내는 코드가 있습니다:
[source]
 
 우선, have 함수를 이용하여 플레이어가 현재 물건을 지니고 있는지 확인하는 단순한 방식이 필요합니다. 플레이어가 지닌 것이 무엇인지 확인하는 inventory 명령어를 만들었다는 것을 기억하시기 바랍니다. 물건이 inventory에 있다면, 이는 플레이어가 물건을 "지니고 있다have"는 것을 의미합니다.

 다음으로, 나중에 게임에서 오직 한번만 용접이 가능하기에, 저희 프로그램은 사슬과 바구니가 서로 용접됬는지를 판별하는 몇몇 방법이 필요합니다. 이러한 목적으로 전역, 동적 변수 *chain-welded* 변수를 생성하였습니다.

 마지막으로, welding 명령어 자체를 만들어야 합니다. welding은 많은 조건이 충족되었을 때에 비로써 가능합니다.:

z attic에 위치해야 한다.
z welding 명령어의 subject와 object로써 chain과 bucket을 지녀야만 한다
z chain과 bucket을 들고 있어야 한다.
z chain과 bucekt은 또 다시 용접할 순 없다.

 이러한 조건을 만족한다면, *chain-welded* 변수를 true로 설정하고 이것이 성공적이라는 것을 나타내는 메시지를 출력합니다. 조건을 만족시키지 못한다면, 용접이 성공적이지 못했다는 것을 알립니다.

 CLISP REPL에서 이 명령어를 테스트 해봅시다:
[REPL]

 음, 지극히 정상적인 반응입니다. 어쨋든 저희는 다락방에 없고, 올바른 물건을 지니지 않았습니다. 지금까진 괜찮습니다.

 다음으로, 저희의 멋진 game-repl에서 새로운 명령어를 테스트 해봅시다:
[REPL]

 어라? 왜 이것은 저 명령어를 "알지" 못하는 것일까요? 그 답은 단순합니다: 저희 game-repl은 승인되지 않은 명령어의 수행을 방지하는 기본적인 보호막을 지니고 있습니다.

 이를 고치기위해선, weld를 승인된 명령어 목록에 추가시켜야 합니다.
[REPL]

 pushnew 명령어를 이용하여, weld 함수는 오직 이게 리스트에 존재하지 않을 때 승인된 명령어로 추가됩니다. 문제가 해결되었습니다!


A Command for Dunking
[pic]
 마법사의 정원에는, 우물이 있습니다. 바구니를 물로 채워넣기위해 플레이어가 이를 우물에 던저넣는 명령어를 만들어 봅시다:
[source]

 저희 weld 명령어에선, 우선 바구니가 이미 채워졌는지를 확인하는 변수를 필요로 했습니다. 다음으로, dunk 함수가 필요합니다. dunking 하기 위해, 저희는 다시 한번 이 행동을 성공적으로 수행하기에 앞서 만족되야만 하는 기나긴 조건 목록을 가지게 되었습니다. 이는 welding 명령어가 필요로 했던 것과 유사합니다. 예를들어, dunking은 특정 지역에 있으며 정확한 물건을 지닌 플레이어를 요구합니다. 다른 조건은, dunk가 가능하기 전에 플레이어가 용접된 사슬을 가져야한다는 사실과 같은, dunking-specific입니다. 마지막으로, 저희는 dunk 함수를 승인된 행동 목록에 넣어야 합니다.
[pic]


The game-action Macro 
 이제 저희는 두 사용자 게임 행동을 만들었으며, 몇몇 방식에 있어 weld와 dunk 명령어는 매우 유사합니다. 그러나, SVG 라이브리에서 처럼, 각 게임 명령어는 명령어의 행동을 customize하기 위해 이 안에 특정 동적 로직 지녀야 합니다. 이러한 이슈를 다루는 game-action 매크로를 작성해 봅시다. 이는 새로운 게임 명령어를 만드는 것을 쉽게 만들어 줄 것입니다.
[source]

 이 game-action 매크로는 dunk와 weld 명령어 사이의 일반적인 패턴을 구성합니다. game-action의 인자는 command의 이름, 행동과 연관된 두 물체, 이게 일어나는 장소, 사용자 로직을 이 명령어에 추가하도록 해주는 body 인자의 임의의 추가 코드입니다.

 game-action 매크로의 주요 임무는 명령어를 위한 새로운 함수를 정의하는 것입니다. 여러분은 아마 여러분을 매크로가 멈추지 않고 자체적으로 새로운 함수를 정의하는 것과 같은 강력한 일을 할 수 있다는 것에 놀랄 것입니다. 저는 이번 예제가 여러분에게 Common Lisp 매크로 시스템이 어떻게 유연하고 mind-bending할 수 있는지 보여주길 희망합니다.

 이 게임의 모든 game action은 location, subjct, object를 필요로 하기에, 이 매크로로 직접 몇몇 조건을 다룰 수 있습니다. 그러나, 저희는 다른 조건들을 각 특화된 명령어를 위해 open 하여 남겨둘 것입니다. 예를들어, 게임 sentence의 subject가 플레이어가 소유해야 하지만, object는 그렇지 않는 경우가 있습니다. sentence의 object (dragon)은 플레이어의 inventory 에 있을 필요가 없는 "돌을 용에게 던저라"와 같은 수행될 수 있는 많은 행동이 있기에, 이는 이치에 맞습니다.

 기본 매크로-레벨 조건을 만족시킨다면, 로직의 나머지를 개별 명령 레벨로 나눌 것입니다. 조건이 충족되지 않는다면, 현재 명령어의 이름에 customized된 에러 메시지를 출력합니다. 마지막으로, 저희 fancy game-repl을 위해 그 명령어를 허용된 명령 목록으로 pushnew합니다

 매크로에서 하지 말아야 하는 일은 어떠한 전역 변수를 정의하거나 설정하는 것입니다. 게임 명령어가 *chain-welded*나 *bucket-filled* 전역 변수를 정의해야 한다면, 이를 스스로 처리해야 합니다. 게임의 state 변수와 particular 명령어 사이에 일-대-일 관계의 보장이 없기에, 이는 이치에 맞습니다. 예를들어, 필요하지 않는 상태를 만드는 어떤 명령어가 여러번 허용될 수 있습니다. 혹은 다수의 상태 변수에 기반한 행동이 있을 수 도 있습니다. 명령어가 이러한 종류의 변의를 갖는 것은 그들로 하여금 고유함과 재미를 줍니다.

 이러한 매크로로, 저희는 이제 새로운 게임 행동을 생성하는 단순한 DSL을 가졌습니다! Essentially, 이 명령어는 게임 명령어를 생성하는 영역domain에  특화된 여러분만의 프로그래밍 언어를 주었습니다. 이전 weld와 dunk 명령어를 새로운 게임 명령 프로그래밍 언어를 이용하여 재작성해 봅시다:
[source]

 보시다시피, 이 명령어들은 더 눈에 쉽게 들어 옴니다. bucket의 소유를 확인하는 반면, dunk는 well의 소유를 확인할 필요가 앖습니다.

 게임 명령어 DSL의 구현하기 위해 이용한 매크로의 가치를 더 살펴보기 위해, 더욱 복잡한 게임 명령어 splash를 구현해 봅시다:
[source]

 이 명령어에는, 발생할 수 있는 3가지 분리된 시나리오가 있습니다

z bucket은 비어있다.
z bucket이 가득찼지만, frog를 흠쳤다. 이러한 경우 여러분은 패배합니다.
z bucket이 가득찼으며, frog를 흠치지 않았다. 여러분의 승리입니다!

 game-action 매크로로, 저희는 특별하고 색다른 행동을 지닌 많은 행동 명령어들을 지원할 수 있습니다. 여전히, 저희는 불필요한 반복을 피할 수 있습니다.

NOTE
 game-action 명령어는 매크로의 본체에서 subject와 object 변수를 노출합니다. 이는 게임 명령어가 정보에 접근하는 것을 허용하지만, game-action 명령어가 만든 코드가 subject와 object변수를 갖고 있다면 이 또한 이름 충돌을 유발합니다. 연습으로 game-action 매크로를 수정해보면, subject와 object 변수는 16장에서 다룬 gensym 이름으로 교체해보시기 바랍니다.


Let’s Try the Completed Wizard’s Adventure Game!
 여기 저희가 이 게임에 넣은 풍부한 기능성을 보여주는 Wizard’s Adventure Game 실행 샘플이 있습니다. 게임을 실행해보고 마법의 도넛을 얻을 수 있는지 봅시다!
[pic]

[repl]
What You’ve Learned
 이번 장은 Lisp에서 DSL을 어떻게 만드는지를 시연하였습니다. 여러분은 다음에 나온 것을 배웠습니다:

z 매우 특화된 영역을 위해 기괴한 프로그래밍을 해야한다면, 매크로는 훌륭한 해결책이다. 이로 하여금, 여러분만의 DSL을 만들 수 있습니다.

z 보통, (print-tag와 같은) 매크로를 위한 helper 함수를 우선 작성하고 오직 매크로만이 제공 할 수 있는 improments를 추가하는 (tag와 같은) 매크로를 작성하는것이 이치에 맞습니다. 이러한 구현는 보통 깔끔하고 안전한 syntax 의 코드의 코드에 접근을 허용하는 것과 연관되어 있습니다

z DSL을 더 많은 힘을 여러분에게 주는 정규 Lisp 코드와 섞을 수 있다.

z 매우 특화된 코드를 작성해야 할때 DSL은 유용하다 - 이게 웹 페이지를 위한 코드, 그림을 그리는 코드, 특별한 게임 명령어를 만드는 코드이든지 간에.