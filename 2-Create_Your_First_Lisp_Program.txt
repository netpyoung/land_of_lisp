
 저희는 Lisp의 약간의 철학을 다루었고 CLIS환경을 갖추으며, 우리는 간단한 게임의 형태를 실제 Lisp코드로 작성 할 준비가 되었습니다.

The Guess-My-Number Game 


저희가 제작할 첫번째 게임은 매우 간단한 생각해보기 게임입니다. 이것은 숫자맞추기 게임입니다. 여러분이 1에서 100사이의 번호를 생각하고, 컴퓨터가 맞추는 게임입니다.

 만일 여러분이 23이란 숫자를 생각했다고 가정하고 진행하겠습니다. 컴퓨터는 50이라 추측하는 것으로 시작하고, 계속 추측하보는데, 정답을 맞출때까지 여러분은 (small) 혹은 (bigger)이라고 입력합니다.

이 게임을 만들려면, 여러분은 세가지 함수(function)를 만들 필요가 있습니다 : 
 my-number-guess, small, bigger.
게이머는 단순히 이 함수를 REPL로 불러옵니다.

 이전 장에서 본것과 같이, CLISP를 시작하면(혹은 다른 Lisp), 여러분은 REPL을 보게되고,
여러분이 명령어를 입력한걸 읽고(Read) 해석하여(Evaluated) 보여(Printed)줍니다. 이번 경우에는, 저희는 my-number-guess, small, bigger 함수를 실행할 것입니다.

 함수를 부르려면(호출하려면, call), 함수에 입력값(인자, parameter)을 넣어서 괄호로 감싸야 합니다. 이 함수에서는 인자가 필요없기 때문에, 함수이름만 괄호로 감싸면 됩니다.

 이 게임을 어떻게 짤지 생각해봅니다. 짧게 생각한후, 다음과 같은 결론에 이르렀습니다.

1. 게이머의 최소값과 최대값의 한계를 정합니다. 만약 범위가 1부터 100까지라면, 최소값은 1이되고 최대값은 100이 됩니다.
2. 번호가 범위안에 있는지 추측합니다.
3. 게이머의 번호보다 작다면, 최대값을 낮춥니다.
4. 게이머의 번호보다 크다면, 최소값을 올립니다.


 매 추측마다 가능한 수의 범위를 반으로 줄이는 단계를 수행함으로써, 게이머의 수를 빠르게 찾나아갈 수 있습니다.
 이러한 종류의 검색을 이진검색(binary search)이라 부릅니다. 아시겠지만, 이와 같은 이진검색은 컴퓨터 프로그래밍에 자주 사용되고 있습니다. 예를들어, 여러분이 이와 같은 단계를 따름으로써, 정렬된 테이블에 주어진 특정번호를 효율적으로 찾을 수 있습니다. 이 경우에는, 테이블에서 최소값과 최대값을 따라감으로써, 위와 유사한 방법으로 올바른 열을 빠르게 찾아나갈 것입니다.

Defining Global Variables in Lisp 

 게임을 구성하고 있는 함수를 호출함에 있어, 프로그램에는 추적해나갈 최소와 최대가 있어야 합니다. 이러한 일을 하기 위해, 전역변수(global variables)라 불리는 *small*과 *big*을 만들 필요가 있습니다.

Defining the small and big Variables 

변수는 Lisp에서의 전역 변수는 top-level definition라 불립니다. 우리는 새로운 top-level definition을 defparameter 함수로 만들것 입니다 : 

 defparameter란 함수 이름은 실제로 parameter와 아무런 관계도 아니기 때문에, 종종 혼동 됩니다. 이것으로 여러분은 전역 변수를 정의할 수 있습니다.


defparameter에 보낼 첫번째 인자는 새로운 변수의 이름입니다. *big*과 *small* 이름을 둘러싼 별표-애정어린표현으로 귀마개라 부릅시다(affectionately called earmuffs)-는 순전히 맘대로 붙였고 부가적인 것입니다. Lisp에서는 별표를 변수 이름의 일부로 보고 이것에 대해 무시합니다. 이번장 뒤에 다루게 될 다른 지역변수들과 구분하기 쉽기 때문에, Lisper들은 전역변수들을 이와 같은 방법으로 표시하는 것을 선호합니다.

An Alternative Global Variable Definition Function (전역 변수 정의 함수의 대안)

 defparameter를 사용하여 전역 변수를 설정하면, 예전에 저장된 변수값을 덮어서 저장합니다.

 보시다시피 *foo*변수를 다시 정의하면 값이 바뀝니다. 전역 변수를 정의할 수 있는 또다른 명령어 defvar는 이전에 정의했던 전역 변수의 값을 덮어쓰지 않습니다.

 몇몇 Lisper들은 전역 변수를 정의할때 defparameter보다 defvar를 선호합니다. 그러나, 이 책에서는 오직 defparameter을 사용할 것입니다.

NOTE
여러분이 다른 곳에서 Lisp에 관한 것을 읽을때, 아마 몇몇 프로그래머들이 Common Lisp에서 전역변수를 참조할때 동적변수(dynamic variable)나 특수변수(special variable) 를 사용하는것을 볼 수 있습니다.
Common Lisp에서 전역 변수는 특별한 기능을 가졌기 때문인데, 이것은 후에 다루기로 합니다.

Basic Lisp Etiquette 

명령어를 호출하는 방식과 Lisp의 코드형식은 다른 언어들에 비해 다소 이상합니다. 첫째로 defparameter 함수와 같은 명령어를(이것의 인자와) 괄호로 감싸야 됩니다 :

 괄호가없으면, 명령어는 호출되지 않습니다.

 또한, 공백과 줄바꿈은 Lisp가 여러분의 코드를 읽을때 완전히 무시되어집니다. 이게 의미하는 것은 여러분이 이상한 방법으로 명령어를 호출해도 같은 결과를 얻습니다 : 

 Lisp 코드는 매우 유연한 형태가 될 수 있기 때문에, Lisper들은 다양한 라인과 들여쓰기를 포함하는 수많은 명령어 형태 규약(conventions for formatting commands)을 가지고 있습니다. 이 책에 있는 코드 예제들은 일반적인 들여쓰기 형태 규약을 따르고 있습니다. 소스코드 들여쓰기 규칙보다도 게임을 만드는데 더욱 관심이 있으므로, 이 책에서는 코드 배치 규칙에 관해 시간을 낭비하지 않겠습니다.

Defining Global Functions in Lisp 

 guess-my-number 게임은 게임을 시작하라는 게이머의 요청에 반응하는 컴퓨터를 지니고, 보다 생각한것보다 작거나 큰지 물어봅니다. 여기서, 저희는 세가지 전역 함수를 정의할 필요가 있습니다 : guess-my-number, smaller, bigger. 저희는 또한 다른 번호로 다시 시작하는 함수 start-over 를 정의해야 합니다. Common Lisp에선, 아래와 같이 def로 함수를 정의합니다

 우선적으로, 함수의 이름과 인자를 지정합니다. 그다음, 함수의 로직을 구성하는 코드를 완성해나갈 것입니다.

Defining the guess-my-number Function 

 저희가 정의할 첫번째 함수는 is-guess-my-number입니다. 이 함수는 *big*과 *small*변수를 게이머의 수를 예상하기 위해 사용합니다 정의는 다음과 같습니다 :  

 guess-my-number뒤에 있는 텅빈 괄호()는 이 함수는 어떤 인자값도 필요치 않다는것을 나타냅니다. REPL에서 코드 일부를 입력할때 들여쓰기나 줄바꿈에 대해 걱정할 필요가 없을지라도, 괄호를 정확한 자리에 넣어야 합니다. 괄호를 잊어먹거나 다른 곳에 넣는다면, 오류가 날 것입니다.

 REPL에서 이와 같은 코드 조각을 실행시킬때마다 표현식에 들어간 결과값이 출력될 것입니다. Common Lisp의 모든 명령어는 반환 값을 생성합니다. 예를 들어, defun 명령어는 새로 생성된 함수 이름을 반환합니다. 이것이 저희가 defun Y를 호출한후 REPL에서 함수 이름이 되풀이되어 보여지게 되는 이유입니다.

 이 함수는 어떤 일을 할까요? 쉽게 예기하자면, 이 게임에서 범위 안에 컴퓨터가 맞출 수를 넣는 것입니다. 이것을 수행하면, 범위의 끝에 있는 두수의 평균을 고릅니다. 자연수에 대해서만 생각을 할 것이므로, 평균이 분수로 밖에 나타낼 수 없으면, 평균과 가까운 값을 사용합니다.

 guess-my-number에 대한 구현은 최대와 최소값을 더하고, 산술적 자리옮김(arithmetic shift)을 이용해, 합을 반으로 만듬으로써 결과를 구합니다.  (+  *small*  *big*) 이 코드는 두 변수를 더하는 것입니다. ash함수가 호출될때 이 덧샘이 계산되기 때문에, 더한 결과가 ash 함수로 전달됩니다.

 괄호로 둘러싸인 ash함수와 추가(+)함수는 Lisp에서 필수입니다. 이 괄호들은 Lisp에게 "우리는 이 함수를 호출 하고 싶어"라 말하는 것입니다.
 Lisp에 내장된 함수 ash는 수를 이진 형식으로 보고, 그것을 우측이나 좌측으로 비트를 이동하여 버리게 됩니다. 예를 들어, 11이란 수는 이진으로 1011로 쓰여졌습니다. 저희는 ash함수로 두번째 인자로 1을 넣음으로써 이 수를 좌측으로 비트를 이동할 수 있습니다 : 

 바이너리로 10110인 22가 반환되었습니다.

 저희는 두번째 인자로 -1을 넣음으로써 비트를 오른쪽으로 이동할 수 있습니다(끝에 있는 비트는 버려지게 됩니다): 

 바이너리로 101인 5가 반환되었습니다.

 이 ash 함수를 guess-my-number에서 써서, 우리가 찾아야할 번호의 범위를 반으로 계속 줄여나감으로써 정확한 번호를 빠르게 찾아나갈 것입니다. 이미 말했듯이 이진 검색이라 부르는 이 반으로 줄이른 과정은 컴퓨터 프로그래밍에 있어 유용한 기법입니다. ash함수는 Lisp에서 이진 검색시에 일반적으로 사용됩니다.
  
 새 함수를 호출하면 어떤일이 일어나는지 봅시다 : 

 첫번째 추측이기 때문에, 이 함수를 호출함으로써 저희가 보게될 결과는 계획했던대로 동작합니다 : 1부터 100사이에 있는 오른쪽에 있는 50을 골랐습니다.

 Lisp에서 프로그래밍 할때, 여러분은 결과가 화면에 출력되지 않는 함수들을 작성할 것입니다.


함수 내부에서 계산된 값을 반환합니다.
 Instead, they'll simply return the value calculated in the body of the function.

예를들어, 5를 반환하는 함수를 원한다고 칩시다. 이렇게 작성할 수 있습니다 : 

 함수 X안에서 계산된 값은 5로 평가되기 때문에, (return-five)를 호출하면 5를 리턴합니다.

guess-my-number는 이렇게 설계되었습니다. 화면에서 계산 결과를 수 있는데 이것은 함수가 숫자를 보여주기 때문에 아니라, REPL의 기능 때문입니다.


Defining the smaller and bigger Functions 

이제 저희는 smaller와 bigger함수를 작성할 것입니다. guess-my-number와 같이 defun으로 전역 함수를 정의합니다 : 

 우선적으로, defun을 사용하여 새로운 전역 함수 smaller를 정의하겠습니다.
빈 괄호가 비어있는데, 이 함수는 인자를 가지지 않기 때문입니다.

 다음, 저희는 setf함수를 이용하여 전역 변수 *big*의 값을 바꿀 것입니다. 마지막 추측 값보다 번호가 작아야 하기 때문에,  이것의 최대값은 추즉했던 것보다 하나 적은 수로 해야 합니다. (1-  (guess-my-number)) 이 코드는 다음과 같은 일을 합니다 :  guess-my-number함수를 호출하여 수를 추측한후, 1-함수를 사용하여 추측한 결과에서 1을 뺍니다.

 마지막으로, 저희는 smaller가 새로운 추측값을 보여주기를 원합니다. guess-my-number을 함수 마지막에 넣음으로써 이와 같은 일을 할 수 있습니다. 이번에는, 다음번 추측을 계산하기 위해 guess-my-number가 *big*값을 갱신시켜야합니다. 함수의 결과 값이 자동으로 반환되는데, smaller 함수에 의해 (guess-my-number에 의한)새로운 추측이 시작되기 때문입니다. *small*값을 증가시키는 것만 빼면, bigger함수도 같은 방식으로 동작합니다.

결국 bigger함수를 호출할시 이전 추측보다 크다고 말하는 것이고, 최소값은 (*small*변수의 영향을 받아)이전 추측보다 적어도 1이상이 크다는것입니다.

1+함수는 guess-my-number 반환값에 1을 더해 줍니다.

 작성한 함수가 추측값이 56이란 수로 가정하에 동작하는 과정이 아래에 나와 있습니다 :

Defining the start-over Function

게임을 완성하기 위해, 전역변수를 초기화할(to reset) start-over함수를 추가하겠습니다 :

여기에 나와 있듯이, start-over함수는 *small*과 *big*에 들어있는 값을 초기화 시키고 새로운 추측을 반환하기 위해 guess-ny-number를 다시 부릅니다.
다른 수로 새 게임을 시작하길 원한다면, 이 함수를 호출해서 게임을 초기화 할 수 있습니다.

Defining Local Variables in Lisp

간단한 게임에서, 저희는 전역변수와 전역함수들을 정의하였습니다.
그러나 대부분의 경우에 여러분은 정의한 것들을 하나의 함수나 혹은 코드블럭(block of code)안에 한정(limit)하기를 원할 것입니다. 이러한 것들을 지역(local)변수와 지역함수라 부릅니다.
 지역 변수를 정의하기 위해선, let명령어를 사용합니다. let 명령어는 다음과 같은 형태를 가지고 있습니다 : 

 let명령어 안에 있는 첫번째 것은 list 변수 선언 입니다. 이것으로 하나 혹은 이상의 지역 변수를 선언할 수 있습니다. 그럼으로써, 명령어 본체 안에서(오직 본체 안에서만) 이 변수를 사용할 수 있습니다. let명령어의 예제 입니다 :

 이 예제에서, 저희는 5와 6값을 갖는 변수 a와 b를 선언하였습니다. 그다음, let 명령어의 본체에서 이 둘을 더하였고, 그 결과인 11이 보여지게 됩니다.
 let 표현식을 사용할때, 선언하고자 하는 변수 리스트 전체를 괄호로 감싸야만 합니다. 또, 변수 이름과 초기화 값을 또다른 괄호 쌍으로 감싸야 합니다.

Defining Local Functions in Lisp
flet명령어를 사용하여 지역 함수를 정의할 수 있습니다. flet명령어는 다음과 같은 구조를 가졌습니다 : 

 상단에 있는 flet에서, 함수를 선언합니다(첫 두 라인). 이 함수는 본체 안에서만 사용이 가능합니다. 함수 선언은 함수이름, 함수의 인자와 함수 코드가 넣어질 함수 본체로 이루어져 있습니다. 여기예 하나의 예가 있습니다 :

 이 예제에서, 우리는 하나의 n이라는 인자를 취하는 함수 f를 정의하였습니다. f함수는 n변수에 10을 더합니다. 저희가 5를 인자에 넣고 함수를 호출하면, 15가 반환됩니다.
 let과 같이, 하나 혹은 이상의 함수들을 flet의 범위안에서 정의할 수 있습니다.
 flet명령어는 한번에 다수의 지역 함수를 정의하는데 사용할 수 있습니다. 명령어 첫번째 부분에 함수 선언들을 간편하게 추가 할 수 있습니다 :

 여기서, 저희는 두 함수를 정의하였습니다: 하나는 f이고 나머지 하나는 g입니다. flet 본체 안에서, 저희는 쉽게 두 함수를 참조할 수 있습니다. 예를 들어, f함수에 5를 넣고 호출하여 15를 얻고, g를 호출하여 3을 빼면, 최종 결과는 12가 됩니다.
 정의된 함수 안에서 사용가능한 함수를 만드려면,  labels명령어를 사용할 수 있습니다. 이것의 기본 구조는 flet 과 동일합니다. 여기 예가 있습니다 :

 이 예에서는, 지역 함수 a는 수에 5를 더합니다. 다음으로, 함수 b를 정의합니다. 함수 a를 호출한다음, 결과에 6을 더합니다. 최종적으로, 10이 인자가 되어 함수 b를 호출합니다. 10 더하기 6 더하기 5는 21임으로, 21이 전체 표현식의 최종 값이 됩니다. flet 대신 labels의 사용되어지는 특별한 경우는, 함수 b가 함수 a를 호출할 때입니다. flet을 사용한다면, 함수 b는 함수 a에 관해 "알지" 못할 것입니다.

labels 명령어는 다른 지역함수를 호출 할 수 있게 하고, 자기 자신을 호출하는 함수도 허용합니다. 이것은 Lisp코드에서 일반적이며 재귀(recursion)라 불립니다. (뒷장에서 재귀에 관한 많은 예제를 볼 수 있습니다.)

What You’ve Learned
이번 장에서는, 변수와 함수를 정의하는 Common Lisp의 기본 명령어에 대해 다루었습니다.
저희가 배운것을 나열해보면 : 
전역 변수 정의하기 위한 defparameter명령어의 사용
전역 함수 정의하기 위한 defun 명령어의 사용
지역 변수와 함수 각각의 정의를 위한 let과 flet 명령어의 사용
labels은 flet과 비슷하지만, 자신을 호출 할 수 있다. 자기 자신을 호출 하는 함수는 재귀 함수라 불린다.
