MAKING DICE OF DOOM MORE FUN
20장.Dice of doom을 더욱 재밌게 만들기

 Dice of Doom 의 최종 버전을 만들 시간입니다. 저희 게임의 version 4는 이전 버전보다 훨씬 플레이하기 재밋어질 것입니다.


 비록 여러분이 이를 인지하지 않을 지라도, 저희는 게임의 규칙에 있어 게임을 프로그램하기 쉽도록 하는 몇몇 중요한 구성물들을 만들었습니다. 이번 장에선, 더욱 많은 플레이어를 허용하고, 주사위 굴림의 추가와, Dice of Doom을 좀 더 재미있는 게임으로 만들도록 약간의 변화를 줄 것입니다.


Increasing the Number of Players
 시작에 앞서, 이전 장의 코드를 dice_of_doom_v3.lisp에 넣고, 다음 명령어를 실행합니다:
[REPL]

 저희가 할 첫번째 변화는 플레이어 숫자를 2에서 4로 늘리는 것입니다. 컴퓨터에 의해 조종되는 AI 적이 3이 될 것입니다. 지금까지 코드를 작성해 왔기에, 매우 적은 추가 코드를 필요로 합니다:
[CODE]

 우선 *num-players* 변수를 4로 바꿉니다. 그런 다음 새로운 플레이어에 대한 추가 주사위 색깔을 표시해야합니다. 4명의 플레이어를 위한 색상은 빨강, 파랑, 초록, 자주색이 될 것입니다.

 지금까지 저희가 만든 AI는 이미 4인용 게임에 적절하게 돌아갑니다.

 AI 게임 엔진은 "paranoid strategy"라 불리는 것을 이용할 것입니다. 이는 AI 플레이어가 항상 (인간을 포함한) 다른 플레이어가 다른 어떠한 목표없이 -흠 어떻게 말을 해야할까요?- 개인적으로 자신을 골탕먹이려 한다고 여긴다는 것을 의미합니다. 이는 이용하기에 나쁜 전략이 아닙니다; 그러나, 2인용보다 많은 게임에서 새로운 가능성이 열립니다. 예를들어, 패배하는 플레이어들이 그들의 가능성을 높이기 위해 승리하는 플레이어에 맞서 싸울 수 있습니다. 게임 AI는 이처럼 무리를 지을 만큼 충분히 영리하지 못하지만, 충분히 괜찮습니다.

 이제 저희는 플레이어 숫자를 증가시키기 위해 몇몇 상수를 수정하였으며, 다른 것들도 수정해봅시다:
[CODE]

 여기서, 저희는 6각 tile에 대한 주사위의 최대 갯수를 3에서 5로 늘렸으며, AI 레벨을 4에서 2로 줄였습니다. 이번 장에서 기술할 새로운 규칙에서, 저희는 빠름을 유지하기 위해 AI를 조금 포기해야 합니다. 4인 경쟁이 되었으므로, AI는 실제로 적인 인간에 대항할만큼 영리할 필요가 없습니다.


Rolling the Dice
 아마도 지금까지 저희 게임에서 하나의 뚜련한 결점을 눈치챘으리라 확신합니다:
Dice of Doom임에도 불구하고, 실제로 무작위성이 없습니다! 주사위를 굴리지 않으며, 매우 구차한 주사위 게임처럼 큰 더미가 항상 자동적으로 이깁니다. 이제 저희는 비로써 이러한 결점을 바로 잡을 것입니다.

 이 version에서 공격하는 동안 두 주사위 더미는 굴러, 가장 높은 숫자로 굴러진자가 전투에서 승리합니다. 무승부는, 방어자의 승리입니다. 공격자가 진다면, 플레이어는 공격한 hex로부터 하나를 제외한 모든 주사위를 포기해야합니다.

 AI 프로그래밍이란 용어에서, 이는 게임 트리의 node에 변화를 주어햐 한다는 것을 의미합니다. 저희가 구현할 이 방법은 매우 간단합니다.


Building Chance Nodes
 moves lazy list에 있는 모든 move는 항상 정확히 두 항목을 지니고 있습니다: move에 대한 기술과 (공격의 출발지와 목적지 리스트나, passing move를 위한 nil), move가 취해졌을시 게임트리의 새로운 node. 이제 저희는 move에 세번째 항목을 추가할 것며, 이는 성공적이지 못한 공격을 대한 게임 트리를 포함합니다. 이는  move list에 있는 각 move가, 공격이 성공적이냐에 달린 다음 게임 트리에 대한 possible follow-up nodes로, chance node로 쓰일 것이라는 것을 의미합니다.

 attacking-move함수를 추가 항목을 move에 추가하여 각 move가 chance node처럼 행동하도록 업데이트 해봅시다.
[CODE]

 이 attacking-moves의 업데이트된 버전에서 새로운 것은 바로 이곳(_1_), 게임 트리에 새로운 move를 만듬으로써 3번째 항목을 추가한 곳입니다. alternate change node의 가지에 있는 보드는 다음에 작성할 board-attack-fail함수의 호출로 구성됩니다.

 board-attack-fail 함수는 여러분이 예상한것과 동일하게 행동합니다:
 이는 board를 취하며 공격이 실패한 6각형에서 모든 주사위에서 하나를 제거한 board를 반환합니다.
[CODE]

 여기에선, 6각형이 공격을 받지 않는한, board에 대해 단순히 loop하여 수정없이 각 6각형을 반환합니다. 이번 경우, 6각형에서 하나를 제외한 모든 주사위를 없엤습니다


Doing the Actual Dice Rolling
 다음으로, 저희는 실제로  주사위를 굴리는 몇몇 함수를 작성해야 합니다. 여기 주사위 더미를 굴리는 함수가 있습니다:
[CODE]

 이는 우선 각 주사위에 대해 한번 looping하여 주사위 더미의 총 갯수를 계산합니다. 각 주사위에 대해, 이는 1에서 6까지의 무작위 숫자를 생성합니다. 그런 다음 이는 total 변수에 전체 합을 저장합니다. 다음, roll-dice 함수는 굴림에 대한 안내descriptive 메시지를 출력합니다. 마지막으로, 이는 total을 반환합니다.

 주사위 더미를 따로 굴리지 않았기에, 각각에 대해 두 주사위 더미를 싸우게pit하는 또 다른 함수를 만들어 봅시다:
[CODE]

 roll-dice를 두번 호출하여 두 굴림의 총계를 비교합니다. 저희는 인간이나 컴퓨터에 의해 선택된 turn에 대한 승리 혹은 패배의 move를 선택하기 위해 게임 트리를 순회travle할때, 이 함수를 이용할 것입니다


Calling the Dice Rolling Code from Our Game Engine
 게임 엔진과 관련하여, 주사위를 굴리는 것은 인간이나 컴퓨터가 move를 선택한 후 승리하거나 실패하는 chance node의 가지를 집는다는 것을 의미합니다. 이러한 행동은 pick-chance-branch함수에 의해 수행됩니다:
[CODE]

 이 함수는 현재 board와, 해결되어야만 하는 chance node를 포함하는, move를 취합니다. move의 내부에 있는 path가 null이 아닌경우, 공격 path간에 출발지와 목적지 6각형의 주사위 갯수에 대해 roll-against를 호출합니다. 저희는 null path를 검사하는데, 이는 move가 주사위 굴림이 필요없는 "pass," 라는 것을 의미하기 때문입니다.

 공격에 대한 주사위 굴림이 성공적이면, move의 chance node에서 처음 자식 트리를 반환합니다. 공격이 성공적이지 않다면, chance node의 두번째 자식을 반환합니다.

 이제 저희는 인간이나 컴퓨터가 move를 선택하면 pick-chance-branch 함수가 호출된다고 확신할 수 있습니다. 우선, 인간에 대한 것을 다뤄봅시다:
[CODE]

 여기서 한 일은 이전 handle-human 함수 끝에서 pick-change-branch의 호출을 추가한 것이며, 이 지점에서 게임의 다음 상태를 지닌 게임트리의 child branch를 반환합니다.

 이와 동일한 방식으로 handle-computer 함수를 갱신합니다:
[CODE]

 또 다시, 저희는 단순히 함수 하단에 pick-chance-branch의 호출을 추가하였습니다.

 이제 업데이트된 Dice of Doom 게임의 플레이가 가능합니다. 그러나, 이 시점에선, AI가 아직 change node가 존재하는지 알지 못하기에 컴퓨터플레이어는 매우 어리석은 게임을 할 것입니다. 이는 모든 공격이 항상 성공적이라 가정하므로, 너무 무모하여 제대로된 게임을 플레이 할 수 없게 만들 것입니다. 저희는 AI를 향상시켜 결정을 내리기 위한 주사위 굴림을 고려하도록 만들어야 합니다.


Updating the AI
 주사위 굴림을 다룰 수 있는 AI는 이제 저희 게임에서 중요하며, 주사위 굴림에 대해 통계에 관한 자그마한 뭔가를 알아야 합니다. 다음 테이블은 필요한 전략적인 정보를 제공합니다:
[
;; Table contains the odds of winning for each possible pairing of
;; dice in the game (nr-dice-src in columns vs nr-dice-dst in rows)
;; NOTE: the table starts with 2 dice, which is the minimum needed in
;; order to attack.
(defparameter *dice-odds*
;;   2    3    4    5 attackers
 #(#(0.84 0.97 1.0  1.0)  ; 1 dice in defence
   #(0.44 0.78 0.94 0.99) ; 2 dice in defence
   #(0.15 0.45 0.74 0.91) ; 3...
   #(0.04 0.19 0.46 0.72)
   #(0.01 0.06 0.22 0.46)))
]

 이 테이블은 게임에서 각 주사위 쌍에 대한 이길 가능성odds을 포함하고 있습니다. 행은 1나부터 시작하는 defending 주사위를 나타냅니다. 열은 2개(공격에 필요한 최소한의 주사위)부터 시작하는 attacking 주사위를 나타냅니다

 예를들어, 이 테이블은 저희에게 1개의 defending dice에 대한하는 2개의 attacking dice의 굴림은 84 퍼센트의 이길 확률을 지닌다는 것을 말해줍니다. 4개의 attacking dice에 대한 3개의 defending dice는 74 퍼센트의 이길 확률을 지닙니다.

 기억하실지 모르겠지만, 저희 AI 코드의 core함수는 possible follow-up moves의 list에 point score를 주는 get-ratings함수 입니다. 이를 주사위 굴림 성공 odds를 고려하여 각 possible move의 score를 계산하도록 수정해야 합니다. 이제 저희는 각 공격의 성공이나 실패의 결과의 point scores로써 *dice-odds* 테이블을 이용할 것이며, 각 available move에 대한 combined score를 체워 넣을것입니다:
[CODE]

 업데이트된 get-rating 함수에서, 테이블에서 성공적인 각 공격의 odds를 살펴봅니다. 그런 다음 odds에 winning child tree에 대한 rating을 곱합니다. 추가로, 패배하는 공격 odds에 losing board에 대한 rating을 곱하였습니다. 이제 저희는 chance node를 이해하며 move에 대한 score를 생성할때 알맞게 그들을 처리하는 업데이트된 get-rating 함수를 가졌습니다.

 저희 게임 AI는 chance nodes와 완전히 호환가능하므로, 하나 추가적인 자그마한 chance를 만들어야 합니다. tree-trimming 함수는 각 move에 대한 chance node의 두 가지에 대해 알아야하므로, 각 move에 대한 대안으로 승리와 패배를 적절히 trim할 수 있습니다:
[CODE]

 각 move의 꼬리에 대해 mapcar하므로, chance node의 두 가지에 대해 trimming이 수행됩니다.

NOTE
 Dice of Doom version 4는 alpha-beta pruning을 지니지 않습니다. chance nodes가 존재하는 곳에서 적절한 alpha-beta pruning을 수행하는 것은 매우 복잡합니다.


Improving the Dice of Doom Reinforcement Rules
 이제까지, 플레이어의 턴이 끝날때의 reinforcement의 수는 항상 captured opponent dice의 수에서 1을 뺀 것과 동일하였습니다. 이 reinforcement rule은 게임에서의 dice의 최종 숫자는 항상 감소한다는 것을 보증하므로, 게임은 결국 종료될 것이며, 게임 트리는 항상 제한된 size일 것입니다.

 그러나, version 2의 저희 게임 트리는 lazy 트리이므로, 트리가 무한하다면 이는 perfectly fine합니다. lazy evaluation의 주된 이점 중 하나는 무한한 size의 data structure를 지닐 수 있다는 것을 기억하시기 바랍니다.

 그러므로, 저희는 적략적으로 더욱 재미있게 만들기 위해 reinforcement rule을 조정할 것입니다.

 새로운 rule에 따르면, reinforcement dice는 플레이어의 가장 큰 인접 지형에 있는 tile수와 동일합니다. 영토를 연결하는 위험을 무릅쓸 것인지, 어쩌면 자살 임무를 품고 그들에게 보내어 생존할 수 없는 지형 조금 희생하는지에 대해 플레이어는 계속하여 결정해야하기에, 이는 전략의 깊이를 더해줍니다

 이 새로운 reinforcement rule을 구현하기 위해, 우선 get-connected 함수를 정의해봅시다. 이는 현재 플레이어가 소유하고 있으며 neghbors의 cluster로 목적지 tile에 연결된 tiles list를 반환합니다:
[CODE]

 이 함수는 연결된 tile을 찾는데 8장의 Grand Theft Wumpus game에서 결합관계를 계산하기 위해 사용한 것과 동일한 알고리즘을 이용했습니다. visited list가 남아있는 동안 hex와 neighbors를 재귀적으로 순회합니다.

 get-connected 함수는 2개의 recursive local function를 정의하여 이를 수행합니다. check-pos 함수는 하나의 위치 검사하여, 그 지점에서 접근가능한accessible 어떤 새로운 neighbors를 visited list에 추가합니다. check-neighbors 함수는 전체 neighbors list를 검사하며, 비슷하게 visited list에 새로운 neighbors를 덧붙입니다. 이 2개의 함수는 cluster에 있는 모든 neighbors를 찾을 때 동안 서로 재귀적으로 호출합니다. 이러한 재귀 계산을 시작하기 위해, 목표지점과 초기initially 비어있는 visited list으로 check-pos 함수를 호출합니다.

 이제 저희는 cluster를 찾을 수 있습니다. 그러나, 가장 큰 cluster를 찾기 위해 largest-cluster-size 함수가 필요합니다:
[CODE]

 이 함수는 이전에 방문했던 node의 list와 가장큰 크기를 유지하며, 보드에 있는 모든 지점을 확인하여 지금까지의 최상의 cluster를 찾는데 사용될 지역 함수 f를 정의합니다.

 현재 position 숫자가 board에 있는 spots 전체보다 작을경우, tile을 계속 확인합니다. 확인된 현재 tile 플레이어에 속하며 아직 방문하지 않았다면, 그 spot에서 도달가능한 6각형의 cluster를 받기 위해 get-connected를 호출할 것입니다. 그런다음, cluster의 size가 예전에 찾은 best보다 크다면, recursive call에서 이를 새로운 best size로 만들어야 합니다. 그렇지 않으면, 이전 best size를 유지하는 동안 f를 호출하여 진행합니다 (이 지점에서의 best 변수는 예전에 이전 iteration에서 발견한 bets 값을 유지할 것입니다). 그러나, 어떤일이 벌어지든지간에, pos 변수는 f함수의 호출에 매번 증가하며, 저희는 결국 전체 보드를 다루게됩니다.

 마지막으로, 저희는 reinforcement의 수를 결정하는 새로운 규칙을 이용하기 위해 add-new-dice를 갱신해야 합니다:
[CODE]

 보시다시피, add-new-dice 함수는, 예전 코드와의 호환을 위해 인자로 spare-dice를 받았지만, 이제 이 인자는 무시되어집니다. 대신, board에 추가된 reinforcements의 수가 가장큰 cluster의 크기에 기반합니다. 그 외에는, add-new-dice는 이전버전과 동일합니다.

 이는 새로운 reinforcement 규칙을 가능케하는 전체 코드입니다. 코드의 설계로 인해, AI 플레이어는 게임 트리에 대한 접근권을 지닙니다. 이제 게임 트리는 이 새로운 reinforcement 데이터를 지니기에, AI는 자동적으로 새로운 reinforcement 규칙에 걸맞는 전략을 채택할 것입니다!


Conclusion
 많고 다양한 프로그래밍 기법을 이용하여 Dice of Doom 게임을 만듬으로써 저희의 기나긴 여정이 끝났습니다. 저희는 이 책의 모든 게임과 함께 기나긴 여행을 마쳤습니다. 저와 같이 Lisp 프로그래밍 세계의 여행을 떠나주셔서 감사드립니다!

 저는 여러분이 노동의 열매를 즐기며 4개의 게임과 Dice of Doom의 마지막 버전을 즐기기를 제안합니다. 다시 말하지만, 웹 브라우저를 통해 Dice of Doom request handler 서비스 해야합니다.
[REPL]

 이제 여러분은 Firefox에서 (거듭말하자면, localhost:8080/game.html에서) 4인용이며 이번장에서 여러분이 추가한 새로운 규칙을 포함한 Dice of Doom을 플레이 할 수 있습니다
[PIC]

 Dice of Doom의 전투와 앞으로 여러분의 Lisp 프로그래밍에 대해 건투를 빕니다!
[PIC]