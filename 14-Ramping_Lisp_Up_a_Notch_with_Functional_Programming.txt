RAMPING LISP UP A NOTCH WITH FUNCTIONAL PROGRAMMING
14.함수형 프로그래밍으로 Lisp의 가치를 높이자

 이전 장에서 봤듯이, Lisp는 짧은 시간안에 몇몇 빠른 코드를 모아 간단한 게임을 매우 쉽게 만들어 줍니다. 그러나, Lisp의 주된 명성은 매우 복잡한 과학 문제를 해결하는데 적절한 학문적 도구라는 것입니다. 주장컨데 해킹하기 좋다는 사실은 단지 부수 이익일 뿐입니다.


 이 책의 나머지부분에선, 더욱 세련된 게임을 만들기 위해 몇몇 진보된 기술을 탐험하면서 언어의 과학적인 부분에 중점을 둘 것입니다. 이는 컴퓨터 프로그램에서 절대로 불가능이라고 생각했던 일들을 해냅니다.

 이번 장에선, 함수형 프로그래밍 기술이라 불리는 first advanced Lisp 개념에 대해 배울 것입니다. 다음 장에선, 이 기술을 이용하여, 인위적으로 대충 만든 지능 있는 적에 대항하는 간단한 주사위 전쟁게임dice_wars을 만들 것입니다.



What Is Functional Programming?
 이전 장에서, 저희는 이미 몇몇 함수형 프로그래밍 개념들을 다루었습니다. 잘 알려진 대답으로 함수형 프로그래밍은 "모든 코드를 함수를 사용하여 작성한 스타일의 프로그래밍"입니다.

 그러나, 문맥에서 함수function란 용어term를 사용하였을 때에는 매우 특별한 무언가를 의미합니다 - 실재로 수학자가 사용한 함수function란 단어word와 의미한 것과 동일한 것. 따라서, 그럼 이 단어를 사용할때 수학자는 무엇을 의미하였을까요?

 아마도 여러분은 이미 대답을 알고 있습니다. 아주 예전에 pre-algebra를 배웠을때의 기억을 떠올려 보시기 바랍니다. particular lesson에 졸지 않았다면, 선생님이 이와 같은것을 칠판에 적었던 것을 기억할 것입니다:
[pic]

 이 그림은 함수가 함수의 영역domain이라 불리는 곳으로 가는 인자를 지닌 것을 보여줍니다. 그런 다음 함수는 이 인자를 취하여 값을 반환합니다. 이 값을 함수의 범위에 있다고 합니다.

NOTE
 몇몇 숙련된 Lisper는, 누군가가 함수가 "값을 반환한다"고 말한다면, 움찔할 것입니다. Lisp는 함수형 프로그래밍-algebra와 같은 1930s에 Alonzo Church에 의해 개발된 lambda calculus에서 나왔기 때문입니다. lambda calculus에서는, 시작된 프로그램에  함수의 결과를 판별하기 위해 치환 법칙을 수행함으로써, 프로그램을 "실행"합니다. 때문에, 함수 집합의 결과는 치환을 거처 마치 마법의 일종처럼 나타납니다; 의도적으로 함수가 값을 반환한다고 "단정하지" 마시기 바랍니다.

 이러한 이유 때문에, 순수 Lisp주의자는 함수를 "값을 평가한다"라고 말하는걸 선호합니다. 그러나, 프로그래밍 세계에서 대부분의 사람들은 함수는 값을 반환한다라고 말하는 것을 선호합니다. 함수에 대해 어떤 방식이 가장 자연스럽게 느껴지는것은 여러분에게 달려 있습니다.


 여기, 몇몇 중요한 수학적 함수의 속성이 있습니다:

z동일한 인자를 통과시키면, 함수는 항상 동일한 결과를 반환한다. (이는 종종 referential transparency라 언급됩니다)
z 이 변수가 상수성constant를 유지한다고 확신하지 않는한, 함수는 함수 외부에 정의된 변수를 참조하지 않는다.
z 함수에 의해 수정되는modify(혹은 함수형 프로그래머가 말하는, 변화mutate) 변수는 없다.
z 함수의 용도은 결과를 반환하는것 말고는 아무것도 하지 않는 것이다.
z 이 함수는 다이얼로그 박스를 화면에 띄우거나 컴퓨터를 "Bing!"하게 만드는 것과 같이 외부 세계로 보여지는 일을 하지 않는다.
z 함수는 키보드나 하드드라이브와 같은 외부 소스로부터 정보를 취하지 않는다.

 가능한 이러한 규칙을 따른다면, 여러분은 코드를 함수형 스타일로 코드를 작성했다고 말할 수 있습니다

 실재 수학적 함수의 좋은 예제는 sine 함수입니다. 비슷하게, Lisp의 (수학적 sine을 계산하는)sin 함수는 함수형 스타일의 규칙을 따르는 Lisp함수의 좋은 예제입니다:
[output]

 sin 함수는 동일한 인자를 넣으면(이번 경우에는, 0.5) 항상 동일한 결과를 반환합니다. 이는 외부 세계와 소통하지 않습니다. 이것의 일생동안 목표는 sine을 값으로 반환하는 것입니다. 리스트를 처리하는데 있어 모든 규칙을 따릅니다.

 분명, 함수형 스타일로 컴퓨터 프로그램의 모든 코드를 작성하는 것은 불가능한일 일지도 모릅니다. 예를들어, 컴퓨터가 "Bing!"을 할 수 없다고 정한 규칙이 있다면, 누가 "Bing!"할 수 없는 컴퓨터를 사용하길 원할까요?
[pic]

 "Bing!"하는 것처럼 외부 세계로 보여지거나, 화면에 다이얼로그 박스를 보여주거나 하는 코드를 side effect를 수반한다고 말합니다. 함수형 프로그래머들은 이와 같은 side effect가 여러분의 코드를 "더럽게dirty"만든다고 생각합니다.

 side effect를 포함하는 dirty code에 대한 기술적인 용어는 imperative code입니다. imperative란 용어는, "우선 이것을 하고, 다음에 저것을 해라"처럼 말하는,요리책(cookbook)에 있는 스타일로 코드가 작성되었다는 것을 암시합니다. 요리책과 같이, imperative코드에 있는 대부분의 라인은 화면에 표시하거나, 전역변수를 수정하는  side effect를 유발합니다. imperative code는 함수형 코드와 반대됩니다.

 이는 저희를 함수형 프로그래밍 철학 중심으로 이끌어 줍니다. 이는 여러분의 프로그램을 두 부분으로 나누어야 한다고 말합니다:

z 첫번째로, 가장 큰 부분은 완전한 함수형이며 side effect로부터 자유로워야 한다.
이는 프로그램의 순결한clean 부분입니다.
z 두번째로, 자그마한 부분으로 사용자와 외부 세계와 소통하는 side effect를 지닌 부분. 이 코드는 지저분dirty하며 가능한 작은 부분을 차지해야만 합니다.

 예를들어 다이얼로그 박스를 띄우는 코드조각이 있다면, 저희는 이것을 지저분하다 여겨 코드의 imperative 영역으로 추방시킵니다. 다이얼로그 박스와 같은 것들은 실제 수학이 아니며, 수학 함수와 다른 순수하고 함수형 코드에 넣으면 안됩니다.
[pic]


Anatomy of a Program Written in the Functional Style
 이제 저희는 함수형 프로그래밍을 어떻게 하는지를 다루었으며, 이 스타일을 따라 간단한 프로그램을 작성해 봅시다. 저희는 이 프로그램이 대부분의 소프트웨어의 대표적인 예가 되었으면 하기 때문에, 대부분의 소프트웨어에선 무슨 일을 하는지를 밝혀야 됩니다. 그럼 대부분의 프로그램은 실제 어떠한 일을 할까요? 그것들은 위젯widget의 track을 유지합니다!
[pic]

 여기 함수형 스타일로 작성된 전체 예제 프로그램이 있습니다:
[output]

 약속한대로, 이는 두 부분으로 나뉘었습니다: clean영역과 dirty 영역. 제가 프로그램의 clean영역이 dirty 영역보다 커야한다고 언급했었습니다. 그러나, 이 예제에서는 매우 짧기 때문에, dirty 영역이 조금 더 큽니다. 보통, 여러분은 clean 영역이 실제 코드의 80 퍼센트정도 된다는 것을 예상할 수 있습니다.

NOTE
 몇몇 프로그래밍 언어들은 Lisp보다 함수형 프로그래밍에 더욱 더 중점을 둡니다. 예를들어, Haskell은 99.9 퍼센트의 코드를 함수형 스타일로 작성하게 만드는 강력한 기능들을 가졌습니다. 그러나, 결국에 프로그램에 몇몇 side effect가 필요하게 될 것입니다; 그렇지 않으면, 여러분의 코드는 유용한 것이 될 수 없습니다.


 그럼 저희 예제 프로그램은 어떠한 일을 할까요? 대다수의 컴퓨터 프로그램은 어떠한 작업을 하도록 설계되었습니다: 데이터베이스에 있는 위젯의 트랙을 유지!

 이번 예제에 있는 데이터베이스는 매우 원시적입니다. 이는 전역 변수 *database*에 저장된 단순한 Lisp list입니다. 시작시 데이터베이스가 비어있어야 하므로, 변수를 초기화하고 비어있게 설정하였습니다.

 몇몇 widget들을 tracking하기 위해 main-loop함수를 호출할 수 있습니다. 이 함수는 단지 사용자에게 widget 이름을 뭍는 무한 loop를 시작합니다. 그런 다음 이것을 widget에서 읽어, 새로운 widget을 데이터베이스에 추가하기 위해 add-widget함수를 호출합니다

 그러나, add-widget함수는 코드의 clean 영역입니다. 이는 함수형이며 *database*변수를 직접 수정하지 않는다는 걸 의미합니다. 모든 함수형 코드처럼, add-widget함수는 새로운 값을 반환하는것 이상의 일을 하지 않습니다. 이는 데이터베이스에 widget을 "추가"할 수 있는 유일한 방법이 새로운-브랜드의 데이터베이스를 반환한다는 것을 의미합니다. 새로운 widget이 리스트 앞에 추가되었다는 것을 빼면, 새로운 데이터베이스는 이전에 것과 동일합니다
[output]

 얼핏 듣기에 이 소리가 얼마나 괴상한지 생각해 보십시요. 수백만개의 widget들을 포함하는 오라클 데이터베이스 서버를 운용하고 있다고 상상해보십시요:
[pic]

 새로운 widget을 추가하면 데이터베이스 서버는, 이전 데이터베이스를 복재하여, 기존것에 하나의 새로운 항목이 추가한 새로운-브랜드를 만듬으로써, 이를 수행할 것입니다:
[pic]

 이는 매우 비효율 적입니다. 그러나, 저희 widget예제에서 하는 일은 처음 보였던 것만큼 나쁘진 않습니다. add-widgets 함수는 매 호출시마다 새로운 widget 리스트를 생성하며, 이 함수를 반복하여 호출하여 리스트를 점점 길어지도록 만듭니다. 그러나, 모든 새로운 widget은 단순히 리스트 앞에 추가되기 때문에, 이 widget 리스트의 끝자락은 이전 리스트와 동일합니다. 때문에 add-widget 함수는, 단순히 하나의 새로운 widget을 리스트 앞으로 consing하고, 예전 리스트를 나머지 항목으로 남김으로써, 새로운 리스트를 만들때마다 "속임수를 씁니다". 이는 빠르면서 매우 적은 새로운 매모리 할당을 요구하는 방법으로 새로운 리스트가 만들어지도록 합니다. 사실 add-widget에 의해 할당된 새로운 매모리는 이전 리스트와 새로운 widget를 연결시키는 새로운 하나의 cons cell입니다.

 새로운 데이터 구조를 생성할때 이 "속임수"는 함수형 프로그래밍을 가능한 효율적으로 만들어주는 key technique입니다 더욱이, 안전하게 구조를 공유하는 것은, 이전 데이터 조각을 절대로 수정하지 말라는 함수형 프로그래밍의 교리중 하나입니다.

 따라서 저희 add-widget 함수는 추가 항목이 추가된 새로운 데이터베이스를 생성합니다. 코드의 dirty 영역에 있는 main-loop함수는 전역 변수 *database*를 이 새로운 데이터배이스와 동일하게 설정합니다. 이러한 과정속에서, 간접적으로 두가지 단계로 데이터베이스를 수정하였습니다:

1. add-widget 함수는 기본적으로 업데이트된 데이터베이스를 생성해주는 프로그램의 뇌이다.

2. dirty한 일을 맡고있는 main-loop함수는 작업을 완료하기위해 전역 변수 *database*를 수정한다.

 이 예제 프로그램은 함수형 스타일로 작성된 Lisp 프로그램의 기본 구성을 설명합니다. 저희 새로운 프로그램이 하는 일을 살펴봅시다:
[output]

 CTRL-C를 눌러 이번 예제의 무한 loop에서 빠져나올수 있습니다.


Higher-Order Programming
 프로그래머가 함수형 스타일의 프로그램을 작성하는 법을 배울때 하나의 걸림돌은, 다양한 코드 덩어리를 하나의 행동을 수행하도록 묶는것이 어렵다는 것입니다. 이를 code composition이라 합니다. 프로그래밍 언어는 code composition을 쉽게 행해야 합니다. 다시말하자면, 이는 다양한 코드 조각을 모아서 문재를 쉽게 해결할 수 있도록 합니다. 함수형 코드를 작성할때 code compositon을 위한 가장 강력한 도구는, 다른 함수를 인자로 취하는 함수를 허용하는 higher-order 프로그래밍입니다.

 왜 초급 함수형 프로그래머에게 code compositon이 난관인지 이해하기 위해, 예제를 살펴봅시다. 다음 리스트에 들어있는 각 수에 2씩 더한다고 가정해봅시다:
[output]

 이러한 일을 하기위해, 리스트를 훑는traverse 코드와 수에 2를 더하는 코드를 작성해야합니다. 저희가 구성해야할 작업으로는 두가지가 있습니다.


Code Composition with Imperative Code
 이 작업을 하기 위한 가능한 naive(그리고 imperative)한 방법으론 loop를 이용하는 것입니다:
[output]

 여기서 저희는 loop에서 리스트에 있는 모든 항목을 세는 변수 n을 만들었습니다. 그런 다음 setf를 이용하여 리스트의 n지점에 있는 수에 2를 더하였습니다. 이는 C프로그래머였다면 작성해본 정렬 코드와 유사합니다. 이는 매우 못생겼지만ugly, 이것에 대해 언급할수 있게 되었다는 긍정적인 면이 있습니다:

z 이러한 코드 구조는 잠재적으로 매우 효율적이다. 새로운 리스트를 저장하기 위해 매모리를 할당할 필요가 없기(모든 숫자들을 2씩 증가하기 위해 예전 리스트를 못쓰게 만듭니다) 때문에, 이는 공간효율적space-efficient입니다. 그리고 또한, 이 loop를 리스트(리스트에 있는 항목을 찾는 nth는 느립니다) 대신 배열에 대해 작동하도록 다시 작성한다면,이는 매우 시간절약적time-efficient이 될 수 도 있습니다.

z 이와 같이 작성된 코드는 looping작업과 2씩 더하는 작업으로 깔끔하게 구성된다. loop내부에 덧셈하는 코드를 넣음으로써, 더욱 복잡한 일을 하기 위해 이 두가지 활동을 구성할 수 있습니다: 전체 리스트의 수에 2씩 더함.

 그러나, 이러한 imperative 접근에는 어두운면도 분명 존재합니다:

z 기존 리스트를 망친다. 이는 후에 *my-list*변수를 사용할 때 문제가 되며, 이 코드가 이 리스트에 있는 기존 값들을 망친다는 사실을 놓치고 있습니다. Lisper는 *my-list*란 변수는 좋든 싫든 프로그램에 hidden state조각으로 변경된다고 말합니다. imperative-스타일 프로그래밍을 장려하는 프로그래밍 언어에서 hidden state에 관련된 버그들이 만연합니다.

z 저희는 리스트의 위치를 찾기위해 변수 n를 만들어야합니다. 이는 코드를 비대하게 하며 버그가 숨어들수 있는 장소를 제공합니다. 거기에는 항상, 잘못된 값을 넣거나 리스트의 항목에 부적절하게 접근하는, 위험이 도사리고 있습니다.


Using the Functional Style
 이제 이 코드를 함수형 스타일로 다시 작성하면 어떤 일이 일어나는지 살펴봅시다. 우선, 초급 함수형 프로그래머가 하듯 higher-order 프로그래밍을 사용하지 않고 작성합니다:
[output]

 여기서, 저희는 리스트의 앞에 있는 수에 2를 더하는 add-two 함수를 만들었으며, 리스트의 꼬리tail을 만들기 위해 재귀적으로 호출하였습니다

 이 코드는 imperative solution의 수많은 어두운 면을 피해갑니다. 기존 리스트를 파괴하지 않으며, 인덱스 사용이 필요하지 않습니다. 불행히도, 이는 imperative의 중대한 이점을 노치고 말았습니다: 리스트의 항목에 2를 더하는 코드와 리스트를 순회하는 코드 간의 차이를 명확히 묘사하지 못하게 됩니다. 이 두 활동은 지금 서로 깊게 연관되어 있어, 이 문제를 해결하기 위해 특별한 add-two함수를 만들어야 합니다. 저희는 이 두 작업을 clean한 방식으로 구성하는 능력을 잃어버리고 말았습니다.


Higher-Order Programming to the Rescue

 만일 이 작업을 코드를 구성하는게 가능한 함수형 스타일로 작성하기 원한다면, higher-order 함수를 사용해야만 합니다. 여기 숙련된 Lisp가 어떻게 리스트에 있는 모든 수에 2를 더하는지가 나와있습니다:
[output]

 이제 저희는 함수형이며 더하는 코드와 순환하는 코드를 구성하는 코드를 지녔습니다. 여기서 순환은, 리스트에 있는 모든 멤버에 함수를 적용하는 higher-order함수인 mapcar 함수에 의해 수행됩니다. 덧셈은 수에 2를 더하는 역활을 맡으며 리스트에 수가 있다는 사실을 인지하지 못하는 lambda함수에 의해 수행됩니다. 이 예제는, 함수형 스타일을 깰 필요없이 higher-order 프로그래밍이 코드 덩어리를 깔끔하게 기술하며 구성할 수 있다는 것을 보여줍니다.


Why Functional Programming Is Crazy
 저희는 이미 왜 함수형 프로그래밍이 crazy인지에 대한 원인 하나를 알고 있습니다: 함수형 프로그램은 side effect를 가지지 않기 때문에 실제로 어떠한 일도 할 수 없습니다. 잘 알려진 함수형 프로그래머 Simon Peyton Jones는 다음 처럼 말했습니다 "side effect없이 할 수 있는 일은 버튼을 누르고 박스가 뜨거워질동안 지켜보는 것이다"(뜨거워 진다는것 자체가 side effect이기 때문에, 이는 기술적으로는 옳지 않습니다)

 저희는 코드의 나머지로부터 분리되며, imperative이며 함수형 스타일이 아닌 코드를 포함한 프로그램에 dirty 영역을 추가함으로써, 함수형 프로그래밍의 한계를 넘어설 수 있다는 것을 보았습니다. 그러나, 함수형 스타일의 문제점을 회상해봅시다: 이는 코드를 극도로 비효율적이 되도록 만드는 경향이 있습니다.

 성능은 항상 함수형 프로그램의 주된 관심입니다. 새로운 변수를 생성하지 않고 이미 존재하는 변수의 값을 mutate하는 코드를 작성하는 것은, 프로그램을 몹시 느리게 만드는 막대한 양의 메모리 복사와 할당을 야기합니다. 이 복사와 할당을 피하는 방법으로는, 다양한 데이터 조각의 구조를 공유하는 것입니다.

 그럼에도 불구하고, 함수형 스타일로 작성된 코드는 성능적인 측면에서 다른 속성을 가집니다. 예를들어, 함수형 코드는 looping대신 수많은 재귀recursion를 이용합니다. 재귀의 사용은 Lisp 컴파일러/인터프리터가 성능 저하를 야기하는 프로그램 스택에 수많은 항목을 넣게 합니다.

 다행히도, 함수형 프로그래머는 막대한 성능 문제를 해결할 수 있는 최적화 기법을 개발하였습니다. 이는 다음에 나올 몇몀 장에서 다룰 memoization, tail call 최적화, lazy evalution, 그리고 higher-order 프로그래밍을 포함합니다. 이러한 기술과 다른 것들을 이용하여, 숙련된 함수형 프로그래머는 성능 면에 있어  어떤 스타일로 작성된 코드와도 견줄만한 코드를 작성할 수 있습니다

 그러나, 몇몇 프로그램의 형식은 순수하게 함수형 방식으로 적성될 수 없습니다. 예를들어, 함수형 스타일로 데이터베이스 시스템과 관련하여 최고인 오라클-스타일과 같은 것을 짤 수는 없을 것입니다. 그렇지만, 작고 메모리-거주resident 데이터베이스 시스템에서는 순수 함수형 기술들을 이용할 수 있습니다 (한 예로 하스켈 프로그래머의 HAppS-IxSet(http://happs.org/)가 있습니다). 따라서, 실제 함수형 프로그래밍을 사용함에 있어 제한은 없습니다(no hard limit).


Why Functional Programming Is Fantastic

 이제 여러분이 궁금해할 함수형 프로그래머가 견뎌야만하는 고민거리에 대해 말할 것입니다. "누가 왜 이런 방식으로 프로그램을 못살게 굴까?" 그 답은 함수형 프로그래밍은 이러한 골치아픔을 날려버릴 많은 매력적인 이점을 가지고 있기 때문입니다.


Functional Programming Reduces Bugs

 컴퓨터 프로그램의 버그는, 코드가 작성됬을때 어느 특정한 환경에 놓여진 코드가 프로그래머가 예상할수 없는 방식으로 행하는 경우가 종종 발생하게 됩니다. 함수형 프로그래밍에서 함수의 행동은 하나 오직 하나에 의존합니다: 인자들은 분명하게explicityly 함수를 통과합니다. 이는 프로그래머에게, 에러를 유발시킬 수 있는 환경을 포함하여, 프로그램이 가능한 마주칠 수 있는 모든 환경을 쉽게 만들어 줍니다.

 인자에 기반하여 함수를 작성하는것은 또한 쉽게 중복되는 버그를 만듭니다. 동일한 데이터를 인자로 넣어 함수를 호출하면, 이는 매번 동일한 일을 해야만 합니다. 이러한 속성을 referential transparency라 부릅니다.



Functional Programs Are More Compact
 생성과 초기화, 그리고 변수 업데이트와 관련된 지극히 평범한run-of-the-mill 컴퓨터 프로그램의 수많은 일들이 있습니다. 함수형 프로그램은 이러한 일을 하지 않습니다. 전에 다루었듯이, 함수형 프로그램을 코드에서 임시 변수를 만들 필요가 없는 higher-order 함수를 이용하여 만들었고, 그럼으로써 저희 코드는 더욱 작아졌습니다compact.


Functional Code Is More Elegant
 함수형 프로그래밍의 가장 큰 이점은 컴퓨터 프로그래밍의 모든 것을 수학의 영역으로 돌려놨다는 것입니다. 다이얼로그 박스를 팝업하거나 하드드라이브에 작성하는 일은 수학 방정식과는 맞지 않습니다. 컴퓨터 코드를 이와 같은 순수 레벨로 돌릴 수 있다면 더욱 우아해 질것이라고
주장할 수 도 있을 것입니다. 추가로, 여러분의 코드가 수학의 세계와 가까워진다면, 더 좋은 컴퓨터 코드를 작성하기 위해 수학적 도구로 사용할 될 있습니다.

 사실, 함수형 컴퓨터 프로그램의 적절성을 확인하기위해, 많은 연구가 수학적 증명을 사용하고 있습니다. 비록 이 연구가 현실적인 프로그래머가 그와 같은 기술을 사용할 단계까지 오진 못했지만, 아마 미래에는 더욱 보편화 될 것입니다. 그리고, 아마 틀림없이 함수형 프로그래밍 스타일은 여러분의 코드가 올바른지 증명하는데 있어 필수적이 될 것입니다


What You’ve Learned
 이번 장에서, 저희는 함수형 프로그래밍을 다루었습니다. 이러한 과정속에서, 다음 내용들을 배웠습니다:

z 함수형 스타일로 작성된 프로그램은 인자로 동일한 값을 주었을때 항상 동일한 결과를 내보낸다.
z 함수형 프로그래밍은 side effect를 포함하지 않는다. 일생동안의 목표는 단지 값을 계산하여 반환하는 것입니다.
z 함수형이 아닌 프로그램은 보통 "우선 이걸하고, 다음으로 저걸해라" 하는 요리책cookbook처럼 읽힌다. 이러한 스타일의 프로그래밍을 imperative 프로그래밍이라 부릅니다.
z Lisp 프로그램을 작성하는 좋은 전략으로는 clean한 함수형 부분과 dirty한 imperative한 부분으로 쪼개는 것이다.
z 함수형 프로그램은, 특히 숙련된 함수형 프로그래머의 손에서, 더욱 작고 더 적은 버그를 갖도록 매우 빠르게 작성될 수 있다.