LAZY PROGRAMMING

14장에서, 여러분은 여러분의 프로그램이 clean, math-like 함수로 만들어 질때 단순하고 깔끔하게 만들 수 있다는 것을 배웠습니다

오로지 인자에 기반한 이러한 함수는 항상 동일한 결과를 반환합니다

 이러한 함수의 종류에 의존한다면, 여러분은 함수형 프로그래밍 스타일을 이용하는 것입니다.

 그러나, 15장에서 Dice of Doom게임을 만들기 위해 함수형 프로그래밍 스타일을 이용하였을때, 문제는 분명해졌습니다: 함수가 전적으로 인자에 기반하면, 이에 통과시킬 무언가가 커지게 된다는 것입니다.

Dice of Doom게임에서, 저희는 모든 가능한 게임 보드의 미래 상태를 지닌 game-tree 변수를 전달했습니다.

 쥐꼬리만한 3x3 보드라 할지라도, 이는 실제로 거대한 구조입니다!

 따라서 게임의 현재 디자인은 여러분의 코드를 매우 단순하고 우아하게 만드는 반면, 기하급수 적으로 커지는 게임 트리를 갖는 거대한 게임 보드의 크기를 잘 조정하는 것처럼 보이진 않습니다.

 저희가 생각할 수 있는 우아한 코드를 유지하며 큰 보드에서의 더욱 복잡한 게임을 허용하는 하나의 방법은, 게임 시작부분에서 모든 가능성있는 move를 곧바로 보지 않도록 저희 프로그램을 충분히 영리하게 만드는 것입니다.

 이것이 가능할까요?

물론, 이는 lazy evaluation 기법을 이용하면 가능합니다.

 이번 장에서, 저희는 향상된 Dice of Doom을 만들기 위해 lazy evaluation을 사용할 것입니다


Adding Lazy Evaluation to Lisp
 lazy evaluation에서 저희는 여전히 저희 코드의 한 곳에서 전체 게임 트리를 만들 수 있습니다 - 게임 시작 부분에서.

 그러나, 저희는 기발한 트릭을 이용하였고, 몇몇 게임 트리의 가지는 구름속으로 숨겨졌습니다:
[pic]

 게임 트리 가지는 여전히 시작부분에서 바로 선언되었습니다.

 그러나, 저희는 구름속에 있는 가지들에 대한 계산을 수행하는데 애쓰지는 않고, 대신 저희는 "실제" 가지를 만들때 이를 수행합니다.

 이것이 lazy evaluation의 lazy part 입니다.

 대신, 저희는 누군가가 구름낀 가지를 "살펴"보는지를 기다립니다.

 이게 일어나는 순간, 팟!하고, 저희는 그 지점에 실제 게임 트리의 가지를 생성합니다:
[pic]

이는 게임 트리에 있는 이러한 가지가, 코드의 어떤 부분이 이를 살펴보는 경우에만, 생성된다는 것을 의미합니다.



 플레이어가 게임에서 특정 move를 선택하지 않는다면, AI는 이에 대항하기 위한 결정을 내리지 않을 것이며, 저희 프로그램은 게의르게도 주어진 가지가 실제로 어떻게 보여지는지 밝혀내는데 필요한 계산을 하지 않을 것입니다.


Haskell과 Closure Lisp와 같은 몇몇 언어는, 언어의 핵심 부분으로 lazy evaluation을 지원합니다.


 사실, Closure는 이의 사용을 독려하며, 함수형 프로그래밍에 있어 이게 얼마나 유용한지를 clearly하게 보여줍니다

그러나, ANSI Common Lisp 표준은 lazy evaluation와 유사한 어떠한 기법도 포함하지 않습니다.

다행스럽게도, Common Lisp의 강력한 매크로 시스템으로, 저희는 쉽게 저희 스스로 이러한 기법을 언어에 추가할 수 있습니다!


Creating the lazy and force Commands

저희가 만들 lazy evalution을 위한 가장 기본적인 명령어는 lazy와 force입니다

 lazy 명령어는 코드 조각을 둘러쌀 수 있게하며, Lisp에게 이 처럼 게의른 방식으로 코드가 평가되길 원한다고 말하는 wrapper가 될 것입니다:
[REPL]

보시다시피, 컴퓨터는 1 더하기 2의 값을 계산하려 하지 않습니다

대신, 이는 단순히 함수를 반환합니다.

 실제 계산 결과를 얻기 위해선, lazy 값에서 다른 기본 lazy evalution 명령어를 호출해야합니다:
[REPL]

중요한 것은 lazy 값이 생성됬을 때가 아니라, force됬을때 계산이 수행됬다는 것입니다.

이러한 case를 이해하기 위해, 더욱 복잡한 예제를 살펴 봅시다:

[REPL]

 여기 저희가 만든, 덧셈이 일어나면 부수 효과로 콘솔에 메시지를 출려하는, add 함수가 있습니다

다음으로, 게의르게 함수로 두 숫자를 더하고 결과를 변수 *foo*에 저장합니다.

 그리고 나면, "I am adding now"라는 메시지가 보이지 않기에, 저희는 덧셈이 실제로 발생하지 않았다는 것을 알게됩니다

그 다음으로 저희는 변수를 force합니다.
변수를 force하면, 계산이 실제로 수행되며, 3이란 결과가 반환됩니다.


 저희는 lazy 값을 force하여, 메시지가 콘솔에서 출력되었을때 덧셈이 발생한다는 것을 알 수 있습니다.

여기 간단한 lazy의 구현을 위한 코드가 있습니다:
[source]


저희는 매크로를 선언하여 lazy를 구현하였습니다.
이 매크로는
두 변수가 필요합니다
코드에서


This macro will require two 
variables in the code it generates. We need to declare these as gensym names Y, 
as discussed in Chapter 16. Next, we begin generating the code that the 
macro will output Z (note the backquote at the beginning of this line).

At the top of the code generated by the macro is a declaration for two 
local variables, using the gensym names we created Z. The first variable tells us 
whether this lazy value has been forced yet Z. If it is nil, the value can hide in 
a cloud.

 If the variable is true, the value is no longer hidden in a cloud, because 
it has been forced.


Once the value has been calculated through a call to force, we store the 
resulting value in another variable, though initially this value isn’t used and is 
set to nil [.

 When our lazy macro is called, we want it to return a function, 
which can be called at a later time to force our lazy value to return a result. 
Therefore, we declare a lambda function next \.


Remember that any local variables declared outside this lambda function 
will be captured by the function as a closure. This means that the local vari-
ables above Z[ will persist between subsequent calls of the lambda function. 
Why does this matter? Well, once the cloud goes POOF!, we have completed 
all the work to calculate a value, and we don’t want to do it again when the 
lazy value is forced and checked again multiple times in the future. We can 
avoid this by remembering the value after the first force here [ between calls.
When our lazy value is forced (by calling the lambda function we created), 
the first question we must ask ourselves is whether it has been forced already 
or is still hidden behind the cloud ]. For a value that has not yet been forced, 
we go POOF! and perform the lazy calculation ^, and save it as our value. We 
also mark it as having been forced _. Now the cloud has been destroyed.
