SECTION III
Lisp Is Hacking

LOOP AND FORMAT: THE SEEDY UNDERBELLY OF LISP

 이전에, 저희는 Common Lisp 언어의 core를 살펴보았고 간결함과 우아함에 감명을 받았습니다. 그러나 이 core 주변에는 어떤 매력을 지닌 Lisp의 어둡고 초라한 면도 있습니다. 그들이 Lisp core의 아름다움을 회손할지도 모르지만, 그들의 파워로 이것을 쉽게 보상합니다. 이러한 언어의 부분은 budding Lisp hacker에게 있어 진정한 즐거움입니다

 loop와 format, 이 확장을 이번 section에서 다룰것이며, 수학적인 우아함을 넘어설 강력한 힘에 중점을 두겠습니다. Lisp 프로그래머들 사이에서 이것은 종종 논란을 야기하며, 이 명령어들에 의해 어떤 힘이 제공되는지 묻는 이들은 우아함에 있어 상반관계가 있는지 걱정합니다. 이러한 프로그래머들은 어떤 중대한 code를 작성할때 loop와 format를 피해야 한다고 믿습니다.

 그러나 이 명령어들을 사용하고 배워야하는 중요한 이유가 있습니다: 이것들은 Lisp의 유연함과 확장성 포함하고 있습니다. Lisp가 (거의 틀림없이) 가장 유연한 프로그래밍 언어이기 때문에, hacker들은 수십년동안 수천개의 그들의 hack로 이것을 확장시켜 왔습니다. 이러한 성공적인 확장의 중간에 서있는 loop와 format는 Darwinian battlefield에서 살아남는 것에서 진정한 장관을 이룰 것입니다.


LOOPING WITH THE LOOP COMMAND

loop와 format명령어는 강력하고 hacker-friendly합니다. 이들이 제공하는 대다수의 기능들은 Lisp언어에서 다른 방면으로 이용가능하며, 간결한 code를 좋아한다면 이러한 상당히 특화된 명령어를 배울 가치가 있습니다. 이번장에서 loop에 대해 살펴 볼 것입니다. 다음 장에서는 format에 대해 다룰 것입니다.


The loop Macro

 컴퓨터 프로그램에서 여러분이 원하는 어떠한 looping 타입이라도 loop macro로 할 수 있습니다. 여기 간단한 예제가 있습니다:
[source]

 이 code는 5보다 작은 자연수를 다음처럼 모두 더합니다:

 0 + 1 + 2 + 3 + 4 = 10

 이 loop 명령어 Lisp명령어가 해야하는 적절한 방법으로 일을 처리하지 않는다는 것을 볼 수 있습니다. 무엇보다도 이것은 장애가 있습니다.(First of all, it’s parenthetically challenged.) 한줄에 괄호 없이 일곱개의 토큰이 가진것을 전에는 한번도 본적이 없습니다!
[pic]

#BEGIN================
What makes it even less Lispy is that some of these extra tokens (for, below, 
and sum) appear to have special meanings.

3장을 회상하여
form에 있는 첫번째 토큰

 Recall from Chapter 3 that the first 
token in a form (the one immediately after the opening parenthesis) is typi-
cally what decides the basic behavior of the code, while the rest of the form 
contains parameters.

loop macro에서는
"magic tokens"

 Within the loop macro, several of these “magic tokens” 
fundamentally affect the loop’s behavior.

 Here’s what they mean:

z 값의 범위를 통해 iterate할 변수를 선언하는 것을 허용한다. 기본적으로 0부터 시작하는 정수로 카운트를 할 것입니다.

z below tells the for construct to halt when it reaches the specified value (in 
this case, 5), excluding the value itself.

주어진 표현식의 모든 값들을
z sum adds together all values of a given expression (in this case, the expres-
sion is just i) and makes the loop return that number.


Some loop Tricks
The loop macro has a veritable cornucopia of special tokens that make just 
about any kind of behavior possible. Let’s look at some of the possibilities.


Counting from a Starting Point to an Ending Point
By using from and to clauses, you can make the for construct count through 
any specific range of integers:
[source]


Iterating Through Values in a List
In the following example, we iterate through values in a list using the in token:
[source]


doing Stuff in a Loop
The do token takes an arbitrary expression and executes it inside the loop:
[source]


Doing Stuff Under Certain Conditions
The when token lets you run the following part of the loop only as needed:
[source]


Notice that only the sum of the odd numbers is returned.

Breaking out of a Loop Early
The following loop uses several new tricks:
[source]

Notice that there’s nothing in the for part of the loop that tells it to stop 
counting numbers?it goes from zero off to infinity. However, once we reach 
5, the when clause triggers the loop to immediately return the value 'falafel.
Collecting a List of Values
The collect clause lets you return more than one item 
from the loop, in the form of a list. This command is 
useful when you need to modify each item in a list, as 
in the following example:
[source]
[pic]

Using Multiple for Clauses
It’s possible for a loop macro to have 
more than one for clause. Consider 
the following example:
[source]
[pic]

How many numbers do you think will be returned as a result? There are 
two possibilities: Either it increments x and y at the same time and returns a 
list of 10 items, or it iterates x and y in a nested fashion and returns 100 num-
bers. The answer is the former:
[source]

As you can see, both numbers incremented at the same time between 0 
and 9.
If there are multiple for clauses in a Common Lisp loop, each one will be 
checked, and the loop will stop when any one of the clauses runs out of values. 
This means that for clauses do not loop independently across multiple looping 
variables, so if you loop on two ranges of 10 values each, it will still just loop 
10 times.
However, sometimes you want to generate the Cartesian product between 
multiple ranges. In other words, you want a loop to run once for every possi-
ble combination of two or more ranges. To accomplish this, you need to use 
nested loops for x and y:

[source]
In this case, we’ve created 10 lists of 10 items each, looping for a total of 
100 items. 
Also, notice that using a for variable starting at zero, such as the i variable 
in the following example, provides a clean way to track the index number of 
items in a list:

[source]
You might think we’ve covered every conceivable variation of looping at 
this point. If so, you are gravely mistaken. Behold! The Periodic Table of the 
Loop Macro!

[pic]
[pic]
Everything You Ever Wanted to Know About loop
The individual examples we’ve discussed so far give only the briefest hint of 
the full capabilities of loop. But fear not! You now have the world’s first and 
only Periodic Table of the Loop Macro. Just tape it to your monitor, glue it to 
your wallet, or laser-etch it directly into your retina, and you’ll be guaranteed 
to reach loop proficiency in no time!
Almost every legal command that can be used in a loop macro is covered 
by the periodic table. It shows how to manipulate hash tables and arrays, and 
perform special looping operations. Each square in the periodic table contains 
an example. If you run the example, you should be able to figure out the 
behavior of the given command.
Using loop to Evolve!
[pic]

Let’s create another game, making full use of loop. But this won’t be a game 
that we play. Instead, it will be a game world that evolves as we watch it! We’re 
going to create an environment of steppes and jungles, filled with animals 
running around, foraging, eating, and reproducing. And after a few million 
units of time, we’ll see that they’ve evolved into different species!
NOTE This example is adapted from A.K. Dewdney’s article “Simulated evolution: wherein 
bugs learn to hunt bacteria,” in the “Computer Recreations” column of Scientific 
American (May 1989: 138-141).
[pic]
Our game world is extremely simple. It consists of a simple rectangular 
plane, with edges that wrap around to the opposite side. (Mathematically 
speaking, it has a toroidal topology.) Most of this world is covered in steppes, 
meaning that very few plants grow for the animals to eat. In the center of the 
world is a small jungle, where plants grow much faster. Our animals, who are 
herbivores, will forage this world in search for food.
Let’s create some variables describing the extent of our world:
[source]


We’re giving the world a width of 100 units and a height of 30 units. Using 
these dimensions should make it easy to display the world in our Lisp REPL. 
The *jungle* list defines the rectangle in the world map that contains the jun-
gle. The first two numbers in the list are the x- and y-coordinates of the jungle’s 
top-left corner, and the last two numbers are its width and height. Finally, we 
give the amount of energy contained in each plant, which is set to 80. This 
means that if an animal finds a plant, it will gain 80 days’ worth of food by 
eating it.
NOTE If your terminal window isn’t large enough to display the entire world, change the val-
ues of the *width* and *height* variables. Set the *width* variable to the width of your 
terminal window minus two, and the *height* variable to the height of your terminal 
window minus one.

#END