
SECTION III
Lisp Is Hacking

LOOP AND FORMAT: THE SEEDY UNDERBELLY OF LISP

 이전에, 저희는 Common Lisp 언어의 core를 살펴보았고 간결함과 우아함에 감명을 받았습니다. 그러나 이 core 주변에는 어떤 매력을 지닌 Lisp의 어둡고 초라한 면도 있습니다. 그들이 Lisp core의 아름다움을 회손할지도 모르지만, 그들의 파워로 이것을 쉽게 보상합니다. 이러한 언어의 부분은 budding Lisp hacker에게 있어 진정한 즐거움입니다

 loop와 format, 이 확장을 이번 section에서 다룰것이며, 수학적인 우아함을 넘어설 강력한 힘에 중점을 두겠습니다. Lisp 프로그래머들 사이에서 이것은 종종 논란을 야기하며, 이 명령어들에 의해 어떤 힘이 제공되는지 묻는 이들은 우아함에 있어 상반관계가 있는지 걱정합니다. 이러한 프로그래머들은 어떤 중대한 code를 작성할때 loop와 format를 피해야 한다고 믿습니다.

 그러나 이 명령어들을 사용하고 배워야하는 중요한 이유가 있습니다: 이것들은 Lisp의 유연함과 확장성 포함하고 있습니다. Lisp가 (거의 틀림없이) 가장 유연한 프로그래밍 언어이기 때문에, hacker들은 수십년동안 수천개의 그들의 hack로 이것을 확장시켜 왔습니다. 이러한 성공적인 확장의 중간에 서있는 loop와 format는 Darwinian battlefield에서 살아남는 것에서 진정한 장관을 이룰 것입니다.


LOOPING WITH THE LOOP COMMAND

loop와 format명령어는 강력하고 hacker-friendly합니다. 이들이 제공하는 대다수의 기능들은 Lisp언어에서 다른 방면으로 이용가능하며, 간결한 code를 좋아한다면 이러한 상당히 특화된 명령어를 배울 가치가 있습니다. 이번장에서 loop에 대해 살펴 볼 것입니다. 다음 장에서는 format에 대해 다룰 것입니다.


The loop Macro

 컴퓨터 프로그램에서 여러분이 원하는 어떠한 looping 타입이라도 loop macro로 할 수 있습니다. 여기 간단한 예제가 있습니다:
[source]

 이 code는 5보다 작은 자연수를 다음처럼 모두 더합니다:

 0 + 1 + 2 + 3 + 4 = 10

 이 loop 명령어 Lisp명령어가 해야하는 적절한 방법으로 일을 처리하지 않는다는 것을 볼 수 있습니다. 무엇보다도 이것은 장애가 있습니다.(First of all, it’s parenthetically challenged.) 한줄에 괄호 없이 일곱개의 토큰이 가진것을 전에는 한번도 본적이 없습니다!
[pic]

 이것이 Lispy가 아닌것처럼 만드는 것은 이 추가 토큰들이(for, below, 그리고 sum) 특별한 의미를 지니는 것 처럼 보인다는 것입니다. 3장을 회상하면 form에 있는 첫번째 토큰은 전통적으로 code의 기본 속성을 결정하며, 반면 form의 나머지 것들은 인자들을 포함하고 있습니다. loop macro에서는 이 "magic tokens"이 근본적으로 loop의 행동에 영향을 미칩니다. 여기, 이게 무엇을 의미하는지가 나와 있습니다:

z for는 값의 범위를 통해 iterate할 변수를 선언하는 것을 허용한다. 기본적으로 0부터 시작하는 정수로 카운트를 할 것입니다.
z below는 특정 값(이번 경우에는 5)에 도달할때 멈추어 그 자신의 값을 제외한다고 for에게 말한다.
z sum은 주어진 표현식의 모든 값들을 더하여 loop가 그 수를 반환하도록 한다.


Some loop Tricks

 loop macro는 어떤 종류의 행동이라도 가능하게 해주는 특별한 토큰들의 cornucopia를 가졌습니다. 몇몇 가능성들을 살펴봅시다


Counting from a Starting Point to an Ending Point

 from과 to 절을 이용하여, for 구조가 특정한 정수 범위를 셀수 있도록 만들 수 있습니다:
[source]


Iterating Through Values in a List

 다음 예제에서, in 토큰을 사용하여 list에 있는 값을 통해 iterate하였습니다:
[source]


doing Stuff in a Loop
 do 토큰은 임의의 표현식을 받아 loop내부에서 이것을 실행합니다:
[source]


Doing Stuff Under Certain Conditions

 when 토큰은 다음 loop의 일부분을 필요하다면 실행하도록 합니다:
[source]

 홀수의 합이 반환되었다는 것을 알립니다.


Breaking out of a Loop Early

 다음 loop는 몇몇 새로운 트릭을 사용하였습니다:
[source]

 숫자 카운팅을 멈추도록 말하는 Loop의 일부분이 없다는 것을 알립니다 - 이것은 0부터 무한으로 나아갈 것입니다. 그러나 5에 도달하게되면, when 절이 loop가 즉시 값 'falafel을 반환하도록 만듭니다.


Collecting a List of Values

 collect 절은 list form으로 loop로부터 하나의 항목보다 더 반환하도록 만듭니다. 이 명령어는 다음 예제처럼 list에 있는 각 항목을 수정할 필요가 있을때 유용합니다:
[source]
[pic]

Using Multiple for Clauses

 loop macro는 하나 이상의 절을 갖는게 가능합니다. 다음 예제를 잘 살펴봅니다:
[source]
[pic]

 얼마나 많은 숫자가 결과로 반환된다고 생각하십니까? 여기 두 가능성이 있습니다: x와 y를 동시에 증가시키며 10개의 항목이 있는 list를 반환하거나, x와 y를 중첩하여 순환시키며 100개의 숫자를 반환하거나. 정답은 전자입니다:
[source]

 보시다시피, 두 수 모두가 동시에 0부터 9까지 증가하였습니다.

 Common Lisp loop에 다수의 for 절이 있다면, 각각 점검checked될 것이며, loop는 어떤 절중 하나가 값을 반환할때 멈출 것입니다. 이것이 의미하는 것은, for절이 다수의 looping 변수들과 독립적으로 loop하지 않는 다는 것을 의미하며, 각각의 두 값 10의 범위를 loop한다면, 10번만 loop 할 것입니다.

 그러나, 종종 다수의 범위사이에서 데카르트 곱(the Cartesian product)을 생성하기 원합니다. 다시말하자면, 모든 가능한 두개 혹은 이상의 범위 조합을 위해 한번만 실행하는 loop를 원합니다. 이것을 하기 위해선, 중첩된 loop for x와 y가 필요합니다:
[source]

 이번 경우에, 모두 100개의 항목들을 looping하면서 각각 10개의 항목을 지닌 10개의 리스트를 만들었습니다.

 또한, 다음 예제에서 i 변수와 같은 0부터 시작하는 변수를 사용하여, list에 있는 항목들의 색인 숫자를 추적할 깔끔한 방법을 제공하였다는 것을 알립니다.
[source]

 이 지점에서, 가능한 모든 looping 변종들을 다루었다고 생각할지도 모릅니다. 만약 그렇다면, 중대한 실수를 하였습니다. 보십시요! Lisp Macro의 주기율표를!
[pic]
[pic]

Everything You Ever Wanted to Know About loop

 이전에 저희가 다루었던 믿지못할 예제들은 단지 loop의 전체 능력중에서 작은 정보일 뿐입니다. 그러나 겁먹지 마십시요! 이제 여러분은 세계에서 처음이자 유일한 Loop Macro의 주기율표를 가졌습니다. 단순히 이것을 여러분의 모니터에 입력하기보다는, 지갑에 이것을 붙이거나, 레이저로 이것을 여러분의 망막retina에 세긴다면, 단숨에 loop에 숙달되는 것이 보장됩니다!

 loop macro에서 사용할 수 있는 모든 합법적인 명령어의 대다수는 이 주기율 표에서 다루어졌습니다. 이것은 어떻게 해쉬 테이블과 배열을 조작하는지, 특별한 lopping 연산을 수행하는지를 보여줍니다. 이 주기율표에 있는 각 네모칸들은 하나의 예제를 포함하고 있습니다. 이 예제를 실행한다면, 주어진 명령어의 행동을 밝혀낼 수 있을 것입니다
 

Using loop to Evolve!
[pic]
#BEGIN=============================================

loop를 사용하여 만들어진 또 다른 게임을 만들어 봅시다.
이것은 저희가 진행할 수 있는 게임이 아닙니다.
대신에, 이것은 진화하는 게임 세계가 될 것이며 저희는 그걸 지켜봅니다!

Let’s create another game, making full use of loop. But this won’t be a game 
that we play. Instead, it will be a game world that evolves as we watch it! 


We’re going to create an environment of steppes and jungles,
 filled with animals 
running around, foraging, eating, and reproducing.

몇 백만 시간이 흐른후에, 다른 종으로 진화한걸 볼 수 있을 것입니다.

NOTE
 이 예제는 Scientific American에 "Computer Recreations" 칼럼에 실린
A.K. Dewdney의 글 "Simulated evolution: wherein bugs learns to hunt bacteria"에서 체택되었습니다(May 1989: 138-141)..
[pic]

저희 게임 세계는 매우 간단합니다.
간단한 사각형 평지로 이루어졌습니다

 It consists of a simple rectangular 
plane, with edges that wrap around to the opposite side. (Mathematically 
speaking, it has a toroidal topology.)


 Most of this world is covered in steppes, meaning that very few plants grow for the animals to eat. In the center of the 
world is a small jungle, where plants grow much faster. Our animals, who are 
herbivores, will forage this world in search for food.

Let’s create some variables describing the extent of our world:
[source]


We’re giving the world a width of 100 units and a height of 30 units. Using 
these dimensions should make it easy to display the world in our Lisp REPL. 
The *jungle* list defines the rectangle in the world map that contains the jun-
gle. The first two numbers in the list are the x- and y-coordinates of the jungle’s 
top-left corner, and the last two numbers are its width and height. Finally, we 
give the amount of energy contained in each plant, which is set to 80. This 
means that if an animal finds a plant, it will gain 80 days’ worth of food by 
eating it.
NOTE If your terminal window isn’t large enough to display the entire world, change the val-
ues of the *width* and *height* variables. Set the *width* variable to the width of your 
terminal window minus two, and the *height* variable to the height of your terminal 
window minus one.


Growing Plants in Our World
As you might imagine, simulating evolution on a computer is a slow process. 
In order to see the creatures evolve, we need to simulate large stretches of 
time, which means we’ll want our code for this project to be very efficient. As 
animals wander around our world, they will need to be able to check if there 
is a plant at a given x,y location. The most efficient way to enable this is to 
store all of our plants in a hash table, indexed based on each plant’s x- and 
y-coordinates.
[source]

By default, a Common Lisp hash table uses eq when testing for the equal-
ity of keys. For this hash table, however, we’re defining :test to use equal 
instead of eq, which will let us use cons pairs of x- and y-coordinates as keys. If 
you remember our rule of thumb for checking equality, cons pairs should be 
compared using equal. If we didn’t make this change, every check for a key 
would fail, since two different cons cells, even with the same contents, test 
as being different when using eq.
Plants will grow randomly across the world, though a higher concentra-
tion of plants will grow in the jungle area than in the steppes. Let’s write 
some functions to grow new plants:
[source]

The random-plant function creates a new plant within a specified region 
of the world. It uses the random function to construct a random location and 
stores it in the local variable pos X. Then it uses setf to indicate the existence 
of the plant within the hash table Y. The only item actually stored in the 
hash table is t. For this *plants* table, the keys of the table (the x,y position of 
each plant) are actually more than the values stored in the table.
It may seem a bit weird to go through the trouble of creating a hash table 
to do nothing more than store t in every slot. However, Common Lisp does 
not, by default, have a data structure designed for holding mathematical sets. 
In our game, we want to keep track of the set of all world positions that have 
a plant in them. It turns out that hash tables are a perfectly acceptable way of 
expressing this. You simply use each set item as a key and store t as the value. 
Indeed, doing this is a bit of a hack, but it is a reasonably simple and efficient 
hack. (Other Lisp dialects, such as Clojure, have a set data structure built right 
into them, making this hack unnecessary.)
Every day our simulation runs, the add-plants function will create two new 
plants: one in the jungle Z and one in the rest of the map [. Because the jungle 
is so small, it will have dense vegetation compared to the rest of the world.

Creating Animals
[pic]
The plants in our world are very simple, but the animals are a bit more com-
plicated. Because of this, we’ll need to define a structure that stores the 
properties of each animal in our game:
[source]

Let’s take a look at each of these fields in detail.
Anatomy of an Animal
[pic]

We need to track several properties for each animal. First, we need to know 
its x- and y-coordinates. This indicates where the animal is located on the 
world map.
Next, we need to know how much energy an animal has. This is a Darwinian 
game of survival, so if an animal can’t forage enough food, it will starve and 
die. The energy field tracks how many days of energy an animal has remain-
ing. It is crucial that an animal find more food before its energy supply is 
exhausted.
We also need to track which direction the animal is 
facing. This is important because an animal will walk 
to a neighboring square in the world map each day. 
The dir field will specify the direction of the animal’s 
next x,y position as a number from 0 to 7:
For example, an orientation of 0 would cause the 
animal to move up and to the left by the next day.
Finally, we need to track the animal’s genes. Each 
animal has exactly eight genes, consisting of positive integers. These integers 
represent eight “slots,” which encircle the animal as follows:
[pic]
[pic]
Every day, an animal will decide whether to continue facing the same 
direction as the day before or to turn and face a new direction. It will do this 
by consulting these eight slots and randomly choosing a new direction. The 
chance of a gene being chosen will be proportional to the number stored in 
the gene slot. 
For example, an animal might have the following genes:
[source]

Let’s represent these genes as a table, showing each slot 
number and how large of a value is stored in it:
In this example, an animal has a large number (10) stored 
in slot 2. Looking at our picture of the eight slots around the 
animal, you can see that slot 2 points to the right. Therefore, 
[pic]
this animal will make a lot of right-hand turns and run in a circle. Of course, 
since the other slots still contain values larger than zero, the animal will occa-
sionally move in another direction.
Let’s create an *animals* variable, populated with a single starting animal. 
You can think of this animal as “Adam” (or “Eve”, depending on what gender 
you prefer for our asexual animals).
[source]

We make the animal’s starting point the center of the world by setting 
the x and y positions to half of the map’s width and height, respectively. We 
set its initial energy to 1000, since it hasn’t evolved much yet and we want it to 
have a fighting chance at survival. It starts off facing the upper left, with its 
dir field set to 0. For its genes, we just use random numbers.
Note that unlike the *plants* structure, which was a hash table, the 
*animals* structure is just a plain list (currently containing only a single mem-
ber). This is because, for the core of our simulation, we never need to search 
our list of animals. Instead, we’ll just be traversing *animals* once every simu-
lated day, to let our critters do their daily activities. Lists already support effi-
cient linear traversals, so using another, more complex data structure (such as 
a table) would have no significant effect on the performance of our simulation.

Handling Animal Motion

[pic]
The move function accepts an animal as an argument and moves it, orthogo-
nally or diagonally, based on the direction grid we have described:
[source]

The move function modifies the x and y fields, using the animal-x and 
animal-y accessors. As we’ve discussed, these are automatically generated 
through the defstruct macro, based on the field names. At the top of this 
function, we use the accessors to retrieve the x- and y-coordinates for the 
animal XY. Then we use the same accessors to set the same values, with the 
aid of setf Z^.
To calculate the new x-coordinate, we use a cond command to first check 
if the direction is 2, 3, or 4 [. These are the directions the animal may face 
that point east in the world, so we want to add one to the x-coordinate. If the 
direction instead is 1 or 5, it means the animal is facing directly north or 
south \. In those cases, the x-coordinate shouldn’t be changed. In all other 
cases, the animal is facing west and we need to subtract one ]. The y-coordi-
nate is adjusted in an analogous way ^.
Since the world needs to wrap around at the edges, we do some extra math 
using the mod (remainder) function to calculate the modulus of the coordinates 
and enable wrapping across the map Z^. If an animal would have ended up 
with an x-coordinate of *width*, the mod function puts it back to zero, and it 
does the same for the y-coordinate and *height*. So, for example, if our func-
tion makes the animal move east until x equals 100, this will mean that (mod 
100 *width*) equals zero, and the animal will have wrapped around back to 
the far west side of the game world.
The final thing the move function needs to do is decrease the amount of 
energy the animal possesses by one. Motion, after all, requires energy.
Handling Animal Turning
Next, we’ll write the turn function. This function will use the animal’s genes 
to decide if and how much it will turn on a given day.

[source]

This function needs to make sure that the amount the animal turns is 
proportional to the gene number in the given slot. It does this by first sum-
ming the amount of all genes, and then picking a random number within 
that sum X. After that, it uses a recursive function named angle Y, which 
traverses the genes and finds the gene that corresponds to the chosen number, 
based on the respective contributions of each gene to the sum. It subtracts 
the running count in the argument x from the number stored at the current 
gene Y. If the running count has hit or exceeded zero, the function has reached 
the chosen number and stops recursing Z. Finally, it adds the amount of 
turning to the current direction and, if needed, wraps the number around 
back to zero, once again by using mod [.
Handling Animal Eating
[pic]

Eating is a simple process. We just need to check if there’s a plant at the ani-
mal’s current location, and if there is, consume it:
[source]

The animal’s energy is increased by the amount of energy that was 
being stored by the plant. We then remove the plant from the world using 
the remhash function.

Handling Animal Reproduction
[pic]

Reproduction is usually the most interesting part in any animal simulation. 
We’ll keep things simple by having our animals reproduce asexually, but it 
should still be interesting, because errors will creep into their genes as they 
get copied, causing mutations.
[source]

It takes a healthy parent to produce healthy offspring, so our animals will 
reproduce only if they have at least 200 days’ worth of energy X. We use the 
global constant *reproduction-energy* to decide what this cutoff number should 
be. If the animal decides to reproduce, it will lose half its energy to its child Y.

To create the new animal, we simply copy the structure of the parent 
with the copy-structure function Z. We need to be careful though, since 
copy-structure performs only a shallow copy of a structure. This means that if 
there are any fields in the structure that contain values that are more compli-
cated than just numbers or symbols, the values in those fields will be shared 
with the parent. An animal’s genes, which are stored in a list, represent the only 
such complex value in our animal structures. If we aren’t careful, mutations 
in the genes of an animal would simultaneously affect all its parents and 
children. In order to avoid this, we need to create an explicit copy of our 
gene list using the copy-list function [.
Here is an example that shows what horrible things could happen if we 
just relied on the shallow copy from the copy-structure function:

[source]

Here, we’ve created a parent animal with all its genes set to 1 X. Next, we 
use copy-structure to create a child Y. Then we set the third (second count-
ing from zero) gene equal to 10 Z. Our parent now looks correct [. Unfor-
tunately, since we neglected to use copy-list to create a separate list of genes 
for the child, the child genes were also changed \ when the parent mutated. 
Any time you have data structures that go beyond simple atomic symbols or 
numbers, you need to be very careful when using setf so that these kinds of 
bugs don’t creep into your code. In future chapters (especially Chapter 14), 
you’ll learn how to avoid these issues by not using functions that mutate data 
directly, in the manner that setf does.
To mutate an animal in our reproduce function, we randomly pick one of 
its eight genes and place it in the mutation variable. Then we use setf to twiddle 
that value a bit, again using a random number. We did this twiddling on the 
following line:
[source]

In this line, we’re slightly changing a random slot in the gene list. 
The number of the slot is stored in the local variable mutation. We add a ran-
dom number less than three to the value in this slot, and then subtract one 
from the total. This means the gene value will change plus or minus one, or 
stay the same. Since we don’t want a gene value to be smaller than one, we 
use the max function to make sure it is at least one.
We then use push to insert this new critter into our global *animal* list, 
which adds it to the simulation.
Simulating a Day in Our World
Now that we have functions that handle every detail of an animal’s routine, 
let’s write one that simulates a day in our world.
[source]

First, this function removes all dead animals from the world X. (An ani-
mal is dead if its energy is less than or equal to zero.) Next, it maps across the 
list, handling each of the animal’s possible daily activities: turning, moving, 
eating, and reproducing Y. Since all these functions have side effects (they 
modify the individual animal structures directly, using setf), we use the mapc 
function, which does not waste time generating a result list from the map-
ping process.
Finally, we call the add-plants function Z, which adds two new plants to 
the world every day (one in the jungle and one in the steppe). Since there 
are always new plants growing on the landscape, our simulated world should 
eventually reach an equilibrium, allowing a reasonably large population of 
animals to survive throughout the spans of time we simulate.
Drawing Our World
A simulated world isn’t any fun unless we can actually see our critters running 
around, searching for food, reproducing, and dying. The draw-world function 
handles this by using the *animals* and *plants* data structures to draw a snap-
shot of the current world to the REPL.
[source]

First, the function uses a loop to iterate through each of the world’s rows 
X. Every row starts with a new line (created with fresh-line) followed by a 
vertical bar, which shows us where the left edge of the world is. Next, we iterate 
across the columns of the current row Y, checking for an animal at every 
location. We perform this check using the some function Z, which lets us 
determine if at least one item in a list obeys a certain condition. In this case, 
the condition we’re checking is whether there’s an animal at the current x- and 
y-coordinates. If so, we draw the letter M at that spot [. (The capital letter M 
looks a little like an animal, if you use your imagination.) 
Otherwise, we check for a plant, which we’ll indicate with an asterisk (*) 
character \. And if there isn’t a plant or an animal, we draw a space charac-
ter ]. Lastly, we draw another vertical bar to cap off the end of each line ^.
Notice that in this function, we need to search through our entire *animals* 
list, which will cause a performance penalty. However, draw-world is not a core 
routine in our simulation. As you’ll see shortly, the user interface for our game 
will allow us to run thousands of days of the simulation at a time, without 
drawing the world to the screen until the end. Since there’s no need to draw 
the screen on every single day when we do this, the performance of draw-world 
has no impact on the overall performance of the simulation.
Creating a User Interface
Finally, we’ll create a user interface function for our simulation, called evolution.
[source]

First, this function draws the world in the REPL X. Then it waits for the 
user to enter a command at the REPL using read-line Y. If the user enters 
quit, the simulation ends Z. Otherwise, it will attempt to parse the user’s 
command using parse-integer [. We set :junk-allowed to true for parse-integer, 
which lets the interface accept a string even if it isn’t a valid integer.
If the user enters a valid integer n, the program will run the simulation 
for n simulated days, using a loop \. It will also print a dot to the screen for 
every 1000 days, so the user can see that the computer hasn’t frozen while 
running the simulation.
If the input isn’t a valid integer, we run update-world to simulate one 
more day. Since read-line allows for an empty value, the user can just tap the 
ENTER key and watch the animals move around their world.
Finally, the evolution function recursively calls itself to redraw the world 
and await more user input ]. Our simulation is now complete.
Let’s Watch Some Evolution!
To start the simulation, execute evolution as follows:

[output]
Our world is currently empty, except for the Adam/Eve animal in the 
center. Hit ENTER a few times to cycle through a few days:
[output]
Our under-evolved animal is stumbling around randomly, and a few 
plants are starting to grow.

Next, enter 100 to see what the world looks like after 100 days:

[output]

Our animal has already multiplied quite a bit, although this has less to 
do with the amount of food it has eaten than with the large amount of “starter 
energy” we gave it.
Now let’s go all out and run the simulation for five million days! Since 
we’re using CLISP, this will be kind of slow, and you may want to start it up in 
the evening and let it run overnight. With a higher-performance Lisp, such 
as SBCL, it could take only a couple of minutes.
[output]

Our world doesn’t look much different after five million days than it did 
after a hundred days. Of course, there are more animals, both traveling across 
the steppes and enjoying the lush vegetation of the jungle.

But appearances are deceptive. These animals are distinctly different from 
their early ancestors. If you observe them closely (by tapping ENTER), you’ll 
see that some of the creatures move in straight lines and others just jitter 
around in a small area, never taking more than a single step in any direction. 
(As an exercise, you could tweak the code to use different letters for each 
animal, in order to make their motion even easier to observe.) You can see 
this contrast even more clearly by typing quit to exit the simulation, then 
checking the contents of the *animals* variable at the REPL:
[output]

If you look closely at all the animals in the list, you’ll notice that they 
have two distinct types of genomes. One group of animals has a high number 
toward the front of the list, which causes them to move mostly in a straight 
line. The other group has a large number toward the back of the list, which 
causes them to jitter about within a small area. There are no animals with a 
genome between those two extremes. Have we evolved two different species?
If you were to create a function that measured how far these evolved ani-
mals travel in a fixed amount of time, the histogram of the distance would 
appear as follows:
[pic]


This is a clear bimodal distribution, showing that the behavior of these 
animals appears to fall into two populations. Think about the environment 
these animals live in, and try to reason why this bimodal distribution would 
evolve. We will discuss the solution to this conundrum next.
Explaining the Evolution
The solution to the evolution puzzle is pretty straightforward. There are two 
possible survival strategies an animal can adopt in this imaginary world: 
z Focus on the rich food supply in the jungle. Any animal adopting this 
strategy needs to be conservative in its motion. It can’t stray too far over 
time, or it might fall out of the jungle. Of course, these types of animals 
do need to evolve at least a bit of jittery motion, or they will never find 
any food at all. Let’s call these conservative, jittery, jungle-dwelling ani-
mals the elephant species.
z Forage the sparse vegetation of the steppes. Here, the most critical trait 
for survival is to cover large distances. Such an animal needs to be open-
minded, and must constantly migrate to new areas of the map to find 
food. (It can’t travel in too straight a line however, or it may end up com-
peting for resources with its own offspring.) This strategy requires a bit 
of naive optimism, and can at times lead to doom. Let’s call these liberally 
minded, risk-taking animals the donkey species.

[pic]

 세가지 종족으로 진화하는 시뮬레이션을 확장하는 것은 독자들에게 숙제로 남깁니다.

What You’ve Learned
 이번 장에서, loop명령어를 자세히 다루었습니다. 그러면서 여러분은 다음과 같은 것을 배웠습니다:

z loop명령어는 종합 looping 상점이다 - 여러분이 loop를 하기 위해 필요한 어떤 것이라도 할 수 있습니다.
z loop에서 숫자를 세기 위해선, for 구절를 사용한다.
z loop에서 list에 있는 항목들을 세기 위해선, for in 구절을 사용한다.
z list와 collect 구문으로 list에 항목을을 모아서 그것을 반환할 수 있다.
z loop에서 지원하는 다른 유용한 구문을 찾기 위해 Loop Macro의 Periodic Table을 사용한다.
#END