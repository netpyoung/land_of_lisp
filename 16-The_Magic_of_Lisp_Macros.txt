THE MAGIC OF LISP MACROS
16장.리스프 매크로의 마법


 매크로 프로그래밍은 Lisp가 사용자 프로그래밍언어가 되도록, Lisp 컴파일러/인터프리터를 가지고 놀 수 있도록 만들어 줍니다. 다양한 프로그래밍 과제에 맞닥들였을때, 많은 숙련된 Lisper들은 우선 스스로 묻습니다, "이 문제를 쉽게 해결하기 위한 내가 사용할 수 있는 프로그래밍 언어는 무엇일까?" 그런 다음 Lisp를 그 언어로 변환시키기 위해 매크로를 이용할겁니다!

 이렇게 단순하고 포괄적인 매크로 시스템을 지닌 프로그래밍 언어는 없습니다. 심지어 어떤이는 단순한 이유로, 다른 프로그래밍 언어에 이 기능을 더하는것은 불가능하다고 주장하기도 합니다: Lisp언어는 컴퓨터 코드와 프로그램 데이터가 동일한 "것"에서 만들어진 것에 있어 유일합니다. 이 책에서 많이 다루었듯이, Lisp에서 데이터를 저장하는 기본 구조는 cons cell로 구성된 symbols, numbers, lists입니다. 유사하게, Lisp 프로그램의 코드는 이와 동일한 기본 틀로 구성되어 있습니다. 이번 장에서 보게 될 거지만, Lisp에서의 코드와 데이터사이의 symmetry는 Lisp 매크로 시스템을 가능케 만드는 마법입니다.
[PIC]

NOTE
 여러분은 매크로라 불리는 기능을 갖는 C++과 같은 다른 프로그래밍 언어에 대해 들어 봤을 것입니다. 예를들어, C++언어에선 #define 지시문을 사용하여 이를 만듭니다. 그러나, 이는 동일한 것이 아닙니다! Lisp 매크로는 완전히 다르고 더욱 정교한 방법으로 처리합니다.


A Simple Lisp Macro
 컴퓨터 프로그램을 작성할때 종종, 여러분은 데자뷰를 느낄 것입니다. 저는 여러분이 이러한 기분을 알거라고 확신합니다. 여러분은 컴퓨터에서 타이핑하다가 갑자기 깨닫습니다 "이봐, 동일한 코드 조각을 작성한게 이번주만해도 세번째야!"

 예를들어, 여러분의 프로그램이 특별한 add 함수가 필요하다고 가정해봅시다:
[SOURCE]

 이 함수는 두 숫자를 더하고 side effect로 더한 값을 REPL에 출력합니다. 여러분은 디버깅을 통해 프로그램에서 이 함수의 유용성을 발견할 것입니다:
[REPL]

 이 add 함수는 간단하게 보이지만, 이 코드는 골칫거리를 하나 가지고 있습니다: 변수 x를 선언하는데 있어 왜 매우 많은 괄호들이 필요할까요? let 명령어는 하나의 변수를 선언할때 많은 괄호를 요구하며, 결국 코드는 터무니없게 보입니다.

 let에 필요한 괄호는 프로그래머가 거의 매일 격는 시각 noise의 한 예입니다. 그러나, let 명령어는 일반적인 Lisp 함수가 지원하지 못하는 일을 할 수 있기에, 여러분은 이러한 괄호를 숨기는 평범한 함수를 작성할 수 없습니다. let 명령어는 특별한 form입니다. 이는 언어의 core 부분이며, 표준 Lisp 함수를 넘어서는 특별한 힘을 지닙니다.

 매크로는 수많은 괄호들을 없에줄 것입니다. 새로운 매크로 let1을 만들어 봅시다:
[SOURCE]

 보시다시피, 매크로의 정의는 함수의 정의와 유사하게 보입니다. 그러나, defun을 사용하는 대신, 이를 정의하기 위해 defmacro를 이용하였습니다. 이는 함수처럼 이름을 가지며(이번경우 let1) 인자를 받습니다.

 일단 매크로 let1을 정의하였으면, 더 적은 괄호로 동작한다는 점을 제외하고 let처럼 사용할 수 있습니다:
[REPL]


Macro Expansion
 비록 매크로 정의가 함수 정의처럼 매우 간단해 보일지라도, 실제 매크로는 함수와 매우 다릅니다. 왜 그런지 이해하기 위해, 여러분의 Lisp가 사실 여러분의 Lisp 프로그램에서 즐겁게 뛰어다니는 작고 귀여운 방울이라 상상해 보십시요.
[PIC]

 이 방울은 표준 Lisp 코드만 이해합니다. 만약 이게 저희 let1명령어를 본다면, 뭘 해야할지 모를것입니다.
[PIC]

 이제 저희가 코드의 모양을 바꾸는 마법봉을 지녔다고 상상해 보십시요. 저희 예제에서, let1은 보통의 let으로 바뀔 것이며, Lisp는 행복할 것입니다.
[PIC]

 이 마법봉을 매크로 확장expansion이라 합니다. 이는 Lisp 인터프리터/컴파일러의 코어가 이걸 보기 전에 여러분의 코드로 연결시켜주는 특별한 변신술입니다. 매크로 확장자의 일은 여러분의 코드에 있는 어떤 매크로를 찾아(let1 매크로 처럼) 정상적인 Lisp 코드로 변환시키는 것입니다.

 이는 매크로가 함수가 실행될 때와는 다른 시간에 동작한다는 걸 의미합니다. 일반적인 Lisp 함수는 함수를 포함하는 프로그램을 실행할때 동작합니다. 이를 runtime이라 부릅니다. 반면, 매크로는 프로그램이 수행되기 전, 프로그램이 읽혀지고 Lisp 환경에 의해 컴파일 될때 동작합니다. 이를 매크로 확장 시간이라 부릅니다.

 이제 저희는 Lisp 매크로의 기본 개념을 다루었으므로, 어떻게 let1이 정의되었는지 더욱 자세히 살펴봅시다.


How Macros Are Transformed
 defmacro 명령어로 새로운 매크로를 정의할때, 이는 기본적으로 Lisp 매크로 확장 시스템에게 프로그램이 실행하기 전에 변형하는 새로운 형태를 가르칩니다. 이 매크로는 Lisp 표현식 형태로 원본 소스 코드를 인자로 받습니다. 이것의 일은, 매크로 확장자가 원본 소스가 Lisp 방울blob을 행복하게 해주는 표준 Lisp 코드로 변환되는것을 돕는 것입니다.

 어떻게 let1 매크로가 변형되는지 자세히 살펴봅시다. 여기 이것의 정의가 다시 나왔습니다:
[SOURCE]

 이 defmacro 호출의 첫번째 라인은 매크로 expander에게 알립니다 "이봐, 이 코드에서 let1으로 시작하는 form을 봤으면, 표준 Lisp로 변형시켜야되"  또한 defmacro로 정의된 매크로는 매크로가 사용될시 매크로안에서 발견된 raw 소스 코드를 담을 수 있는 인자를 지닐 수 있습니다. let1 매크로는 이와 같은 3개의 인자를 지닙니다: var, val, body. 그러면 이 세개의 인자는 무얼 나타낼까요?
[PIC]

 보시다시피, let1을 사용할때, let1매크로의 인자로 3가지 다른 표현식을 지녔습니다:

var : 첫번째 인자는 여러분이 정의한 변수의 이름입니다. 이 이름은 var라는 인자를 이용하여 매크로 내에서 이용가능합니다. 이 예에서, 이는 심볼 foo와 동일할 것입니다.
val : 두번째 표현식은 변수의 값을 결정하는 코드를 받습니다. 저희 매크로에서, 두번째 인자는 val입니다. 이는 리스트 (+ 2 3)과 동일합니다.
body : let1 호출에 있는 세번째 표현식은 생성된 새로운 변수(이번 경우 foo)를 이용하는 body 코드입니다. 이는 body의 인자를 통해 매크로 안에서 사용할 수 있습니다.

 let명령어는 body안에 다수의 statement를 지닐 수 있기 때문에, 이러한 습성을 let1 매크로 안으로 복제하기 원합니다. 이것이 매크로 명령어로 let1을 정의할때 마지막 &body인자가 앞에 특별한 키워드가 있는지에 대한 이유입니다. 이는 매크로 expander에게 "매크로의 리스트에 남아있는 표현식을 다 달라"고 요청합니다. 이러한 이유로 let1 예제의 body인자는 실제로 ((* foo foo))입니다 - 중첩된 리스트. 이번 예제에선 let1에 단 하나의 statement만을 넣었습니다.

 이제 let1 매크로의 인자의 값이 무었인지 보았고, 어떻게 매크로가 이 정보를 let1을 Lisp 컴파일러가 이해할 수 있는 표준 let으로 변형하는데 이용하는지 살펴봅시다. Lisp에 있는 소스 코드를 변형시키는 가장 쉬운 방법은 역 따옴표 syntax를 이용하는 것입니다. 역따옴표를 사용하는 방법이 기억나지 않는다면, 73쪽에 있는 "How Quasiquoting Works" 를 보시기 바랍니다.) 역 따옴표로 let1에 코드를 넣음으로써 적절한 let 명령어를 위한 코드를 만들 수 있습니다. 여기 참고를 위해 let1매크로가 다시 나왔습니다.
[SOURCE]

 보시다시피 let1 매크로는, Lisp의 let 명령어가 필요로하는 적절한 중첩된 리스트에 놓인 변수 이름과 값이 잇달아 나오는, let 심볼로 시작하는 역따옴표 처리된 리스트를 반환합니다. 이 쉼표는 실제 변수 이름과 값을 이 지점으로 툭하니 놓여지도록 합니다. 마지막으로, let1으로부터 이와 유사한 let 명령어에 body 코드를 놓습니다.

 body 인자는 splicing comma(,@)를 이용하는 변형된 코드로 삽입됩니다. 왜 body가 이런 특별한 방식으로 다루어 져야하는지 이해하기 위해, 다음 let1 매크로의 사용을 살펴봅시다:
[REPL]

 이번 경우, 저희 let body안에 하나보다 더 많은 것을 넣었습니다. let 명령어는 암시적 progn 명령어를 포함하였으며, 이는 다수의 Lisp 지시어instructions들을 내부에 넣을 수 있습니다. 저희 새로운 let1 매크로는 body 인자의 앞에, 모든 남아있는 syntax 표현식을 리스트처럼 let1으로 통과시키는 특별한 &body 마커를 놓음으로써 이러한 것들을 적절히well 허용합니다. 따라서 이전 예제에서, body 인자는 ((princ "Lisp is awesome!") (* foo foo)) 코드를 포함합니다.


Using the Simple Macro
 let1 매크로를 작성했으므로, 이제 깔끔한 방식으로 저희만의 add 함수를 재작성해봅시다:
[SOURCE]

 쉬워 보이지 않습니까?

 매크로에 의해 생성된 코드를 보기위해 macroexpand 명령어를 이용할 수 있습니다. 이와 같이 단순히 매크로의 코드를 macroexpand로 넣으면 됩니다:
[REPL]

 이제 여러분은 let1에 의해 생성된 raw 코드를 봤습니다. 끝에 나와 있는 T는 macroexpand가 확장 될 수 있는 유효한 매크로로 넘겨진다는 것을 의미합니다.

 여러분의 매크로가 더욱 복잡하게 된다면, 여러분은 macroexpand가 구조를 테스트하거나 디버그함에 있어 유용한 도구라는것을 발견할 것입니다.


More Complex Macros
 이제 여러분만의 my-length 명령어가 필요하다 가정해봅시다. 이는 리스트의 길이를 세는 classic list-eating 함수입니다. 저희는 tail 위치에 재귀 함수가 있는 (14장에서 다룬) "tail call로 최적화된" 스타일로 작성할 것입니다:
[SOURCE]

 보시다시피, 이 함수는 다시한번 데자뷰의 두려움을 느끼게하는 반복적인 어떠한 것을 지니고 있습니다. 이 함수에는 두가지 반복적인 패턴이 있습니다:

z 다른 list-eather 함수처럼, cdr의 사용과 관련있는 리스트가 비어있는지를 확인하는 짜증스런 검사를 지녔습니다.
z 이러한 모든 장황한 작업을 지역 함수 f를 만들기 위해 하였습니다.

 이 함수(그리고 동일한 반복을 하는 다른 함수)를 더욱 간결하게 만드는 매크로를 작성해 봅시다.


A Macro for Splitting Lists
 우선, split 매크로를 생성해봅시다. 이는 my-length 함수처럼 더욱 clean한 lister-eater 함수를 작성하게 해줄 것입니다

 List-eaters 는 항상 리스트가 비어있는지를 검사합니다. 만일 그렇지 않다면 car 와/혹은 cdr을 이용하여 그들을 분리하고 리스트의 head 와/나 tail에서 작업을 수행합니다. split 매크로는 저희를 위해 이러한 작업을 수행합니다. 여기 완성된 split 매크로를 사용한것이 나와 있습니다:
[REPL]

 split 매코르의 첫번째 인자는 여러분이 head와 tail로 나누어지길 원하는 리스트 입니다. 이것이 가능하다면 split 매크로에 있는 다음 표현식이 호출될 것입니다. 보너스로, split 매크로는 저희를 위해 자동적으로 head와 tail이란 이름의 두 변수를 생성합니다. 이러한 방법으로, list-eating 함수 내부에서 항상 car와 cdr을 호출할 필요가 없습니다. 리스트가 비어있다면, 끝에 있는 표현식을 호출합니다.

 split 매크로의 코드를 살펴봅시다. 이 매크로의 초기 버전은 곧 짤막하게 다룰 몇몇 버그들을 포함하고 있다는 것을 알립니다:
[SOURCE]

 저희 split 매크로는 인자로 3가지 표현식을 필요로 합니다. 이는 이 매크로를 이용할시, 항상 정확히 3개의 항목만이 필요로 한다는 것을 의미합니다.

 split에 의해 생성되는 코드는 매우 간단합니다. 우선, 리스트가 비어있는지를 확인합니다. 만일 그렇다면, 리스트를 분해시켜 이를 두 지역 변수 head와 tail로 붙입니다. 그런 다음, "그래, 리스트를 분리시킬 수 있어" 라는, 경우를 다루는 코드 안에 넣습니다. 리스트를 분리시킬 수 없다면, no를 호출합니다. no라는 경우엔, 리스트가 분리될 수 없다면 만들지 않을 것이기에 head/tail 변수에 접근할 수 없습니다.

 이 새로운 split 매크로로, my-length 함수(our macro => our function)를 조금 더 깔끔해보이도록 만들 수 있습니다:
[SOURCE]

 split에 의해 생성된 tail 변수의 사용이 얼마나 저희 코드를 간소화 시키는지 보시기 바랍니다. 이와 같이 자동적으로 변수를 생성하는 매크로를 anaphoric 매크로라 부릅니다.

 그러나 아직 저희는 split 매크로를 완성시키진 않았습니다. 비록 이것이 기본적으로 작동하지만, 저희가 다뤄야하는 몇몇 잠재적 버그를 지니고 있습니다.


Avoiding Repeated Execution in Macros
 매크로에서 일어날 수 있는 일반적인 버그중 하나는 잘못된 코드의 반복 실행입니다. 사실, 현 split 매크로 버전은 이러한 결점을 지니고 있습니다. 여기 이러한 문제점을 적나라하게 보여주는 예제가 있습니다:
[REPL]

 이 split의 사용에서, 원본 소스에서 한번 보인 statement "Lisp rocks!"가 3번 출력 되었습니다. 어떻게 이러한 것이 가능할까요?

 인자가 raw 소스 코드로 이루어진 매크로로 들어간다는 것을 기억하시기 바랍니다. 이는 split으로 들어간 val인자는 princ statement를 포함하고있는 progn statement의 raw 코드를 포함한다는 것을 의미합니다. val을 split 매크로에서 3번이나 참조하기 때문에, 이는 princ statement가 3번 실행되도록 합니다.

 macroexpand를 통한 이 예제의 실행을 통해 이를 입증할 수 있습니다:
[REPL]

 보시다시피, princ statement는 3번 보여집니다. 이는 반복적으로 동일한 코드가 불필요하게 실행되므로 예상치못한 행동을 유발하며 비효율적입니다.

 이 문제에 대해 조금 생각해본다면, 해결책을 찾는것은 그다지 어렵지만은 않을것입니다. 이처럼 단순히 split 매크로안에 지역 변수를 생성하면 됩니다:
[SOURCE]

 새로운 버전의 split안에 let1을 사용하였습니다. 여기서 보인것처럼 다른 매크로 안에서의 매크로의 사용은 완벽하게 돌아갑니다.

 이제 이전 예제를 다시 돌려본다면, 정확하게 statement를 한번만 princing 하는 split을 볼 수 있을 것입니다:
[REPL]

 불행히도, 아직도 이 새로운 split 매크로 버전은 또다른 버그를 야기합니다introduce. 다음으로가서 이 새로운 버그와 맞붙어봅시다.


Avoiding Variable Capture
 최신 버전의 split에 있는 버그를 확인하기 위해, 다음을 실행해 봅시다:
[REPL]

 어떠한 일이 일어났습니까? 저희는 방금 split 매크로의 새로운 버전안에서 변수 x를 생성하였습니다! 여기 이를 macroexpand 한다 했을때 split가 호출한 것이 나와있습니다.
[REPL]

 split의 expanded된 버전은 x의 정의를 포함하고 있습니다. 문제가 있는 저희 예제에서 이는 경쟁competing 정의를 막습니다. 이러한 경우, split 매크로는 뜻하지 않게 변수 x를 잡아captured 예상치 못한 방식으로 이를 덮어써버립니다. 어떻게 이러한 문제를 피할 수 있을까요?

 하나 단순한 해결책은 매크로 안에서 변수 x를 만들지 않고, xqweopfjsadlkjgh처럼 기괴하게 긴 이름을 갖는 변수를 이용하는 것입니다. 그리하면 매크로에서 사용되는 변수가 코드에서 이를 사용하는 변수이름과 충돌나지 않을 것이라는 확신이 들 것입니다. 사실, 정확히 이 목적에 맞게 괴상한cracy 변수 이름을 생성하는 gensym이라 불리는 Common Lisp 함수가 있습니다.
[REPL]

 gensym 함수는 여러분을 위해 코드에서 다른 변수 이름과 절대 충돌나지 않는 다는걸 보장하는 고유한 변수 이름을 생성할 것입니다. 여러분은 이가 이와 다른 이름을 구분하는 특별한 prefix (#:)를 지녔다는 것을 인지하였을 것입니다. Common Lisp는 이러한 gensym-기반한 이름을 특별한 방식으로 다루며 gensym 변수의 이름을 직접 사용하는 것을 막습니다.

 이제 변수가 잡히는 것을 방지하기 위해 split 매크로 안에서 gensym 함수를 사용해 봅시다:
[SOURCE]

 개정된 매크로의 첫번째 라인에서, gensym 이름을 담은 변수 g를 정의하였습니다. 이 라인의 선두에 역 따옴표가 없다는 것은 매우 중요합니다. 이는 이 코드의 라인은 런타임이아니라 매크로 확장 시간에 있다는 것을 의미하며, 이 시점에서 변수 g를 정의하는 것은 괜찮습니다. 그러나 다음 라인에서 let1은 이 앞에 역따옴표가 있습니다. 이 라인은 런타임에서 실행될 것이며, 이 지점에서 하드코드된 변수를 사용하지 않을 것입니다. 새로운 버전에서, 고유한 이름을 이용하는 대신 g에 저장된 gensym 이름을 이용하였습니다.

 이제 split 매크로가 사용될 때마다, 내부 값을 유지하기 위해 고유한 이름이 생성됩니다. macroexpand를 통해 몇몇 예제를 톨려 봄으로써 이를 테스트할 수 있습니다:
[REPL]

 두 사례에서 서로 다른 이름의 지역 변수가 생성되었습니다. 이는 코드에서도 변수의 이름이 고유하며, split 매크로가 중첩해서 여러번 사용되어도 고유할 것이라는 걸 보장합니다. 이제까지 저희는 완벽하게 디버그된 split 매크로의 버전을 생성하였습니다.

 단지 이제 버그-free라는것이지, variable capture에서의 해방을 의미하진 않습니다. 매크로가 여전히 변수 head와 tail을 정의합니다. 다른 의미를 지닌 head나 tail이 있는 다른 코드에서 이 함수를 사용한다면, 여러분의 코드는 동작하지 않을 것입니다! 그러나 이 head와 tail에서 capture는 일부러 놔둔 것입니다. 이번 경우 variable capture는 버그가 아닌 하나의 기능입니다 - anaphoric 매크로. 저희가 다루었듯이, 이는 매크로의 본체 안에서 사용될 수 있는 명명된 변수와 함수를 이용가능하게 만듭니다.


A Recursion Macro
 향상된 my-lenght 매크로를 다시 살펴봅시다:
[SOURCE]

 저희가 다루었듯이, 이 코드에는 추가적인 반복 패턴이 있습니다: 지역 함수 f생성. 추가적인 시각 noise를 없에는 또다른 매크로를 작성해봅시다: recurse. 여기 recurse 매크로를 사용하는 한 예제가 있습니다:
[REPL]

 recurse 매크로의 첫번째 인자는 변수와 시작 값의 리스트입니다. 이번 경우, 하나의 변수(n)을 선언하고 시작 값을 9로 설정합니다. 매크로의 나머지 라인에선 재귀적인 함수의 본체를 구성합니다.

 본체에서 저희가 할 첫번째 일은 새로운fresh 라인으로 시작하는 것입니다. 그런 다음 0에 도달했는지 확인합니다. 만일 그렇다면, "lift-off!"를 출력합니다. 그렇지 않으면, 현재 라인을 출력하고 재귀적으로 함수를 다시 호출합니다. split 매크로처럼, 이 recurse 매크로는 anaphoric입니다. recurse인 경우에는, 재귀를 수행할 준비가 되었을때 호출이 가능한 self란 함수를 만듭니다. 저희는 또한 이 지점에서 카운트다운 하기 위해 n에서 1을 뺍니다

 이제 recurse가 어떻게 동작하는지 보았으므로, recurse 매크로를 작성해 봅시다. 인자의 리스트와 시작 값으로 진행하기 위해, 항목들을 쌍pairs의 리스트로 묶는게 가능한 함수를 갖는게 저희에게 유용합니다. 여기 이를 수행하는 pairs 함수가 있습니다:
[REPL]

 pairs 함수는 아이러니하게 지역 함수 f를 갖는 tail-call-optimized list-eater입니다. (즉, 이와같은 함수를 더이상 선언할 필요가 없습니다) 리스트에서 하나의 항목을 분리시키기 위해 split을 이용합니다. 그러나, 리스트에서 한번에 두가지 항목(한 쌍)을 진행해야 하므로, 추가적으로 tail이 비었는지 확인해야 합니다. 리스트에 항목이 없으면(혹은 하나의 항목만이 남아있다면), accumulated된 값을 반환합니다. 그렇지않으면, accumulator에 놓여진 새로운 항목의 쌍으로 리스트의 나머지를 재귀적으로 진행합니다.

 이제 저희는 recurse 매크로를 작성할 준비가 되었습니다:
[SOURCE]

 보시다시피, 이는 단순히 재귀를 전통적인 지역 함수로 변형시킵니다. 우선, 변수 이름과 시작 값을 분리시키기 위해 새로운 pairs 함수를 이용하고 결과를 p에 넣습니다. 그런 다음 간단한 지역 함수 self를 정의합니다. 변수 이름 self는 p에서 홀수번째 항목입니다. 매크로 내부로부터 anaphorically하게 self에 접근하기를 원하므로, 이 함수에서 gensym의 이름 대신 평범한 이름을 사용합니다. 그런 다음 매크로 하단부에서, 모든 시작 값들을 처리passing하는 self를 호출합니다.

 이제 저희는 recurse 매크로를 작성하였고, 이 새로운 언어 구상을 이용하여 다시 한번 저희 my-length 함수를 깔끔하게 만들어 봅시다:
[SOURCE]

 보시다시피, 이번 my-length 함수의 버전에선 반복이나 시각 noise가 매우 적습니다.

 이제 여러분은 깔끔하고clean 간결한 코드를 작성하기 원할때 매크로가 얼마나  유용한지를 이해할 수 있습니다. 그러나, 매크로의 사용의 자유로움은 또한 여러분이 인지해야만하는 어떠한 비용의 감내를 필요로 합니다. 다음에서 매크로의 잠재적 부정적인 면을 보게될 것입니다.


Macros: Dangers and Alternatives
 매크로는, Lisp 언어를 메타프로그래밍과 새로운 언어의 프로토타이핑을 위한 근사한wonderful 도구로 만들어주는, 다른 코드를 생성하는 코드를 작성케 해줍니다. 그러나, 어떠한 수준에 있어 매크로는 단지 교묘한 속임수입니다: 여러분만의 언어를 구성하고 표준 Lisp처럼 그것들을 다루는 것을 Lisp 컴파일러/인터프리터가 받아들이도록 속이는 것입니다. 이는 프로그래머의 도구 상자에서 강력한 도구이지만, 이 책에서 마주쳤던 다른 프로그래밍 도구처럼 우아함이 없습니다

 매크로의 주된 결점은 다른 프로그래머가 여러분의 코드를 이해하는데 있어 어렵게 만들 수 있다는 것입니다. 어쨋든, 여러분만의 방언을 만든다면, 다른 프로그래머들은 이에 익숙치 않을 것입니다. 나중에 있을 self라도 - 아마, 1년이나 2년 - 과도히 매크로를 사용하였다면 여러분의 코드 구조를 이해하는 데 있어 많은 시간이 걸릴 것입니다. 이러한 연유로, 숙련된 Lisper들은 가능하다면 매크로 프로그래밍대신 대안 기술을 사용을 우선시 합니다.(Because of this,  experienced Lispers will do their best to use alternate techniques to macro programming whenever possible.) 흔히, 초급 Lisper는 더 깔끔한 방식으로 다른 곳에서 쓰일수 있는 매크로를 작성합니다

 예를들어, 두 쌍의 split과 recurse매크로를 추가하여 얼마나 my-length 함수가 깔끔해 질 수 있는지 보는것은 재미있습니다. 그러나, 이전 두 장에서, 여러분은 list-eater 함수를 깔끔하게 하는데 사용될 수 있는 또다른 도구 함수형 프로그래밍에 대해 배웠습니다. 함수형 프로그래머들이 종종 사용하는 강력한 함수중 하나는 reduce입니다. 이는 higher-order 함수와 리스트를 받는 함수이며, 리스트에 있는 모든 값들에 대해 한번씩 함수를 호출합니다. 여기 매크로대신 강력한 reduce 함수를 이용하여 다시 작성한 my-length 함수가 있습니다:
[SOURCE]

 보디사디피, 이 새로운 my-length 버전은 이전 버전을 쉽게 날려버립니다. 이는 더 짧을 뿐더러 저희가 만들었던 어떠한 비표준 매크로에 의존하지 않습니다.

 reduce의 첫번째 인자는 reduction 함수를 받습니다. 이것의 일은 여기선 x란 이름의 accumulated value를 추적하고 갱신하는 것입니다. 이 변수 x는 머지않아 리스트의 길이가 될 현재 accumulated value을 유지합니다. 이는 이를 새로운 값으로 갱신하기 위해 간단히 x에 1을 더할 수 있다는 것을 의미합니다. reduction 함수가 리스트에 있는 모든 항목에 대해 한번씩 호출될 것이기에, 마지막에가서는 리스트의 길이를 생성할 것입니다. (reduction 함수는 또한 여기서 주어진 변수 i처럼 인자로써 리스트에 있는 현재 항목을 받습니다. 그러나 저희는 리스트의 길이를 계산하는데 이것이 필요하지 않습니다.) reduce의 다음 항목은 저희가 reduce하기 원하는 리스트 입니다. 마지막으로 저희가 계산하는 accumulated된 길이의 초기 값이 0이기 때문에, :initial-value 키워드 인자로 0을 설정하였다는 것을 알려줘야합니다

 분명, 이번 장에서 저희가 만든 list-eater 매크로 역시 유용한 시나리오도 있습니다. reduce 함수를 쉽게 사용할 수 없는 경우도 많습니다. 그리고 마지막으로, 여러분은 다음 장에서 보게 될 것처럼, 여전히 여러분만의 Lisp 방언을 만들어내는 것이 문제에 대한 정확하게 올바른 해결책이 되는 상황이 많이 있습니다.


What You’ve Learned
 이번장에선 매크로 프로그래밍에 대해 다뤘습니다. 여러분은 다음 내용들을 배웠습니다:

z 매크로는 코드를 작성하는 코드를 작성하게 해준다. 매크로로 여러분은 여러분만의 프로그래밍 언어를 만들 수 있으며 컴파일러가 이를 들여다 보기 전에 표준 Lisp로 변환 할 수 있습니다.
z 매크로는, 그렇게밖에 할 수 없었던 상황에서 코드를 작성했던, 데자뷰의 느낌을 없에도록 해준다. 
z 매크로를 작성할 시에는 주의하여 의도치 않은 반복된 코드의 실행을 야기시켜선 안된다.
z 매크로에서 의도되지 않은 variable capture를 피하도록 주의해야 한다. gensym 이름을 이용하여 이를 피할 수 있습니다.
z 매크로의 기능으로 매크로에 의해 생성된 변수가 고의로 노출되었다면, 이러한 매크로를 anaphoric 매크로라 부른다.
z 매크로 프로그래밍은 매우 강력한 기법이다. 그러나, 가능하다면 문제를 해결하는데 함수형 프로그래밍을 이용하시기 바랍니다. 매크로는 항상 마지막 피난처가 되야합니다.