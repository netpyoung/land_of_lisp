THE MAGIC OF LISP MACROS

 매크로 프로그래밍은, Lisp가 사용자 프로그래밍언어가 되도록, Lisp 컴파일러/인터프리터를 가지고 노는 것을 허용합니다. 다양한 프로그래밍 과제에 맞닥들였을때, 많은 숙련된 Lisper들은 우선 스스로 묻습니다, "이 문제를 쉽게 해결하기 위한 내가 사용할 수 있는 프로그래밍 언어는 무엇일까?" 그런 다음 Lisp를 그 언어로 변환시키기 위해 매크로를 이용할겁니다.

 이렇게 단순하고 포괄적인 매크로시스템을 지닌 프로그래밍 언어는 없습니다. 심지어 어떤이는 단순한 이유로, 다른 프로그래밍 언어에 이 기능을 더하는것은 불가능하다고 주장하기도 합니다: Lisp언어는 컴퓨터 코드와 프로그램 데이터가 동일한 "것"에서 만들어진 것에 있어 유일합니다. 이 책에서 많이 다루었듯이, Lisp에서 데이터를 저장하는 기본 구조는 cons cell로 구성된 symbols, numbers, lists입니다. 유사하게, Lisp 프로그램의 코드는 이와 동일한 기본 틀로 구성되어 있습니다. 이번 장에서 보게 될 거지만, Lisp에서의 코드와 데이터사이의 symmetry는 Lisp 매크로 시스템을 가능케 만드는 magic 입니다
[pic]

NOTE
 여러분은 매크로라 불리는 기능을 갖는 C++과 같은 다른 프로그래밍 언어에 대해 들어 봤을 것입니다. 예를들어, C++언어에선 #define 지시문을 사용하여 이를 만듭니다. 그러나, 이는 동일한 것이 아닙니다! Lisp 매크로는 완전히 다르고 더욱 정교한 방법으로 처리합니다.


A Simple Lisp Macro
 컴퓨터 프로그램을 작성할때 종종, 여러분은 데자뷰를 느낄 것입니다. 저는 여러분이 이러한 기분을 알거라고 확신합니다. 여러분은 컴퓨터에서 타이핑하다가 갑자기 깨닫습니다 "이봐, 동일한 코드 조각을 작성한게 이번주만해도 세번째야!"

 예를들어, 여러분의 프로그램이 특별한 add 함수가 필요하다고 가정해봅시다:
[source]

 이 함수는 두 숫자를 더하고 side effect로 더한 값을 REPL에 출력합니다. 여러분은 디버깅을 통해 프로그램에의서 이 함수의 유용성을 발견할 것입니다:
[output]

 이 add 함수는 간단하게 보이지만, 이 코드는 골칫거리를 하나 가지고 있습니다: 변수 x를 선언하는데 있어 왜 매우 많은 괄호들이 필요할까요? let 명령어는 하나의 변수를 선언할때 많은 괄호를 요구하며, 결국 코드는 터무니없게 보입니다.

 let에 필요한 괄호는 프로그래머가 거의 매일 격는 시각 noise의 한 예입니다. 그러나, let 명령어는 일반적인 Lisp 함수가 지원하지 못하는 일을 할 수 있기에, 여러분은 이러한 괄호를 숨기는 평범한 함수를 작성할 수 없습니다. let 명령어는 특별한 form입니다. 이는 언어의 core 부분이며, 표준 Lisp 함수를 넘어서는 특별한 힘을 지닙니다.

 매크로는 수많은 괄호들을 없에줄 것입니다. 새로운 매크로 let1을 만들어 봅시다:
[source]

 보시다시피, 매크로의 정의는 함수의 정의와 유사하게 보입니다. 그러나, defun을 사용하는 대신, 이를 정의하기 위해 defmacro를 이용하였습니다. 함수처럼, 이는 이름을 가지며(이번경우 let1) 인자를 받습니다.

 일단 매크로 let1을 정의하였으면, 더 적은 괄호로 동작한다는 점을 제외하고 let처럼 사용할 수 있습니다:
[output]


Macro Expansion
 비록 매크로 정의가 함수 정의처럼 매우 간단해 보일지라도, 실제로 매크로는 함수와 매우 다릅니다. 왜 그런지 이해하기 위해, 여러분의 Lisp가 사실 여러분의 Lisp 프로그램에서 즐겁게 뛰어다니는 작고 귀여운 방울이라 상상해 보십시요.
[pic]

 이 방울은 표준 Lisp 코드만 이해합니다. 만약 이게 저희 let1명령어를 본다면, 뭘 해야할지 모를것입니다.
[pic]

이제 저희가 코드 외형을 변형시키는 마법봉을 지녔다고 상상해 보십시요. 저희 예제에서, let1은 보통의 let으로 변형될 것이며, Lisp는 행복할 것입니다.
[pic]

 이 마법봉은 매크로 확장expansion이라 불립니다. 이는 Lisp 인터프리터/컴파일러의 코어가 이걸 보기 전에 여러분의 코드로 연결시켜주는 특별한 변형입니다. 매크로 확장자의 일은 여러분의 코드에 있는 어떤 매크로를 찾아(let1 매크로 처럼) 정상적인 Lisp 코드로 변환시키는 것입니다.

 이는 매크로가 함수가 실행될 때와는 다른 시간에 동작한다는 걸 의미합니다. 일반적인 Lisp 함수는 함수를 포함하는 프로그램을 실행할때 동작합니다. 이를 runtime이라 부릅니다. 반면, 매크로는 프로그램이 수행되기 전, 프로그램이 읽혀지고 Lisp 환경에 의해 컴파일 될때 동작합니다. 이를 매크로 확장 시간이라 부릅니다.

 이제 저희는 Lisp 매크로의 기본 개념을 다루었으므로, 어떻게 let1이 정의되었는지 더욱 자세히 살펴봅시다.


How Macros Are Transformed
 defmacro 명령어로 새로운 매크로를 정의할때, 이는 기본적으로 Lisp 매크로 확장 시스템에게 프로그램이 실행하기 전에 변형하는 새로운 형태를 가리킵니다. 이 매크로는 Lisp 표현식 형태로 원본 소스 코드를 인자로 받습니다. 이것의 일은, 매크로 확장자가 원본 소스가 Lisp 방울을 행복하게 해주는 표준 Lisp 코드로 변환되는것을 돕는 것입니다.

 어떻게 let1 매크로가 변형되는지 자세히 살펴봅시다. 여기 이것의 정의가 다시 나옵니다:
[source]

 이 defmacro 호출의 첫번째 라인은 매크로 expander에게 알립니다 "이봐, 이 코드에서 let1으로 시작하는 form을 봤으면, 표준 Lisp로 변형시켜야되" defmacro로 정의된 매크로는 또한, 매크로가 사용될시 매크로안에서 발견된 raw 소스 코드를 담을 수 있는, 인자를 지닐 수 있습니다. let1 매크로는 이와 같은 3개의 인자를 지닙니다: var, val, body. 그러면 이 세개의 인자는 무얼 나타낼까요?
[pic]

 보시다시피, let1을 사용할때, let1매크로의 인자로 3가지 다른 표현식을 지녔습니다:

var 첫번째 인자는 여러분이 정의한 변수의 이름입니다. 이 이름은 var라는 인자를 이용하여 매크로 내에서 이용가능합니다. 이 예에서, 이는 심볼 foo와 동일할 것입니다.
val 두번째 표현식은 변수의 값을 결정하는 코드를 받습니다. 저희 매크로에서, 두번째 인자는 val입니다. 이는 리스트 (+ 2 3)과 동일합니다.
body let1 호출에 있는 세번째 표현식은 생성된 새로운 변수(이번 경우 foo)를 이용하는 body 코드입니다. 이는 body의 인자를 통해 매크로 안에서 사용할 수 있습니다.

 let명령어는 body안에 다수의 statement를 지닐 수 있기 때문에, let1 매크로 안에 이러한 행동을 복재하기 원합니다. 이것이 매크로 명령어로 let1을 정의할때 마지막 &body인자가 앞에 특별한 키워드가 있는지에 대한 이유입니다. 이는 매크로 expander에게 "매크로의 리스트에 남마있는 표현식을 다 달라"고 요청합니다. 이러한 까닭에, let1 예제의 body인자는 실제로 ((* foo foo))입니다 - 중첩된 리스트. 이번 예제에서, let1에 단 하나의 statement만을 넣었습니다.

 이제 let1 매크로의 인자의 값이 무었인지 보았고, 어떻게 매크로가 이 정보를 let1을 Lisp 컴파일러가 이해할 수 있는 표준 let으로 변형하는데 이용하는지 살펴봅시다. Lisp에 있는 소스 코드를 변형시키는 가장 쉬운 방법은 역 따옴표 syntax를 이용하는 것입니다. 역따옴표를 사용하는 방법이 기억나지 않는다면, 73쪽에 있는 "How Quasiquoting Works" 를 보시기 바랍니다.) 역 따옴표로 let1에 코드를 넣음으로써 적절한 let 명령어를 위한 코드를 만들 수 있습니다. 여기 참고를 위해 let1매크로가 다시 나왔습니다.
[source]

 보시다시피 let1 매크로는, Lisp의 let 명령어가 필요로하는 적절한 중첩된 리스트에 놓인 변수 이름과 값이 잇달아 나오는, let 심볼로 시작하는 역따옴표 처리된 리스트를 반환합니다. 이 쉼표는 실제 변수 이름과 값을 이 지점으로 툭하니 놓여지도록 합니다. 마지막으로, let1으로부터 이와 유사한 let 명령어에 body 코드를 놓습니다

 body 인자는 splicing comma(,@)를 이용하는 변형된 코드로 삽입됩니다. 왜 body가 이런 특별한 방식으로 다루어 져야하는지 이해하기 위해, 다음 let1 매크로의 사용을 살펴봅시다:
[output]

 이번 경우, 저희 let body안에 하나보다 더 많은 것을 넣었습니다. let 명령어는 암시적 progn 명령어를 포함하였으며, 이는 다수의 Lisp 지시어instructions들을 내부에 넣을 수 있습니다. 저희 새로운 let1 매크로는 body 인자의 앞에, 모든 남아있는 syntax 표현식을 리스트처럼 let1으로 통과시키는 특별한 &body 마커를 놓음으로써 이러한 것들을 잘 처리allow합니다. 따라서 이전 예제에서, body 인자는 ((princ "Lisp is awesome!") (* foo foo)) 코드를 포함합니다.


Using the Simple Macro
 let1 매크로를 작성했으므로, 이제 깔끔한 방식으로 저희만의 add 함수를 재작성해봅시다:
[source]

 쉬워 보이지 않습니까?

 매크로에 의해 생성된 코드를 보기위해 macroexpand 명령어를 이용할 수 있습니다. 이와 같이 단순히 매크로의 코드를 macroexpand로 넣으면 됩니다:
[output]

 이제 여러분은 let1에 의해 생성된 raw 코드를 봤습니다. 끝에 나와 있는 T는 macroexpand가 확장 될 수 있는 유효한 매크로로 넘겨진다는 것을 의미합니다.

 여러분의 매크로가 더욱 복잡하게 되면, 여러분은 macroexpand가 구조를 테스트하거나 디버그함에 있어 유용한 도구라는것을 발견할 것입니다.


More Complex Macros
 이제 여러분만의 my-length 명려어가 필요하다 가정해봅시다. 이는 리스트의 길이를 세는 classic listeating 함수입니다. 저희는 tail 위치에 재귀 함수가 있는 "tail call로 최적화된" 스타일(14장에서 다룬)로 작성할 것입니다:
[source]

 보시다시피, 이 함수는 다시한번 데자뷰의 두려움을 느끼게하는 반복적인 어떠한 것을 지니고 있습니다. 이 함수에는 두가지 반복적인 패턴이 있습니다:

z 다른 list-eather 함수처럼, cdr의 사용과 관련있는 리스트가 비어있는지를 확인하는 짜증스런 검사를 지녔습니다.
z 이러한 모든 장황한 작업을 지역 함수 f를 생성하는데 하였습니다.

 이 함수(와 동일한 반복을 하는 다른 함수)를 더욱 간결하게 만드는 매크로를 작성해 봅시다.


A Macro for Splitting Lists
 우선, split 매크로를 생성해봅시다. 이는 my-length 함수처럼 더욱 clean한 lister-eater 함수를 작성하게 해줄 것입니다

 List-eaters 는 항상 리스트가 비어있는지를 검사합니다. 만일 그렇지 않다면 car 나/혹은 cdr을 이용하여 그들을 분리하고 리스트의 머리 와/나 꼬리에서 작업을 수행합니다. split 매크로는 저희를 위해 이러한 작업을 수행합니다. 여기 완성된 split 매크로를 사용했을 때처럼 보이는게 있습니다:
[output]

split 매코르의 첫번째 인자는 여러분이 머리와 꼬리로 나누어지길 원하는 리스트 입니다. 이것이 가능하다면 split 매크로에 있는 다음 표현식이 호출될 것입니다. 보너스로, split 매크로는 저희를 위해 자동적으로 head와 tail이란 이름의 두 변수를 생성합니다. 이러한 방법으로, list-eating 함수 내부에서 항상 car와 cdr을 호출할 필요가 없습니다. 리스트가 비어있다면, 끝에 있는 표현식을 호출합니다.

 split 매크로의 코드를 살펴봅시다. 이 매크로의 초기 버전은 곧 짤막하게 다룰 몇몇 버그들을 포함하고 있다는 것을 알립니다:
[source]

 저희 split 매크로는 인자로 3가지 표현식을 필요로 합니다. 이는 이 매크로를 이용할시, 항상 정확히 3개의 항목만이 필요로 한다는 것을 의미합니다.

 split에 의해 생성되는 코드는 매우 간단합니다. 우선, 리스트가 비어있는지를 확인합니다. 만일 그렇다면, 리스트를 분해시켜 두 지역 변수 head와 tail로 붙입니다. 그런 다음, "그래, 리스트를 분리시킬 수 있어" 라는, 경우를 다루는 코드 안에 넣습니다. 리스트를 분리시킬 수 없다면, no를 호출합니다. no라는 경우엔, 리스트가 분리될 수 없다면 만들지 않을 것이기에 head/tail 변수에 접근할 수 없다는 것을 알립니다

 이 새로운 split 매크로로, my-length 함수(our macro => our function)를 조금 더 깔끔해보이도록 만들 수 있습니다:
[source]

 split에 의해 생성된 tail 변수의 사용이 얼마나 저희 코드를 간소화 시키는지 보시기 바랍니다. 이와 같이 자동적으로 변수를 생성하는 매크로를 anaphoric 매크로라 부릅니다.

 그러나 아직 저희는 split 매크로를 완성시키진 않았습니다. 비록 이것이 기본적으로 작동은하나, 저희가 다루어야하는 몇몇 잠재적 버그를 지니고 있습니다.


Avoiding Repeated Execution in Macros
 매크로에서 일어날 수 있는 일반적인 버그중 하나는 잘못된 코드의 반복 실행입니다. 사실, 현 split 매크로 버전은 이 결점을 지니고 있습니다. 여기 이러한 문제점을 적나라하게 보여주는 예제가 있습니다:
[output]

 이 split의 사용에서, 원본 소스에서 한번 보인 statement "Lisp rocks!"가 3번 출력 되었습니다. 어떻게 이러한 것이 가능할까요?

 인자가 raw 소스 코드로 이루어진 매크로로 들어간다는 것을 기억하시기 바랍니다. 이는 split으로 들어간 val인자는 princ statement를 포함하고있는 progn statement의 raw 코드를 포함한다는 것을 의미합니다. val을 split 매크로에서 3번이나 참조하기 때문에, 이는 princ statement가 3번 실행되도록 합니다.

 macroexpand를 통한 이 예제의 실행을 통해 이를 입증할 수 있습니다:
[output]

 보시다시피, princ statement는 3번 보여집니다. 이는 반복적으로 동일한 코드가 불필요하게 실행되므로 예상치못한 행동을 유발하며 비효율적입니다.

 이 문제에 대해 조금 생각해본다면, 해결책을 찾는것은 그다지 어렵지만은 아닐것입니다. 이처럼 단순히 split 매크로안에 지역 변수를 생성하면 됩니다:
[source]

 새로운 버전의 split안에 let1을 사용하였습니다. 여기서 보인것처럼 다른 매크로 안에서의 매크로의 사용은 완벽하게 돌아갑니다okey.

 이제 이전 예제를 다시 돌려본다면, 정확하게 statement를 한번만 princing 하는 split을 볼 수 있을 것입니다:
[output]

 불행히도, 아직도 이 새로운 split 매크로 버전에는 또다른 버그를 야기합니다introduce. 다음으로가서 이 새로운 버그와 맞붙어봅시다.


Avoiding Variable Capture
 split 최신 버전에 있는 버그를 보기 위해, 다음을 실행해 봅시다:
[output]

 어떠한 일이 일어났습니까? 저희는 방금 split 매크로의 새로운 버전안에서 변수 x를 생성하였습니다! 여기 이를 macroexpand 한다 했을때 split이 호출한 것이 있습니다.
[output]

 split의 expanded된 버전은 x의 정의를 포함하고 있습니다. 문제가 있는 저희 예제에서 이는 경쟁competing 정의를 막습니다. 이러한 경우, split 매크로는 뜻하지 않게 변수 x를 잡아 예상치 못한 방식으로 이를 덮어써버립니다. 어떻게 이러한 문제를 피할 수 있을까요?

 하나 단순한 해결책은 매크로 안에서 변수 x를 만들지 않고, xqweopfjsadlkjgh처럼 기괴하게 긴 이름을 갖는 변수를 이용하는 것입니다. 그리하면 매크로에서 사용되는 변수가 코드에서 이를 사용하는 변수이름과 충돌나지 않을 것이라는 확신이 들 것입니다. 사실, 정확히 이 목적에 맞게 괴상한cracy 변수 이름을 생성하는 gensym이라 불리는 Common Lisp 함수가 있습니다.
[output]

 gensym 함수는 여러분을 위해 코드에서 다른 변수 이름과 절대 충돌나지 않는 다는걸 보장하는 고유한 변수 이름을 생성할 것입니다. 여러분은 이가 이와 다른 이름을 구분하는 특별한 prefix (#:)를 지녔다는 것을 인지하였을 것입니다. Common Lisp는 이러한 gensym-기반한 이름을 특별한 방식으로 다루며 gensym 변수의 이름을 직접 사용하는 것을 막습니다.

 이제 변수가 잡히는 것을 방지하기 위해 split 매크로 안에서 gensym 함수를 사용해 봅시다:
[source]

 개정된 매크로의 첫번째 라인에서, gensym 이름을 담은 변수 g를 정의하였습니다. 이 라인의 선두에 역 따옴표가 없다는 것은 매우 중요합니다. 이는 이 코드의 라인은 런타임이아니라 매크로 확장 시간에 있다는 것을 의미하며, 이 시점에서 변수 g를 정의하는 것은 괜찮습니다. 그러나 다음 라인에서 let1은 이 앞에 역따옴표가 있습니다. 이 라인은 런타임에서 실행될 것이며, 이 지점에서 하드코드된 변수를 사용하지 않을 것입니다. 새로운 버전에서, 고유한 이름을 이용하는 대신 g에 저장된 gensym 이름을 이용하였습니다.

 이제 split 매크로가 사용될 때마다, 내부 값을 유지하기 위해 고유한 이름이 생성됩니다. macroexpand를 통해 몇몇 예제를 톨려 봄으로써 이를 테스트할 수 있습니다:
[output]
<<<<<<< HEAD
ab
=======

>>>>>>> f157348ff2d3eeaa56e4ad6d5cb8c1fa4a7ce303
#=======================###############################
지역 변수

Notice how a differently named local variable was created in both instances 
XY.

이는 보장합니다
변수의 이름이
 This guarantees that the variable name will not only be unique within 
your code, but will also be unique if the split macro is ever used multiple 
times in a nested fashion.

 We have now created a fully debugged version of 
our split macro.


Just because it is now bug-free does not mean that it is free of variable 
capture.

 Note that the macro still defines the variables head and tail. If you 
used this function in other code in which head or tail had an alternate meaning
your code would fail!

 However, in the case of head and tail, the capture is on 
purpose.

 In this situation, the variable capture is a feature, not a bug?it is an 
anaphoric macro.

 As we’ve discussed, this means that it makes named variables 
or functions available that we can use in the body of the macro.


A Recursion Macro
Let’s take another look at our improved my-length macro:
[source]

As we discussed, there is an additional repetitive pattern in this code: 
The creation of a local function f. Let’s write another macro that gets rid of 
this additional visual noise: recurse. Here’s an example of the recurse macro 
in use:
[output]

The first parameter into the recurse macro is a list of variables and their 
starting values X. In this case, we’re declaring only one variable (n) and set-
ting its starting value to 9. The rest of the lines in the macro make up the 
body of the recursive function.
The first thing we do in the body is start a fresh line Y. Then we check if 
n has reached zero yet Z. If it has, we print “lift-off!” [. Otherwise, we print 
the current number \ and call the function again, recursively. Like our split 
macro, the recurse macro is anaphoric. In the case of recurse, it makes a 
function named self available, which we call when we’re ready to perform a 
recursion ]. We also subtract one from n at this point to lower the count-
down number.
Now that we’ve seen how recurse should work, let’s write this recurse macro. 
In order to process the list of arguments and starting values, it’s useful for us 
to have a function that can group items into a list of pairs. Here is a function, 
pairs, that accomplishes this:

[output]

The pairs function is a tail-call-optimized list-eater, which, ironically, has 
its own local function f X. (Shortly, we won’t need to declare such a function 
anymore.) It uses split to break an item off the list Y. However, since it 
needs to process two items (a pair) from the list at once, we need to run an 
additional check to see if the tail is empty Z. If there are no items in the list 
] (or only one item left \), we return our accumulated values. Otherwise, 
we recursively process the rest of the list, with a new pair of items placed into 
the accumulator [.
Now we’re finally ready to write the recurse macro:

[source]

As you can see, it simply transforms the recursion into a traditional 
local function. First, it uses our new pairs function to take apart the variable 
names and starting values, and puts the result into p X. Then it defines a 
local function simply named self. The variable names for self are the 
odd-numbered items from p Y. Since we want self to be accessible, ana-
phorically, from inside the macro, we use a plain name instead of a gensym 
name for this function. At the bottom of the macro, we then simply call 
self, passing in all the starting values Z.
Now that we’ve created the recurse macro, let’s once again clean up our 
my-length function using this new language construct:

[source]

As you can see, there is very little repetition or visual noise in this version 
of our my-length function. 
Now you can appreciate how helpful macros can be when trying to write 
clean, succinct code. However, a liberal use of macros will also require you 
to bear some costs that you need to be aware of. We’ll look at the potential 
downsides to macros next.
Macros: Dangers and Alternatives
Macros allow us to write code that generates other code, making the Lisp 
languages a wonderful tool for metaprogramming and prototyping new 
language ideas. But, at some level, macros are just a sleight of hand: They 
let you trick the Lisp compiler/interpreter into accepting your own cus-
tomized language constructs and treating them like standard Lisp. They 
are indeed a powerful tool in a programmer’s tool chest, but they are not 
as elegant as some of the other programming tools you’ve encountered in 
this book.
The main drawback of macros is that they can make it hard for other 
programmers to understand your code. After all, if you’re creating your own 
language dialect, other programmers won’t be familiar with it. Even your 
future self?say, in a year or two?may have a hard time understanding the 
structure of your code if you’ve made heavy use of macros. Because of this, 
experienced Lispers will do their best to use alternate techniques to macro 
programming whenever possible. Often, a beginning Lisper will write a macro 
in situations that could be addressed in other, cleaner ways.
For instance, it’s fun to see how we were able to clean up our my-length 
function by adding a couple of macros named split and recurse. However, 
in the previous two chapters, you learned about another tool, functional 
programming, which can also be used to clean up list-eater functions. One 
powerful function often used by functional programmers is reduce. It is a 
higher-order function that accepts a function and a list, and will call the 
function once for every value in the list. Here is the my-length function rewrit-
ten to use the powerful reduce function, rather than macros:
[source]

보디사디피, 이 새로운 my-length 버전은 이전 버전을 쉽게 날려버립니다


 It is shorter, and it doesn’t rely on any of the nonstandard macros 
that we created.
The first argument to reduce holds our reduction function X. Its job is to keep 
track of, and update, an accumulated value, here named x. This variable x 
will hold the current accumulated value, which in this case will be the length 
of the list so far. This means we can simply add one to x to update it to its new 
value Y. Since the reduction function will be called once for every item in 
the list, it will, in the end, generate the length of the list. (The reduction func-
tion also receives, as an argument, the current item in the list, here given as 
the variable i. However, we do not need it for calculating the list’s length.) 
The next item passed to reduce is the list we want to reduce Z. Finally, since 
the accumulated length we’re calculating should have an initial value of zero, 
we indicate this by setting the :initial-value keyword argument to zero [.
Clearly, there are other scenarios where the list-eater macros we’ve created 
in this chapter are still useful. There are many cases where the reduce function 
could not be so easily used. So in the end, there are still many situations where 
creating your own Lisp dialect is exactly the right solution to a problem, as 
you’ll see in the next chapter.


What You’ve Learned
 이번장에선 매크로 프로그래밍에 대해 다뤘습니다. 여러분은 다음 내용들을 배웠습니다:

매크로는
코드를 작성하는 코드를 작성하게 해준다.
매크로로 여러분은 여러분만의 프로그래밍 언어를 만들 수 있으며 이를 표준 Lisp로 변환 할 수 있습니다
컴파일ㅓ가
z Macros let you write code that writes code. With macros, you can create 
your own programming language and convert it to standard Lisp just 
before the compiler can get a peek at it.


z Macros allow you to get rid of that feeling of deja vu when writing your 
code, in situations when nothing else can do so.
매크로를 작성할때에 조심해야 한다

z You must be careful when writing macros so that they don’t lead to unin-
tentional, repeated execution of code.

z You need to be careful to avoid unintended variable capture in macros. 
You can avoid this by using gensym names.

매크로에 의해 생성된 변수가
매크로의  노출된다면,
이러한 매크로를 anaphoric 매크로라 부른다.
z If variables created by a macro are exposed on purpose, as a feature of 
the macro, the macro is called an anaphoric macro.

z 매크로 프로그래밍은 매우 강력한 기법이다. 그러나, 가능하다면 문제를 해결하는데 함수형 프로그래밍을 이용하시기 바랍니다. 매크로는 항상 마지막 피난처가 되야합니다.