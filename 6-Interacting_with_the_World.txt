6장.세상과 소통 : Lisp로 읽고 쓰기


 지금까지, 저희는 세상과 직접적으로 소통하는 어떠한 코드도 작성하지 않았습니다. 대신, 명령어로 생성된 모든 결과들을 단순히 값으로 반환하였으며, 저희는 Lisp REPL로부터 함수를 호출함으로써 이를 볼 수 있었습니다.

 그러나, 코드는 블랙박스에만 있지 않습니다. 세상과 소통할 필요가 있을 시점에서, 이것은 사용자 인터페이스가 필요할 것입니다. 다행히도, Lisp는 사용자 인터페이스를 만드는데 많은 도움을 줍니다. 다양한 Common Lisp의 취향을 위해 많은 그래픽 사용자 인터페이스와 웹 인터페이스를 위한 라이브러리들이 있습니다. 사실, 저희는 13장에서 모의 웹 서버를 띄울 것입니다.
 이번 장에서, 저희는 모든 사용자 인터페이스중 가장 기본적인 명령-라인 인터페이스에 중점을 둘 것입니다.
[PIC]


텍스트 읽고 출력하기
 명령-라인 인터페이스를 위해 우리는 직접 화면으로 텍스트를 출력하고 사용자로부터 입력된 텍스트를 읽을 수 있는 명령어가 필요합니다. 이러한 일을 할 두 명령어는 print와 read입니다. 예상했듯이, 이 두 명령어 사이에는 많은 대칭이 존재합니다.


화면에 출력하기
 print함수는 단순히 무언가를 콘솔로 출력할 수 있도록 합니다:
[CODE]

 print함수를 호출함으로써 "foo"가 두번이나 출력된 것으로 오해하지 않으시길 바랍니다. 첫번째 "foo"는 print함수가 실제로 출력된 것입니다. 두번째 "foo"는, 여러분이 아시다싶이 REPL은 항상 들어온 어떤한 표현식의 값을 출력하기 때문입니다. (print "foo")의 값이 "foo"이기 때문에, 두번이나 보이는 것입니다. 혼란을 피하기 위해서, 이번 장의 예제들에선 REPL로 출력되는 마지막 값을 제외할 것입니다.
 print함수는 Lisp값을 화면에 출력하는 간단한 방법입니다. 그러나, 숙련된 Lisper들은 보통 prin1이라 불리는 비슷한 함수를 선호합니다. 차이점을 이해하기 위해, 이 함수들이 REPL에서 나오도록 해 봅시다:
[CODE]

 print함수는 각 항목마다 분리된 라인으로 출력합니다. 이제 prin1을 해봅시다:
[CODE]

 보시다싶이, print1은 항목들을 분리된 라인으로 출력하지 않습니다. 정확하게, print는 항목을 출력하기 전에 새로운 라인으로 시작한 다는 점을 제외하면, print와 prin1명령어는 같습니다. 추가적으로, print는 출력된 값뒤에 공백문자가 붙습니다.
 prin1이 더 적게 행동을 함으로, 이는 매우 단순하고, 더 근복적인 함수입니다. 그러므로 이는 더욱 유연하며, 더 중대한 Lisp 코드에 주로 사용됩니다. 이 책에서는 print함수를 더 자주 사용할 것이지만, 여러분은 prin1명령어 또한 알아 두셔야 합니다.


사용자에게 인사하기
 다음 나오는 예제는 여러분의 Lisp 프롬프트에서 호출 할 수 있는 간단한 함수 say-hello입니다. 이는 사용자에게 그들의 이름을 물어보고 환영으로 답합니다. 이상하게 여길지 모르지만 프로그램을 실행하기 위해선, 여러분의 이름을 쌍따옴표로 묶으시기 바랍니다.
[CODE]

 say-hellow함수 첫번째 줄에서, 사용자 이름을 물어볼 것입니다. 그다음, 지역 변수 name을 정의하고, read함수로 반환된 값으로 설정합니다. read함수는 Lisp를 REPL에 무언가를 입력할 때 동안 기다리도록 합니다. 사용자가 무언가를 입력하고 ENTER를 누른후에야 변수 name이 설정됩니다. 사용자의 이름을 알게되었음으로, 사용자를 환영하는 문장을 출력합니다.
 이 간단한 함수에서 알 수 있듯이, print와 read함수는 (거의)정확하게 저희가 예상하는 것을 수행합니다. print함수는 무언가를 화면에 출력합니다. read함수는 사용자가 입력한 무언가를 프로그램에 넣읍니다. 그리고, 이 함수들의 특이한 성질이 하나 있습니다: 입력하거나 보여지는 모든 값들이 쌍따옴표로 둘러싸여있습니다.


print와 read로 시작하기
 무언가를 화면에 출력하길 원할때, 여러분은 우선 print명령어를 생각해야 합니다. 무언가를 읽어길 원할때, 여러분은 우선 read명령어를 생각해야 합니다. 다른 출력 명령어들이 이전 예제를 따옴표가 필요하지 않게 만들더라도, 여러분이 Lisp에서 입력 혹은 출력 작업을 할 때마다, 자기 자신에게 물어볼 것입니다 "read 혹은 print로 작업을 할 수 있을까?" 시작지점에서 항상 이 두 함수를 이용한다면, 많은 역경에서 여러분 스스로를 구하실 수 있으실 것입니다.

WARNING read명령어는 잘못된 방법으로 사용하였을 경우 위험할 수 있습니다. 자세히 알고 싶다면 101쪽의 "read와 eval의 위험성"를 살펴보시기 바랍니다.

 print와 read함수는 값에 대하여 인간의 관점이 아닌 컴퓨터의 관점으로 생각합니다. 컴퓨터는 쌍따옴표로 둘러싸인 텍스트 문자열을 사랑합니다. 인간의 뇌를 가지고 있지 않기 때문에, 가공되지 않은 텍스트 정보를 주면 의미를 이해할 수 없습니다. 그러나, 텍스트가 쌍따옴표로 둘러싸였다면, 컴퓨터라도 이 값을 텍스트 문자열로 다룬다는것을 구분할 수 있습니다.
 print와 read명령어는 극단적으로 이러한 철학을 취하였습니다. 이런 방식을 따름으로써 Lisp에서 이용가능한 데이터형식 대다수를(실제 함수들과 몇몇 진보된 data구조는 예외) 이 명령어를 사용하여 사소한 비트 손실없이, 출력이나 읽을 수 있습니다. 
 여러분은 아마 이미, 거대한 데이터조각을 파일에 작성하여 후에 이것을 다시 불러오는 것과 같은, 이러한 기능이 막대한 가치를 지닌 몇몇 시나리오를 상상했을 지도 모르겠습니다.
 간단한 예를 들어, 다음 코드는 이전 함수와 모양이 완벽하게 일치하지만, 놀랍게도 이것은 문자열 대신 숫자를 읽고 출력할 수 있습니다. 프로그램이 쌍따옴표를 사용하지 않고 숫자를 출력하고 읽을 수 있는데, Lisp는 어떤것이 숫자라는 것을 raw form에 있는 숫자를 보기만 해도 알기 때문입니다.
[CODE]

 값을 출력하는 print를 사용할때 무슨 일이 일어나는지 예제로 살펴봅시다.
[CODE]

 이 예제들은 실로 지루한데, 단순히 저희가 넣은 그대로 출력하기 때문입니다. 하나의 따옴표를 각 값들 앞에 넣었습니다. 이것은 심볼 이름을 제외한 모든 경우에서 생략되고 함축될 수 있는데, 심볼이 함수 또한 참조할 수 있기 때문입니다.
 마지막 예제는, Lisp에 들어온 문자 그대로 보여줍니다. Lisp 문자를 만드는 것은, 단순히 #\ 심볼을 실제 문자 앞에 넣는 것입니다. Lisp는 또한 안보이는 문자들을 위해 정의된 특수 문자들을 지녔습니다. 주로 사용하는 것중 가장 중요한 것들은 #\Newline, #\Tab, 그리고 #\Space입니다.
 read함수의 출력표는 동일한 대칭적 방식에서 print에 관한 표만큼 지루해 보입니다.

NOTE 위 예제에서 Common Lisp 심볼들이 문자형식으로 blind되었다는 것을 언급하였습니다. 대부분의 문자열에서 이는 사실이지만, 사실 세로로 된 파이프 |로 심볼을 감싸는 것으로 대소문자를-구분하는 심볼을 만드는 것이 가능합니다. 따라서 심볼 |CaseSensitiveSybol|은 대소문자를 유지할 것입니다. 세로로 된 파이프로 둘러싸인 심볼들은 구두점(punctuation, ;)도 포함할 수 있습니다. 이런 이유로 |심지어 이런것도 적법한 Lisp 심볼 입니다!|


인간처럼 읽고 출력하기
 물론, 저희 초기의 작은 say-hello 함수는 몇몇 흥미있는 속성들을 가졌지만, 사람들을 맞이하는데 있어 매우 끔짝한일을 합니다. 인간에 더 친화적으로 만들어진 많은 함수들을 가졌다면 더 좋았을 것입니다. 실제로, 저희는 저희가 원하는것을 요약한 (매우 대칭적인) 작은 표를 만들 수 있습니다.
[pic]

 보시다싶이, Lisp는 데이터조각을, 인간에게 매력적인 방법으로 출력할 수 있는 명령어들을 지녔습니다. princ함수는 어떤 Lisp 데이터 조각을 취할 수 있으며, 인간이 선호하는 방식으로 데이트를 출력하려고 노력합니다. 이는 여러분이 예상할 수 있는 기본적인 일을 합니다: 문자열에 쌍따옴표를 제외하고, raw form에 있는 문자들을 출력하고, 기타 등등. 여기 몇몇 예제들이 있습니다:
[CODE]

 여기 특별한 의미를 지닌 문자를 princing하는 예제가 있습니다:
[CODE]

 이것의 특성상, princ는 여러분이 원하는 암묵적인 출력 문자를 출력하는데 이용할 수 있습니다. 이는 print와 근본적으로 다릅니다. 이미 다뤘듯이, print명령어의 멋진 점은 객체들을, 그들의 내부 표현을 항상 "읽을 수" 있는 방식으로, 출력한다는 것입니다. 그러나, 이는 print가 어떤 암묵적인 텍스트 비트를 생성하는데는 사용할 수 없다는 것을 의미합니다. 반면, princ는 여러분이 원하는 것을 출력하는데 사용할 수 있습니다.
 그러므로, 비록 princ는 인간이 선호하는 방식으로 어떤것을 출력할 수 있지만, 이는 일방 통행입니다. princ로 출력한다면, 인간의 지능만이 의미 있는 적절한 Lisp 데이터구조로 어떻게 바뀌는 지 해독할 수 있습니다. 이는 이러한 작업을 당장 수행하기에는 컴퓨터가 멍청하기 때문에, 저희들의 소중한 대칭성이 파괴되었다는 의미합니다.
 물론, 편법을 써 컴퓨터가 인간이 입력한 것들을 해석하는 몇몇 암묵적인 규칙을 만들 수 있습니다. 이것을 행하는 한가지 명백한 방법은 컴퓨터에게 말하는 것입니다 "그들이 ENTER키를 치기 전까지 유저들이 무언가를 입력하도록 하고, 그런 다음 전체를 문자열로 취급하라". Common Lisp에서 이러한 일을 하는 함수를 read-line이라고 부릅니다. 그러나, 이것은 read, print,그리고 princ 함수의 철학을 가지고 있지 않기 때문에, 이것은 문자들과 문자열이상의 것에 대해 알지 못합니다.
 이 새로운 지식으로, 저희는 마침내 기나긴 여정을 마쳐, 못생긴 쌍따옴표나 다른 이상한 부분 없이 누군가를 환영하는 적절한 함수를 만들 수 있게 되었습니다:
[CODE]

 이번 say-hellow함수는 처음 것과 유사합니다. 그러나, 이제는 컴퓨터가 사용자에게 그들의 이름을 입력할때 쌍따옴표로 둘러싸여진 텍스트 문자열을 출력하지 않습니다. 환영인사를 출력할 때도 같습니다. 또한, 사용자는 이제 (공백이나 따옴표를 포함한)어떤 이름도 입력할 수 있는데, read-line명령어가 ENTER 키를 누르기 전까지 입력된 모든 텍스트를 불평없이 받아 반환하기 때문입니다.


Lisp에서 코드와 데이터간의 대칭성
 저희는 Lisp가 바깥세상으로부터 가공되지 않은 문자열 데이터 form을 해석하고 Lisp 문법 표현식으로부터 변환하는, 매우 우아한 대칭성을 지닌 보았습니다. 그러나 Lisp는 더욱 심오한 대칭성을 가지고 있습니다. 그것은 프로그램 코드와 데이터를 바꿔가며 다룰 수 있다는 것입니다. 프로그램 데이터와 코드를 저장하는데 동일한 데이터 구조를 사용하는 프로그래밍 언어를 homoiconic이라 합니다.
 저희는 homoiconicity의 예를, 3장 코드모드와 데이터모드를 다룰때 살펴봤습니다. 그 예제에서, 저희는 두 방식을 전환하기 위해 따옴표를 사용하였습니다:
[CODE]

 이전 장에서, 저희는 describe-path함수를 정의할때 quasiquote 를 사용하면서, 이 개념에서 하나의 단계 더 나아갔습니다.
 그러나, Lisp에서 quoting과 quasiquoting기능은 그들의 능력에서 안에서 약간 제한적입니다. Lisp 코드 조각을 생성해놓고 이것이 예전에 코드 조각이였던 것처럼 실행되길 원한다면 어떻게 될까요? 예를들어, 순수한 코드 덩어리를 변수에 저장해 봅시다:
[CODE]

 어떻게 *foo*변수에 저장된 코드를 실행할 수 있을까요? 저희는 이를 가능하케하는 더 강력한 명령어가 필요합니다. eval 명령어 입니다:
[CODE]

 eval명령어는 매우 강력하면서 매우 단순하기 때문에, 초급 Lisper들에게 매우 매력적입니다. 저절로-변화하는 코드를 지닌 프로그램을 작성하고 싶다면? eval은 여러분의 가장 친한 친구가 될 것입니다. 사실, 이것이 인공지능(AI)에 광적인 사람들이 예전에 Lisp를 많이 사랑했던 주된 이유입니다. 앞서나가서 eval 명령어를 사용하는 프로그램을 작성해 보십시오. 여러분은 더 많은 재미를 찾게될 것입니다.
 그러나, 숙련된 Lisper는 eval을 드물게 사용합니다. 여러분이 수천줄의 Lisp 코드를 경험하기 전까지, 실제로 매우 강력한 이 명령어를 사용하기 적절할 때를 알 수 없을것입니다. 종종, 초급 Lisper는 Lisp macro를 정의하는것 대신에 eval명령어를 사용할 것입니다. 16장에서 macro를 다룰 것입니다.
 마지막 줄이 Lisp에서의 코드와 데이터 대칭이 Lisp를 homoiconicity의 대명사로 만드는 것입니다. Quoting, quasiquoting, eval 명령어, 그리고 macros는 여러분의 code를 풍족하게 만들어 줄 것입니다.

WARNING 미숙한 eval사용은 보안을 위협할 수 있습니다. 더 많은 정보를 원하신다면 101쪽의 “read와 eval의 위험성"을 살펴보시기 바랍니다.


게임 엔진에 사용자 인터페이스 추가하기
 지금까지, 우리는 게임 명령어를 입력받는데 Lisp REPL을 이용하였습니다. 저희 게임의 프로토타이핑으로써 이러한 일을 한건 놀랄만한 일입니다. 그러나 이제 여러분은 기본 Common Lisp 입력과 출력 명령어에 대해 이해를 하였고, 여러분은 플레이어와 소통하기에 더 알맞은 사용자 텍스트 게임 인터페이스를 넣을 수 있습니다.


사용자 REPL 만들기
 Lisp에서 여러분만의 REPL을 만드는 것은 어처구니없게도 너무 쉽습니다. 여기 저희 게임을 위한, 표준 REPL에서 했던 것과 같이 look명령어를 호출하도록 하는, 단순한 사용자 REPL이 있습니다: 
[CODE]

 만약 이 game-repl의 설명이 이해가 가지 않는다면 잠깐 멈추기 바랍니다: 처음 이것은 명령어를 읽고, 평가한 다음, 마침내 출력합니다. (10장에서 자세히 다룬) 여러분이 전에 보지 못한 명령어 loop는, 여러분이 예상할수 있듯이 단순하게 loop를 영원히 도는것입니다. (CLISP에서 여러분이 무한루프에서 빠져나오려면 CTRL-C와 :a를 입력해야만 합니다.) 보시다싶이, 여러분만의 REPL을 read, eval, print와 loop를 단순히 호출하는것으로 쉽게 만들 수 있습니다.
[PIC]

 물론, REPL의 행동을 수정하여, 저희만의 함수를 호출하길 원합니다. 또한, 더욱 우아한 방법으로 게임을 종료하길 원합니다. 그러므로, game-repl을 다음과 같이 재정의 합시다:
[CODE]

 이번 버전에서는, 우선 플레이어가 입력한 명령어를 지역변수 cmd를 이용하여 붙잡아 둡니다. 이러케 함으로써, quit의 호출을 가로체서 game-repl을 빠저나가는데 이용할 수 있습니다. 다시말하자면, 저희는 quit를 입력하기 전까지 REPL이 계속될 것입니다. 그렇지 않다면, 저희가 곧 작성할 사용자 함수를 이용하여 그 함수를 평가하고 출력할 것입니다. 마지막으로, game-repl함수는 저희가 나가기로 결정하지 않는한, 자기 자신을 재귀적으로 호출하여 되돕니다.


사용자 read 함수 작성하기
 game-read함수의 목적은, 표준 Lisp가 저희 게임을 진행을 위한 함수를 잘못읽는 두 골칫거리를 바로잡기 위해서 입니다:

z 표준 Lisp read는 괄호로 둘러싸인 명령어를 읽도록 강요합니다. 고전 텍스트 어드벤처 플레이어라면 아시겠지만, 괄호없이 단지 look이라고 입력할 수 있었습니다. 이를 완료하면, read-line을 호출하여 괄호를 넣을 수 있을 것입니다.
z read에서는, 어떤 함수 명령어 앞에 따옴표를 붙여야만 합니다. 따옴표를 east앞에 붙이지 않고 walk east를 입력할 수 있어야만 합니다. 이를 위해, 어떤일을 끝낸 다음에 인자 앞에 따옴표를 삽입할 것입니다.
[PIC]

 여기 이러한 것들을 수행하는 game-read 정의가 있습니다:
[CODE]

 read-from-string명령어는 read명령어 처럼 동작하나, 문법 표현식(혹은 어떤 다른 기본 Lisp 데이터형식)을 콘솔에서 직접 얻어오는 대신 문자열로부터 읽어오도록 합니다.
 저희가 사용하는 문자열은 read-line으로부터 얻어온 개량된 버전입니다. 괄호뿐만아니라 문자열을 연결시킬때 사용할 수 있는 concatenate명령어를 사용하여, 이를 쌍따옴표로 둘러싸 변경시킵니다. 결과로 cmd변수가 플레이어가 요청한 명령어로 설정되고 Lisp 문법 표현식으로 전환됩니다. 예를들어, 만일 플레이어가 walk east라 입력하면, cmd 변수는 두 심볼을 포함하고 있는 리스트 (walk east)라 설정됩니다.
 다음으로, 우리는, 명령어에서 플레이어가 지닌 어떤 인자들을 인용하는데 사용할 수 있는, quote-it이라 불리는 지역변수를 정의합니다. 어떻게 인자를 인용하는 것을 정확하게 처리 할 수 있을까요? 따옴표는 quote라 불리는 Lisp명령어의 약칭입니다. 이것은 'foo와 (quote foo)가 서로 같다는 것을 의미합니다. raw 인자들을, 단순히 인자에 quote명령어를 앞에 붙여 리스트에 넣음으로써, 인용할 수 있습니다.
 지역 함수를 labels나 flet으로 정의할 수 있다는 것을 기억하시길 바랍니다. quote-in함수 안에서 재귀를 사용하지 않기에, 더 단순한 flet명령어를 사용할 수 있습니다. game-read함수의 마지막 줄은 quote-it에 플레이어의 명령어에 있는 모든 인자를 적용하는 것입니다. cmd변수의 cdr를 quote-it에 mapping 시킵니다. (그 다음 cdr로 명령어에 있던 첫번째 단어를 다시 앞으로 추가 시킵니다)
 새로운 함수를 돌려봅시다:
[CODE]

 보시다싶이, game-read함수는 (저희 게임세상에 필요한)괄호와 따옴표를 붙일 수 있습니다!

NOTE 사용자 read는, 멍청한 플레이어가 속출할 수 있는 몇몇 제한된 점을 지니고 있습니다. 플레이어가 괄호과 일치하지 않은 "(look"과 같이 이상한 문자열을 입력할 수 있으며, 이는 game-read명령어에서 Lisp 예외를 유발시킵니다. 잘못된 입력에 표준 read명령어가 이상하게도 행동하는것 자체로는 별로 이상할 것이 없습니다. (이번 경우에선, 빠진 괄호를 결국 보충해 줄거라는 희망속에 다른 줄의 입력을 받을 것입니다) 그러나, 저희 game-repl은 이러한 상황을 충분히 다룰 수 없으므로, game-repl의 다운을 유발시킵니다.이것은 만일 여러분이 Zork를 플레이하다가 명령어를 쳤을때 매우 불쾌하게 게임 자체가 다운되는 것과 같습니다. 이러한 드문 상황들을 13장에서 다루게 될 추가적인 예외 처리로 처리할 수 있습니다.


game-eval 함수 작성하기
 이제 저희는 거의 완벽한 Lisp reader를 만들었으므로, 어떻게 eval 명령어를 향상 시킬지를 생각해봅니다. 게임에서 eval을 사용함에 있어 문제점은, 게임에 관계없는 다른 Lisp명령어를 호출하는 것을 허용한다는 것입니다. 해커로부터 프로그램을 보호하기 위해, 다음과 같이 호출 할 수 있는 특정 명령어만 허용하는 game-eval함수를 만들 것입니다.
[CODE]

 game-eval함수는 member 함수를 사용하여 전체 명령어에 있는 첫번째 단어가 허용된 명령어 list에 있는지를 확인합니다. 만약 있다면, 표준 eval을 사용하여 플레이어의 명령어를 실행합니다. 플레이어가 호출한 명령어가 공식 목록에 있는 것을 확인함으로써, 유해한 명령어를 호출하는 것을 방지 할 수 있습니다.
[PIC]

WARNING game-eval함수는 해킹을 완벽히 막지는 못합니다. 자세한 사항은 101쪽의 "read와 eval의 위험성"를 참조하시기 바랍니다.


game-print 함수 작성하기
 game-repl 시스템에서 빠진 마지막조각은 game-print함수 입니다. 저희 게임의 Lisp REPL 버전에서 제한된 것 중에 한가지 명백한것이 있습니다: 게임에서 모든 텍스트 서술문들이 대문자로 출력된다는 것입니다.
 밀레니엄을 거치면서, 제가 보아온 바로는 컴퓨터는 대문자와 소문자를 출력 할 수 있습니다. game-print함수를 작성함으로써, 이러한 문제를 해결할 수 있습니다. game-print 함수의 코드로 가기 앞서, 이것의 출력 예제를 살펴 봅시다:
[CODE]

 보시다싶이, game-print 함수는 심볼 기반으로 작성된 것을 적절하게 대소문자로된 텍스트로 변환시켜 줍니다. 이 함수를 가짐으로써, 저희는 게임 엔진에 있는 가능한 가장 알맞은 형식으로, 텍스트를 저장할 수 있습니다: 심볼 리스트. 이러한 형식은 텍스트 조작을 쉽게 만들어 줍니다. 표현의 관점에서, 이러한 심볼리스트들을 세부표현사항으로 꾸밀수 있습니다.
 물론 이번 예제에서, 꾸밈은 매우 간단합니다. 저희가 해야 할 일은 조건을 조정하는 것입니다. 그러나 여러분은 이미 데이터 모델에 존재하는 세부항목을 분리하는것에 대한 몇몇 작은 이점을 볼 수 있었습니다. 예를 들어, 저희가 describe-path함수가  "Left of here lies a door."와 같은 문장을 작성하도록 바꾼다고 가정해봅시다. 어떠한 추가 수정이 필요하지 않습니다; 프로그램은 문장의 시작부에 있는 Left를 대문자로 바꿔야 한다는 것을 자동적으로 알게될 것입니다.
 그러나 진가는, HTML 코드를 생성하는 것과 같은, 더욱 정교한 표현방법을 원할때 나타날 것입니다. 여러분은, 여러분의 게임에서 색상이나, 폰트, 기타등등 을 바꾸는것 처럼 화려한 텍스트를 보여주기 위해, 사용자 문법을 포함하기 원한다고 합시다. 예를 들어, 다음과 같이 괄호를 포함하는 게임 설명문을 허용할 수 있습니다. "당신은 (red 사악한 악마)에 의해 공격받고 있습니다."그런 다음 여러분은, 빨간 색으로 둘러싸여진 텍스트를 출력하기 위해, game-print 함수에서 red 키워드를 잡을 수 있습니다. 17장에서 이것으로 간단하게 HTML 표현시스템을 만들 것입니다.
[PIC]

 이제 저희는 game-print함수의 코드를 살펴볼 준비가 됬습니다:
[CODE]

 game-print함수와 이를 도와주는(helper) 함수는 이제까지 보아왔던 다른 함수보다 좀 더 복잡합니다. game-print에서 실행되는 코드에서 첫번째로 중요한 부분은, (고치기 원하는 형태를 포함하는)심볼 리스트를 Lisp의 많은 print 변종중 하나인 prin1-to-string를 통해 문자열로 변환 시키는 곳입니다. to-string 의미는, 이 함수는 결과를 화면으로 보내지 않고, 이것을 문자열로 반환하겠다는 것입니다. 1이 의미하는 것은 한줄로 붙인다는 것입니다. 표준 print 명령어는 개행 문자를 포함하고 뒤에 공백이 붙습니다. prin1과 prin1-to-string 변종은 이러한 추가 문자들을 더하지 않습니다.
 다음으로, game-print는 coerce함수로 문자열을 문자리스트로 변환시킵니다. 문자열을 리스트로 coercing함으로써, 저희는 리스트를 처리하는 문제를 지닌 함수의 큰 짐을 줄일 수 있습니다. 이는 곧 Lisp 안전지대입니다. 이 경우에선, 저희는 수정하고자 하는 텍스트를 구성하는 문자리스트를 만들 것입니다.
 이제 저희는 list-eater 함수인 tweak-text로 데이터를 보낼 수 있습니다. game-print함수의 코드에서 사용되는 일부 인자들이 명료성을 위해 줄맞추어 쓰여져 있습니다. 식별자를 살펴 봄으로써 저희는 인자들이 의미하는 것이 어떤 명령어인지를 쉽게 알 수 있습니다. 예를들어, t와 nil인자는 tweak-text에 속해 있습니다.
 tweak-text함수는 list에 있는 각 문자들을 살펴보고 필요하다면 수정합니다. 이 함수의 처음 부분에서, tweaking할 문장 앞부분에서 항목을 잘라내어, 지역변수 item과 rest 두개를 정의합니다. 그런 다음, tweak-text함수는 서로 다른 조건에 대해 list의 상단에 있는 문자를 확인하기 위해 cond를 사용합니다.
 이것이 확인하는 첫번째 조건은 어떤 문자가 공백 문자인가 입니다. 만약 그렇다면, 공백을 바꾸지 않고 놔두고 리스트에 있는 다음 문자를 처리합니다. 만일 문자가 마침표, 물음표, 느낌표라면, 다음 심볼이 문장의 처음이고 나머지 문자열을 대문자로 나타내야 한다는 것을 표시하기 위해 cap을 on시킬 것입니다.
 저희는 또한 쌍따옴표가 어디에 있는지 확인할 것입니다. 드물게, 이러한 일을 하는 이유는 심볼리스트가 영문으로 부호화 되기에 부적합하기 때문입니다. 예로 쉼표(쉼표는 표준 Common Lisp symbol로 허용되지 않습니다.)를 지니거나 표준이 아닌 대소문자로 나타내는 제품이름이 있습니다. 이번 경우에, 저희는 문자열 텍스트 사용에 기댈 수 있습니다. 여기 예제가 있습니다:
[CODE]

 실제로 저희 샘플 게임에선 되돌리는 기능이 필요하진 않습니다. 그래도, 이 기능은 game-print함수가 게임을 확장시키면서 마주치게될 많은 예외적인 텍스트 환경을 처리하도록 해줍니다. 재귀 호출에서 lit 변수를 on으로 전환함으로써, 대문자를 문자그대로 보여지도록 할 수 있습니다. 이 변수가 설정되면, tweak-text함수는 대문자로 시작하는 규칙을 유지합니다.
 다음으로 tweak-text함수는 다음 문자가 대문자를 지원하는지 여부를 검사합니다. 만약 그렇다면, char-upcase함수를 이용하여 list에서 다음 항목을 처리하기 전에 현재 문자를 (이미 대문자가 아닌 경우) 대문자로 바꿉니다.
 다른 조건들을 만족하지 못하면, 현재 문자가 소문자라는 것을 알게 될 것이며, char-downcase함수를 이용하여 이것을 변환시킬 수 있습니다.
 다음으로 tweak-text가 끝난 후에 문자 list에 있는 텍스트들을 모아, game-print함수는 이것을 적절한 문자열로 coerces하고 princs 합니다. game-print마지막에 있는 fresh-line 함수는 화면에 보여지는 다음 항목이 새로운 라인에서 시작되도록 만듭니다.
 이제 저희는 데코레이션을 이용하여 원본 심볼리스트를 화면에 출력하는, 어드벤처 게임 엔진에 필요한 작업을 마쳤습니다.


멋진 새로운 게임 인터페이스를 실험해 보기
 이제 저희 게임에서 사용자 REPL에 필요한 부분들을 모두 완료하였습니다. 단순히 game-repl함수를 호출하여 새로운 게임 세계를 탐험해 보시기 바랍니다. 17장에서, 이 게임 엔진을 추가 명령어를 갖는 완전한 게임으로 확장시킬 것이라는 것을 명심하시기 바랍니다.
[REPL]

 훌륭합니다! 저희는 이제 매우 유연한 텍스트 게임 엔진을 갖게 되었습니다. 이것은 확장할 수 있고 Lisp REPL로 디버그 할 수 있습니다. 또한 자유롭게 수정할 수 있고 자연스러운 텍스트 어드벤처 경험을 사용자에게 제공해주는 인터페이스를 지녔습니다. 진행을 같이 하면서, 저희는 땜빵 코드나 다른 오버헤드를 최소화하여 엔진을 제작하는, 꿈같은 Lisp 기법들을 보았습니다.
[PIC]


read와 eval의 위험성
 저희는 eval과 read명령어를 사용자 Lisp REPL을 만들면서 사용하였습니다. 이러한 명령어들은 매우 강력하면서, 매우 위험합니다. 충분한 주의를 기울이지 않고 사용하면, 해커에게 여러분의 소프트웨어에 대해 악성 명령어를 실행시키는 공격을 허용하게 됩니다.
 예를 들어, 우리 프로그램이 format-harddrive라 불리는 함수가 필요하다고 가정해 봅니다. 무관한 이용자의 접근을 원하는 함수가 아니며, 만일 해커가 우리 게임 REPL속에 이것을 호출하도록 속인다면 매우 위험해 질 수 있습니다.
 이번 장에서 저희가 쉽게 만든 game-eval함수는, 플레이어가 게임 명령어로 format-harddrive를 입력하는 것을 방지하는, 단순한 보호장치를 지니고 있습니다. 여기 새로운 게임 REPL에 이 명령어를 치면 어떤 일이 일어나는지가 나와있습니다:
[CODE]

 저희 game-eval함수는 오직 승인된 목록에 있는 명령어만을 실행할 것입니다. 이는 게임에게 해킹으로부터 사용자를 보호하면서, 명령어를 평가하여 Lisp의 power에 접근하도록 허용하는 방화벽의 한 종류를 제공합니다.
 그러나, 더욱 정교한 플레이어는 exploit을 시도할 지도 모릅니다. 예를들어, walk (format-harddrive)라고 입력 하였습니다. 우연히도, 저희 game-read함수는 모든 함수 인자들을 quote-it을 이용하여 데이터 모드로 바꿉니다 game-read에서 quote-it를 사용하면, 실행된 실제 코드는 (walk '(format-harddrive))입니다. (format-harddrive)앞 따옴표는 악성 명령어를 데이터모드로 변환시켜, 나쁜일이 발생하지 않습니다.
 프로그램을 다운시키는 공격 방법중 하나는 reader macro를 사용하는 것입니다. 이는, 악성 컴퓨터 코드로 가는 새로운 문을 열게하는, Common Lisp read 명령어에 내장된 진보된 기능 집합입니다. (게임 명령어로 eval을 사용하기 전에, read를 먼저 거친다는 것을 기억하시기 바랍니다) 악의적인 코드를 성공적으로 실행시키는 게임 명령어의 예는 walk #.{format-harddrive} 입니다.
 마지막 줄은, eval이나 read를 사용하는 Lisp 프로그램이 해커로부터 완벽히 안전하다고 확신 할 수 없습니다. Lisp 코드를 작성할때, 가능한 이 두 명령어를 사용하는 것을 피해야 합니다.


여러분이 배운것
 이번장에서, 텍스트 어드벤처 게임을 박력있게 만들기위해 사용자 REPL을 만들었습니다. 이러한 과정속에서, 여러분이 배운것은 다음과 같습니다:

z print와 read함수는 콘솔을 통해 사용자와 직접적으로 대화를 한다. 이 두 함수는 컴퓨터-친화적으로 일합니다.
z 다른 입력/출력 함수들은 read와 print만큼 우아하진 않지만, 인간과 상호작용할때 더욱 친근하다. 예로 princ와 read-line이 있습니다.
z homoiconic 프로그래밍 언어는 프로그램 code와 data를 동일한 형태로 저장한다. Lisp의 quoting, quasiquoting, eval과 macro기능은 이를 극도로 homoiconic하게 만듭니다.
z 사용자 REPL을 작성하는 것은 쉽다.
z 내부 Lisp 데이터를 프로그램의 인터페이스에 맞도록 변환하는 것은 간단하다. 이것은 프로그램의 내부 데이터구조로부터 세부표현사항을 분리하는 것을 쉽게 만들어 줍니다.