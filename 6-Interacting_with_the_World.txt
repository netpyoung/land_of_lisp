INTERACTING WITH THE WORLD: READING AND PRINTING IN LISP
6장.세상과 소통 : Lisp로 읽고 쓰기

 지금까지, 저희는 세상과 직접적으로 소통하는 어떠한 코드도 작성하지 않았습니다. 대신, 명령어로 생성된 모든 결과들을 단순히 값으로 반환하였으며, 저희는 Lisp REPL로부터 함수를 호출함으로써 이를 볼 수 있었습니다.

 그러나, 코드는 블랙박스에만 있지 않습니다. 세상과 소통할 필요가 있을 시점에서, 이것은 사용자 인터페이스가 필요할 것입니다. 다행히도, Lisp는 사용자 인터페이스를 만드는데 많은 도움을 줍니다. 다향한 Common Lisp의 취향을 위해 많은 그래픽 사용자 인터페이스 라이브러리와 웹 인터페이스를 위한 라이브러리들이 있습니다. 사실, 저희는 13장에서 모의 웹 서버를 띄울 것입니다.

 이번 장에서, 저희는 모든 사용자 인터페이스중 가장 기본적인 명령-라인 인터페이스에 중점을 둘 것입니다.
[PIC]


Printing and Reading Text
 명령-라인 인터페이스를 위해 우리는 직접 화면으로 text를 출력하고 사용자로부터 입력된 text를 읽을 수 있는 명령어가 필요합니다. 이러한 일을 할 두 명령어는 print와 read입니다. 예상했듯이, 이 두 명령어 사이에 많은 symmetry이 있습니다


Printing to the Screen
 print함수는 단순히 무언가를 console로 출력할 수 있도록 합니다:
[CODE]

 print함수를 호출함으로써 "foo"가 두번이나 출력된 것으로 오해하지 않으시길 바랍니다. 첫번째 "foo"는 print함수가 실제로 출력된 것입니다. 두번째 "foo"는, 여러분이 아시다싶이 REPL은 항상 들어온 어떤한 표현식의 값을 출력하기 때문입니다. (print "foo")의 값이 "foo"이기 때문에, 두번이나 보이는 것입니다. 혼란을 피하기 위해서, 이번 장의 예제들에선 REPL로 출력되는 마지막 값을 제외할 것입니다.

 print함수는 Lisp값을 화면에 출력하는 간단한 방법입니다. 그러나, 숙련된 Lisper들은 보통 prin1이라 불리는 비슷한 함수를 선호합니다. 차이점을 이해하기 위해, 이 함수들이 REPL에서 나오도록 해 봅시다:
[CODE]

print함수는 각 항목마다 분리된 라인으로 출력합니다. 이제 prin1을 해봅시다:
[CODE]

 보시다싶이, print1은 항목들을 분리된 라인으로 출력하지 않습니다. 정확하게, print는 항목을 출력하기 전에 새로운 라인으로 시작한 다는 점을 제외하면, print와 prin1명령어는 같습니다. 추가적으로, print는 출력된 값뒤에 공백문자가 붙습니다.

 prin1가 더 적게 행동함으로, 이것은 매우 단순하고, 더 근복적인 함수입니다
그럼으로 이것은 더욱 유연하며, 더 중대한 Lisp code에 주로 사용됩니다. 이 책에서는 print함수를 더 자주 사용할 것이지만, 여러분은 prin1명령어 또한 알아야 합니다.


Saying Hello to the User 
 다음 나오는 예제는 여러분의 Lisp 프롬프트에서 호출 할 수 있는 간단한 함수 say-hello입니다.  이것은 사용자에게 그들의 이름을 물어보고 환영으로답합니다. 프로그램을 실행하였을때, 이상하게 보일지라도, 여러분의 이름을 쌍따옴표로 둘러싸시기 바랍니다.
[CODE]

 say-hellow함수 첫번째 줄에서, 여러분은 사용자 이름을 물어볼 것입니다. 그다음, 지역 변수 name을 정의하고, read함수로 반환된 값으로 설정합니다. read함수는 Lisp를 REPL에 무언가를 입력할 때 동안 기다리도록 합니다. 사용자가 무언가를 입력하고 ENTER를 누른후에야 변수 name이 설정됩니다. 사용자의 이름을 알게되었음으로, 사용자를 환영하는 문장을 출력합니다.

 이 간단한 함수에서 여러분이 알 수 있듯이, print와 read함수는 (거의)정확하게 여러분이 예상하는 것을 수행합니다. print함수는 무언가를 화면에 출력합니다. read함수는 사용자가 입력한 무언가를 프로그램에 넣읍니다. 그러나, 이 함수들의 특이한 성질이 하나 있습니다: 입력하거나 보여지는 모든 값들이 쌍따옴표로 둘러싸여졌습니다.


Starting with print and read
 무언가를 화면에 출력하길 원할때, 여러분은 우선 print명령어를 생각해야 합니다. 무언가를 읽어길 원할때, 여러분은 우선 read명령어를 생각해야 합니다. 다른 출력 명령어들이 이전 예제를 따옴표가 필요하지 않게 만들 더라도, 여러분이 Lisp에서 입력 혹은 출력 작업을 할 때마다, 자기 자신에게 물어볼 것입니다 "read 혹은 print로 작업을 할 수 있을까?" 시작지점에서 항상 이 두 함수를 이용한다면, 많은 역경에서 여러분 스스로를 구할 것입니다.

WARNING
 read명령어는 잘못된 방법으로 사용하였을 경우 위험할 수 있습니다. 자세히 알고 싶다면 101쪽의 “The Dangers of read and eval”를 봅니다.

 print와 read함수는 값에 대하여 인간의 관점이 아닌 컴퓨터의 관점으로 생각합니다. 컴퓨터는 쌍따옴표로 둘러싸인 text문자열을 사랑합니다. 이것은 인간의 뇌를 가지고 있지 않음으로, raw textual 정보를 입력할때 우리의 의미를 이해할 수 없습니다. 그러나 쌍따옴표로 text조각을 감싼다면, 심지어 멍청한 구식 컴퓨터라도 이 값을 text문자열로 다룬다는것을 구분할 수 있습니다.

 print와 read명령어는 극단적으로 이러한 철학을 취하였습니다. 이런 방식을 따름으로써 사소한 비트 손실없이, Lisp에서 가능한 data형식 대다수(actual 함수들과 몇몇 진보된 data구조는 예외)가 이 명령어를 사용하여 출력이나 읽을 수 있습니다. 이 기능이 막대하게 가치가 있다는 점에서 여러분은 아마 이미, 몇몇 흥미롭고 거대한 data조각을 파일에 작성하거나 후에 이것을 다시 불러오는 것과 같은, 몇몇 이야기 상상하였을 것입니다.

 간단한 예를 들어, 다음 코드는 이전 함수와 완벽하게 일치하는 모양(design)을 가졌으나, 놀랍게도 이것은 문자열 대신 숫자를 읽고 출력할 수 있습니다. 프로그램이 쌍따옴표를 사용하지 않고 숫자를 출력하고 읽을 수 있는데, 단지 이것의 raw form에 있는 숫자를 봄으로써 Lisp는 어떤것이 숫자라는 것을 알기 때문입니다.
[CODE]

 값을 출력하는 print를 사용할때 무슨 일이 일어나는지 예제로 살펴봅시다.
[CODE]

 이 예제들은 실로 지루한데, 단순히 저희가 넣은 그대로 출력하기 때문입니다. 하나의 따옴표를 각 값들 앞에 넣었습니다. 이것은 symbol 이름을 제외한 모든 경우에서 생략되고 함축될 수 있는데, symbol이 함수 또한 참조할 수 도 있기 때문입니다.
 
 마지막 예제는, Lisp에 들어온 문자 그대로, 문자들을 보여줍니다. Lisp 문자를 만드는 것은, 단순히 #\ symbol들을 실제 문자 앞에 넣는 것입니다. Lisp는 또한 안보이는 문자들을 위해 정의된 특수 문자들을 지녔습니다. 매일 사용하는 가장 중요한 것들은 #\newline, #\tab, 그리고 #\space입니다.

 동일한 symmetrical 방식에서, read함수의 출력 table은 print에 대한 table만큼 지루하게 보입니다.

NOTE
 위 예제에서 Common Lisp symbol들이 글자 형식으로 blind되었다는 것을 언급하였습니다. 대부분의 문자열에서 이것은 사실이지만, 사실, 세로로 된 pipe |로 symbol을 감싸는 것으로 대소문자를-구분하는 symbol로 만드는 것이 가능합니다. 따라서 symbol |CaseSensitiveSybol|은 대소문자를 유지할 것입니다. 세로로 된 pipe들로 둘러싸인 symbol들은 구두점(punctuation, ;)도 포함할 수 있습니다. 이런 이유로 |심지어 이런것도 적법한 Lisp syimbol 입니다!|


Reading and Printing Stuff the Way Humans Like It
 물론, 이것은 몇몇 흥미있는 속성들을 가졌지만, 저희 초기의 작은 say-hello 함수는 사람들을 맞이하는데 있어 매우 끔짝한일을 합니다. 인간에 더 친화적으로 만들어진 많은 함수들을 가졌다면 더 좋았을 것입니다. 실제로, 우리는 우리가 원하는것을 요약한 (매우 symmetrical) 작은 table을 만들 수 있습니다.
[pic]

 보시다싶이, Lisp는 data조각을, 인간에게 매력적인 방법으로, 출력할 수 있는 명령어를 가졌습니다. princ함수는 어떤 Lisp data조각을 취할 수 있으며, 인간이 선호하는 방식으로 data를 출력하려고 노력합니다. 이것은 여러분이 예상할 수 있는 기본적인 일을 합니다: 문자열에 쌍따옴표를 제외하고, raw form에 있는 문자들을 출력하고, 기타 등등. 여기 몇몇 예제들이 있습니다:
[CODE]

 여기 특별한 의미를 지닌 문자를 princing하는 예제가 있습니다:
[CODE]

 이것의 특성상, princ는 여러분이 원하는 문자의 arbitary output들을 출력하는데 이용할 수 있습니다. 이것은 print와 근본적으로 다릅니다. 우리가 다뤘듯이, print명령어의 멋진 점은 object들을, 그들의 내부 표현을 항상 "읽을수" 있는 방식으로, 출력한다는 것입니다. 그러나, 이것이 의미하는 것은 print는 어떤 arbitrary text 비트를 생성하는데 이용할 수 없다는 것입니다. 반면, princ는 여러분이 원하는 것을 출력하는데 사용할 수 있습니다.

 그럼으로, princ는 인간이 선호하는 방식으로 어떤것을 출력할 수 있을 지라도, 이것은 일방 통행입니다(it’s a one-way street.)  princ로 출력한다면, 인간과 같은 지능만이 의미 있는 적절한 Lisp data구조로 어떻게 바뀌는 지 해독할 수 있습니다. 이러한것을 당장 실행하기에는 컴퓨터가 멍청하기 때문이며, 이것이 의미하는 것은 저희들의 소중한 symmetry이 파괴되었다는 것입니다.

 물론, 저희는 편법을 써 컴퓨터가 인간이 입력한 것들을 해석하는 몇몇 arbitary rules를 만들 수 있을 것입니다. 이것을 행하는 한가지 명백한 방법은 컴퓨터에게 말하는 것입니다 "그들이 ENTER키를 치기 전까지 유저들이 무언가를 입력하도록 하고, 그런 다음 전체를 문자열로 취급하라". Common Lisp에서 이러한 일을 하는 함수를 read-line이라고 부릅니다. 그러나, 이것은 read, print,그리고 princ 함수의 철학을 가지고 있지 않기 때문에, 이것은 문자들과 문자열이상의 것에 대해 알지 못합니다.

 이 새로운 지식으로, 저희는 마침내 여정을 마칠수 있으며, 못생긴 쌍따옴표나 다른 이상한 부분 없이 누군가를 환영하기 위한 적절한 함수를 만들 수 있게 되었습니다:
[CODE]

 이번 say-hellow함수는 처음 것과 유사합니다. 그러나, 컴퓨터가 사용자에게 그들의 이름을 입력할때, 이것은 이제 쌍따옴표로 둘러싸여진 text문자열을 출력하지 않습니다. 환영인사를 출력할 때도 같습니다. 또한, 사용자는 이제 (공백이나 따옴표를 포함한)어떤 이름도 입력할 수 있는데, read-line명령어가 어떠한 불평없이 ENTER 키를 누르기 전까지 입력된 모든 text를 잡고 반환하기 때문입니다.


The Symmetry Between Code and Data in Lisp
 여러분은 Lisp가, 바깥세상으로부터 raw 문자열 data form을 해석하는 것과 이것을 Lisp 문법 표현식으로부터 변환하는, 매우 우아하고 symmetrical 기능을 가진 것을 보았습니다. 그러나 Lisp는 더 깊은 symmetry를 지녔습니다. 이것은 프로그램 code와 data를 교대하며(interchangeably) 다룰 수 있습니다. data와 프로그램 code를 저장하는데 동일한 data구조를 이용하는 프로그래밍 언어를 homoiconic이라 부릅니다.

 여러분은 homoiconicity의 예를, code 방식과 data방식에 대해 다룰때, 3장에서 보았습니다. 그 예제에서, 여러분은 두 방식을 전환하기 위해 따옴표를 사용하였습니다:
[CODE]

 이전 장에서, 저희는 describe-path함수를 정의할때 quasiquote 를 사용하면서, 이 개념에서 하나의 단계 더 나아갔습니다.

 그러나, Lisp에서 quoting과 quasiquoting기능은 그들의 능력에서 안에서 약간 제한적입니다. 여러분이, 어떻게든 처음부터 Lisp code 조각을 생성하고 이것이 code조각이였던 것처럼 실행되길 원한다면 어떻게 될까요? 예를들어, raw data덩어리를 변수 안에 저장해 봅시다:
[CODE]

 어떻게 *foo*변수에 저장된 code를 실행할 수 있을까요? 우리는 이것을 가능하게 해주는 더 강력한 명령어가 필요합니다. 이것은 eval 명령어 입니다:
[CODE]

 eval명령어는 매우 강력하면서 매우 단순하기 때문에, 이것은 Beginning Lispers에게 매우 매력적입니다. 저절로-변화하는 code를 지닌 프로그램을 작성하고 싶다면? eval은 여러분의 가장 친한 친구가 될 것입니다. 사실, 이것이 인공지능(AI)에 광적인 사람들이 예전에 Lisp를 많이 사랑했던 주된 이유입니다. 앞서나가서 eval 명령어를 사용하는 프로그램을 작성해 보십시오. 여러분은 더 많은 재미를 찾게될 것입니다.

 그러나, 숙련된 Lisper는 eval을 드물게 사용합니다. 여러분이 수천줄의 Lisp code를 경험하기까지, 여러분은 실제로 이 매우 강력한 명령어를 사용하기 적절할 때를 알 수 없을것입니다. 종종, beginning Lisper는 Lisp macro를 정의하는것 대신에 eval명령어를 사용할 것입니다. 16장에서 macro를 다룰 것입니다.

 마지막 줄이 Lisp에서의 data와 code symmetric이 Lisp를 homoiconicity의 대명사로 만드는 것입니다. Quoting, quasiquoting, eval 명령어, 그리고 macros는 여러분의 code에 부유함을 가져다 줄 것입니다.

WARNING 
 숙련되지 않은 eval사용은 보안 위험을 유발할 수 있습니다. 101쪽의 “The Dangers of read and eval”를 봅니다.


Adding a Custom Interface to Our Game Engine
 지금까지, 우리는 게임 명령어를 입력받는데 Lisp REPL을 이용하였습니다. 저희 게임의 prototyping으로써 이러한 일을 한건 놀랄만한 일입니다. 그러나 이제 여러분은 기본 Common Lisp 입력과 출력 명령어에 대해 이해를 하였고, 여러분은 게이머와 소통하기에 더 알맞은 custom text game interface를 설치할 수 있습니다.


Setting Up a Custom REPL
 Lisp에서 여러분만의 REPL을 만드는 것은 어처구니없게도 너무 쉽습니다. 여기 저희 게임을 위한, 표준 REPL에서 했던 것과 같이 look명령어를 호출하도록 하는, 간단한 custom REPL이 있습니다: 
[CODE]

 만약 이 game-repl의 설명이 이해가 가지 않는다면 잠깐 멈추기 바랍니다: 처음 이것은 명령어를 읽고, 평가한다음, 마침내 출력합니다. (10장에서 자세히 다룬) 여러분이 전에 보지 못한 명령어 loop는, 여러분이 예상할수 있듯이 단순하게 loop를 영원히 도는것입니다. (CLISP에서 여러분이 무한루프에서 빠져나오려면 CTRL-C를 누르거나 :a를 입력해야만 합니다.) 보시다싶이, 여러분만의 REPL을 read, eval, print와 loop를 단순히 호출하는것으로 쉽게 만들 수 있습니다.
[PIC]

 물론, REPL의 행동을 customize함으로써, 우리는 저희만의 함수를 호출하길 원할 것입니다. 또한, 우리는 더욱 우아한 방법으로 우리의 게임을 종료하길 원합니다. 그러므로, game-repl을 다음과 같이 재정의 합시다:
[CODE]

 이번에는, 우선 게이머가 입력한 명령어를 지역변수 cmd를 이용하여 붙잡아 둡니다. 이러한 방법으로, 우리는 quit를 호출하며 이것을 사용하여 game-repl을 빠저나가는 시도를 막을 수 있습니다. 다시말하자면, 저희는 quit를 입력하기 않으면 우리의 REPL이 계속 동작하기를 원합니다. 그외에는, 저희가 곧 작성할 이러한 함수의 custom version을 이용하여 evals하고 prints합니다. 마지막으로, game-repl함수는 저희가 일직 나가기를 결정하지 않는 한, 자기 자신을 재귀적으로 호출하여 되돕니다.


Writing a Custom read Function
 game-read함수의 목적은, 표준 Lisp가 저희 게임을 진행을 위한 함수를 잘못읽는 두가지 불만들을 바로잡기 위해서 입니다:

z 표준 Lisp read는 괄호로 둘러싸인 명령어를 읽도록 강요합니다. 고전old-school 텍스트 어드벤처 플레이어라면 아시겠지만, 저희는 괄호없이 단지 look이라고 입력으로 할 수 있었습니다. 이것을 완료하면, read-line을 호출하여 괄호를 넣을 수 있을 것입니다.
z read에서는, 어떤 함수 명령어 앞에 따옴표를 붙여야만 합니다. 따옴표를 east앞에 붙이지 않고 walk east를 입력할 수 있어야만 합니다. 이것을 하기 위해, 어떤일이 끝난 다음, 인자 앞에 따옴표를 삽입할 것입니다.
[PIC]

 여기 이러한 것들을 수행하는 game-read 정의가 있습니다:
[CODE]

 read-from-string명령어는 read명령어 처럼 동작하나, 문법 표현식을 (혹은 어떤 다른 기본 Lisp data형식) console로부터 직접적으로 얻어오는 대신 문자열로부터 읽어오도록 합니다.

 저희가 사용하는 문자열은 read-line으로부터 얻어온 tweaked version 입니다. 우리는, 괄호들 뿐만아니라 문자열들을 연결시킬때 사용할 수 있는 concatenate명령어를 사용하여, 쌍따옴표로 둘러싸 이것을 변경합니다. 결과로 cmd변수가 게이머가 요청한 명령어로 설정되고 Lisp 문법 표현식으로 전환됩니다. 예를들어, 만일 게이머가 walk east라고 쳐 넣으면, cmd 변수는 두 symbol을 포함하고 있는 list (walk east)라고 설정됩니다.

 다음으로, 우리는, 명령어에서 게이머가 가진 어떤 인자들을 인용하는데 사용할 수 있는, quote-it이라 불리는 지역변수를 정의합니다. 어떻게 인자를 인용하는 것을 정확하게 처리 할 수 있을까요? 따옴표는 quote라 불리는 Lisp명령어의 약칭(shorthand)입니다. 이것은 'foo와 (quote foo)가 서로 같다는 것을 의미합니다. raw 인자들을, 단순히 인자에 quote명령어를 앞에 붙여 list에 넣음으로써, 인용할 수 있습니다.

 지역 함수를 labels나 flet으로 정의할 수 있다는 것을 기억하시길 바랍니다. quote-in함수 안에서 재귀를 사용하지 않기에, 더 단순한 flet명령어를 사용할 수 있습니다. game-read함수의 마지막 줄은 quote-it을 게이머의 명령어에 있는 모든 인자에 적용하는 것입니다. cmd변수의 cdr를 quote-it에 mapping 시킵니다. (그 다음 cdr로 명령어에 있던 첫번째 단어를 다시 앞으로 추가 시킵니다)

 새로운 함수를 돌려봅시다:
[CODE]

 보시다싶이, game-read함수는 (게임세상에 필요한)괄호와 따옴표를 붙일 수 있습니다!

NOTE
 custom read는, 잠재적으로 멍청한 게이머를 표면위로 떠오르게 할 수 있는, 몇몇 제한된 점을 지니고 있습니다. 게이머가 괄호과 일치하지 않은 "(look"과 같이 이상한 문자열을 입력할 수 있고, 이것은 game-read명령어에서 Lisp 예외를 유발시킵니다. 잘못된 입력에 표준 read명령어가 이상하게도 행동하는, 그 자체로는, 별로 이상할 것이 없습니다. (이번 경우에선, 빠진 괄호를 결국 보충해 줄거라는 희망속에 다른 줄의 입력을 받을 것입니다) 그러나, 저희 game-repl은 이러한 상황을 충분히 다룰 수 없으므로, game-repl의 다운을 유발시킵니다.이것은 만일 여러분이 Zork를 플레이하다가 명령어를 쳤을때 매우 불쾌하게 Zork게임 자체가 다운되는 것과 같습니다. 이런 드문 상황은 13장에서 다루게 될 추가적인 예외 처리로 처리할 수 있습니다.


Writing a game-eval Function
 저희는 거의-완벽한 Lisp reader를 만들었으며, 이제 어떻게 eval 명령어를 향상 시킬지 생각해봅니다. 게임에서 eval을 사용함에 있어 문제점은, 게임에 관계없는 다른 Lisp명령어를 호출하는 것을 허락한다는 것입니다. hacker로부터 우리 프로그램을 보호하기 위해, 우리는 다음과 같은 호출 할 수 있는 특정 명령어만 허용하도록 game-eval함수를 만들 것입니다.
[CODE]

 game-eval함수는 member 함수를 사용하여 전체 명령어에 있는 첫번째 단어가 허용된 명령어 list에 있는지 확인합니다. 만약 있다면, 표준 eval을 사용하여 게이머의 명령어를 실행합니다. 게이머에 의해 호출된 명령어가 공식 목록에 있는 것을 확인함으로써, 우리는 유해한 명령어를 호출하는 것을 방지 할 수 있습니다.
[PIC]

WARNING
 저희 game-eval함수는 해킹을 100 퍼센트 막지는 못합니다. 자세한 사항은 101쪽의 "The Dangers of read and eval"를 참조하시기 바랍니다.


Writing a game-print Function
 game-repl system의 빠진 마지막 조각은 game-print함수 입니다. 저희 게임의 Lisp REPL 버전에 있는 제한된 것 중에 한가지 명백한건: 게임에서 모든 text description들이 대문자로 출력된다는 것입니다.

 millennium을 거처오면서, 제가 보아온 바로는, 컴퓨터는 대문자와 소문자를 출력 할 수 있습니다. game-print함수를 작성함으로써, 이러한 문제를 해결할 수 있습니다. game-print 함수의 코드를 통해 나아가기 전에, 이것의 출력 예제를 살펴 봅시다:
[CODE]

 보시다싶이, game-print 함수는 저희 symbol-기반으로 작성된 것을 적절하게 대소문자로된 text로 변환시켜 줍니다. 이 함수를 가짐으로써, 저희는 게임 엔진에 있는 가능한 가장 알맞은 형식으로, text를 저장할 수 있습니다: symbol들의 list들로. 이 형식은 text 조작을 쉽게 만듭니다. 그리고, presentation의 관점으로, 우리는 presentation 세부항목 symbol list들을 꾸밀 수 있습니다.

 물론 이번 예제에서, 이렇게 꾸미는것은 매우 간단합니다. 우리가 해야 할 일은 조건을 조정하는 것입니다. 그러나 여러분은 이미 data model에 존재하는 세부항목을 분리하는것에 대한 몇몇 작은 이점을 볼 수 있었습니다. 예를 들어, 저희가 describe-path함수가  "Left of here lies a door."와 같은 문장을 작성하도록 바꾼다고 가정해봅시다. 어떠한 추가 수정이 필요하지 않습니다; 프로그램은 문장의 시작부에 있는 Left를 대문자로 한다는 것을 자동으로 알 것입니다

 그러나 진가는, HTML code를 생성하는 것과 같은, 더욱 정교한 표현방법을 원할때 나타날 것입니다. 여러분은, 여러분의 게임에서 색상이나, 폰트, 기타등등 을 바꾸는 것과 같이 화려한 text를 보여주기 위해, 사용자 문법을 포함하기 원합니다. 예를 들어, 다음과 같이 괄호를 포함하는 게임 설명문을 허용할 수 있습니다. "당신은 (red 사악한 악마)에 의해 공격받고 있습니다."그런 다음 여러분은, 빨간 색으로 둘러싸여진 text를 쓰기 위해, game-print 함수에서 red 키워드를 잡을 수 있습니다. 17장에서 이것으로 간단하게 HTML 표현시스템을 만들 것입니다.
[PIC]

 이제 저희는 game-print함수의 code를 볼 준비가 됬습니다:
[CODE]

 game-print함수와 이의 helper 함수는 이제까지 보아왔던 다른 함수보다 좀 더 복잡합니다. game-print에서 실행되는 code의 첫번째로 중요한 부분은, (고치기 원하는 형태를 포함하는)symbol list를 Lisp의 많은 print 변종중 하나인 prin1-to-string를 통해 문자열로 변환 시키는 곳입니다. to-string 의미는, 이 함수는 화면으로 결과를 보내지 않고, 이것을 문자열로 반환하겠다는 것입니다. 1이 의미하는 것은 한줄로 붙인다는 것입니다. 표준 print 명령어는 개행 문자를 포함하고 뒤에 공백이 붙습니다. prin1과 prin1-to-string 변종은 이러한 추가 문자들을 더하지 않습니다.

 다음으로, game-print는 coerce함수로 문자열을 문자들의 list로 변환시킵니다. 문자열을 list로 coercing함으로써, 우리는 list-processing 문제에 관한 함수의 큰 골치거리(goal)를 줄일 수 있습니다. 이는 곧장 Lisp comfort zone으로 갈 것입니다.
 이번경우에, 저희는 text를 저희가 고치고 싶은 데로 꾸민 문자들의 list를 만들 것입니다.
 
 이제 저희는 list-eater 함수인 tweak-text로 data를 보낼 수 있습니다. game-print함수의 code에서 사용되는 일부 인자들이 명료성을 위해 그들 소유의 라인에 출력되어 집니다. 여러분은, 식별자를 살펴 봄으로써 인자들(arguments)들이 의미하는 것이 어떤 명령어인지, 쉽게 알 수 있습니다. 예를들어, t와 nil인자는 tweak-text에 속해 있습니다.

 tweak-text함수는 list에 있는 각 문자들을 살펴보고 필요하다면 수정합니다. 이 함수의 처음 부분에서,tweaking할 문장 앞부분에서 item을 뜯어냄으로써 얻은, 지역변수 item과 rest 두개를 정의합니다. 그런 다음, tweak-text함수는 서로 다른 조건에 대해 list의 상단에 있는 문자를 확인하기 위해 cond를 사용합니다.

 이것이 확인하는 첫번째 조건은 어떤 문자가 공백 문자인가 입니다. 만약 그렇다면, 공백을 바꾸지 않고 놔두고 list에 있는 다음 문자를 처리합니다. 만일 문자가 마침표, 물음표, 느낌표라면, 나머지 문자열이, 다음 symbol이 문장의 처음이고 대문자로 나타낼 필요가 있다는 것을 나타내기 위해, cap을 on시킬 것입니다.

 우리는 또한 쌍따옴표(quotation mark)가 어디에 있는지 확인할 것입니다. 드물게, 이러한 일을 하는 이유는, symbol list는 영어 text로 encoding하기에 적합하지 않기 때문입니다. 예로 쉼표(쉼표는 표준 Common Lisp symbol로 허용되지 않습니다.)를 가지고 있거나 표준이 아닌 대소문자로 나타내는 제품이름이 있습니다. 이번 경우에, 저희는 text 문자열의 사용에 기댈 수 있습니다. 여기 예제가 있습니다:
[CODE]

 우리의 간단한 게임에서는 되돌리는 기능이 실제로 필요하진 않습니다. 그래도, 이 기능은 game-print함수를, 게임을 확장시키면서 마주치게될, 많은 기본적인 예외 text 상황들을 처리하도록 해줍니다. 재귀 호출에서 lit 변수를 on으로 전환함으로써, 대문자를 문자그대로 보여지도록 다루도록 할 수 있습니다. 이 변수가 설정되면, tweak-text함수는 capitalization 규칙을 방지합니다

 다음으로 tweak-text함수는 다음 문자가 대문자를 지원하는지 여부를 검사합니다. 만약 그렇다면, char-upcase함수를 이용하여 list에서 다음 항목을 처리하기 전에 현재 문자를 (이미 대문자가 아닌 경우) 대문자로 바꿉니다.

 다른 조건들을 만족하지 못하면, 현재 문자가 소문자라는 것을 알게되고, char-downcase함수를 사용하여 이것을 변환시킬 수 있습니다.

 다음으로 tweak-text가 끝난 후에 문자 list에 있는 text를 모아, game-print함수는 이것을 적절한 문자열로 coerces하고 princs 합니다. game-print마지막에 있는 fresh-line 함수는 화면에 보여지는 다음 항목이 새로운 라인에서에서 시작되도록 만듭니다.

 이제 저희는 adventure 게임 엔진에 필요함에 있어 적합한 꾸밈을 이용하여, 원본 symbol들의 list를 화면에 출력하는 작업을 마쳤습니다.


Trying Out Our Fancy New Game Interface
 이제 저희 게임에서 사용자 REPL에 필요한 부분들을 모두 완료하였습니다. 단순히 game-repl함수를 호출하여 새로운 게임 세계를 탐험해 보시기 바랍니다. 17장에서, 이 게임 엔진을 추가 명령어를 갖는 완전한 게임으로 확장한다는 것을 기억하시기 바랍니다.
[REPL]

 훌륭합니다! 우리는 이제 매우 유연한 text 게임 엔진을 갖게 되었습니다. 이것은 확장할 수 있고 Lisp REPL로 디버그 할 수 있습니다. 또한 자연스러운 text adventure 경험을 사용자에게 제공해주는 완벽하게 customizable interface를 가졌습니다. 진행을 같이 하면서, 저희는, 땜빵filler 코드나 다른 오버헤드를 최소화하여 엔진을 제작하는, 꿈같은(mind-bending) Lisp 기법들을 보았습니다.
[PIC]


The Dangers of read and eval
 저희는 eval과 read명령어를 사용자 Lisp REPL을 만들면서 사용하였습니다. 이러한 명령어들은 매우 강력하면서도, 매우 위험합니다. 충분한 주의를 기울이지 않고 저것을 사용할 때는, 해커에게 여러분의 소프트웨어에 대해 악성 명령어를 실행시키는 공격을 허용하게 됩니다.

 예를 들어, 우리 프로그램이 format-harddrive라 불리는 함수가 필요하다고 가정해 봅니다.  아무 사용자가 접근하기 원하는 함수가 아니며, 만일 해커가 우리 게임 REPL속에 이것을 호출하도록 속인다면 매우 위험해 질 수 있습니다

 이번 장에서 저희가 쉽게 만든 game-eval함수는, 게이머가 게임 명령어로 format-harddrive를 입력하는 것을 방지하는, 단순한(crude) 보호장치를 지니고 있습니다. 여기 새로운 게임 REPL에 이 명령어를 치면 어떤 일이 일어나는지 나와있습니다:
[CODE]

 저희 game-eval함수는 오직 승인된 list에 있는 명령어만 실행할 것입니다. 이것은 우리 게임에, 여전히 게임을 해킹으로부터 사용자를 보호하는 동안 명령어를 평가하여 Lisp의 힘에 접근하도록 허용하는, 방화벽의 한 종류를 줍니다.

 그러나, 더욱 치밀한 exploits 플레이어는 가능합니다. 예를들어, walk (format-harddrive)라고 입력 하였습니다. 우연히도, 저희 game-read함수는 모든 함수 인자들을 quote-it을 이용하여 데이터 모드로 바꿉니다 game-read에서 quote-it를 사용하면, 실행된 실제 코드는 (walk '(format-harddrive))입니다. (format-harddrive)앞에 있는것을 참조하여 악성 명령어를 데이터 모드로 변환시켜, 않좋은 일이 일어날 수 있습니다.

 프로그램을 다운시키는 공격 방법중 하나는 reader macro를 사용하는 것입니다. 이것은, 악성 컴퓨터 code로 가는 다른 길을을 여는, Common Lisp read 명령어에 내장된, 진보된 기능 집합입니다. (게임 명령어로 eval을 사용하기 전에, read를 먼저 거친다는 것을 기억하시기 바랍니다) 악의적인 code를 성공적으로 실행하는 게임 명령어의 예는 walk #.{format-harddrive} 입니다.

 마지막 줄은, eval이나 read를 사용하는 Lisp 프로그램이 해커로부터 완벽히 안전하다고 확신 할 수 없습니다. Lisp 코드를 작성할때, 여러분은 가능한 이 두 명령어를 사용하는 것을 피해야 합니다.


What You’ve Learned
 이번장에서, text adventure 게임이 박력있게하기 위해(to supercharge) 우리는 사용자 REPL을 만들었습니다. 이러한 과정을 통해, 다음과 같은 것을 배웠습니다:

z print와 read함수는 console을 통해 사용자와 직접적으로 대화를 한다. 이 두 함수는 컴퓨터-친화적으로 일합니다.
z 다른 입력/출력 함수들은 read와 print만큼 우아하진 않지만, 인간과 상호작용할때 더욱 친근하다. 예로 princ와 read-line이 있습니다.
z homoiconic 프로그래밍 언어는 프로그램 code와 data를 동일한 형태로 저장한다. Lisp의 quoting, quasiquoting, eval과 macro기능은 이것을 강력한(extremely) homoiconic을 만듭니다.
z 사용자 REPL을 작성하는 것은 쉽다.
z 내부 Lisp 데이터를 프로그램의 인터페이스에 맞도록 변환하는 것은 간단하다. 이것은 프로그램의 내부 데이터구조로부터 표현세부사항을 분리하는 것을 쉽게 만들어 줍니다.