9장.진보된 자료구조과 제네릭 프로그래밍


 봐왔던 것과 같이, Lisp에서 cons cells, 심볼, 문자열, 수치 자료구조로 수행할 수 있는 많은 일들이 있습니다. 매우 성숙한 언어답게, Common Lisp는 이러한 기본적인 것을 뛰어넘을 데이터 형식을 더 많이 포함하고 있습니다. 이번장에서는, 이러한 배열, 해쉬테이블, 그리고 구조체포함해서 진보된 자료구조의 유용함을 다룰 것입니다.


배열(Arrays)
 Common Lisp의 배열은 리스트와 매우 유사합니다. 배열을 사용함으로 얻는 주요한 이점으로는 어떤 특정 지점에 있는 값에 접근하기 위해 상수 시간을 요한다는 것입니다. 이것이 의미하는 것이 무엇인지는 후에 짧게 다루도록 하겠습니다.


배열로 작업하기
 새로운 배열을 만들기 위해선 배열의 크기를 지정하여 make-array 명령어를 사용합니다:
[REPL]

 이는 길이가 3인 배열을 만듭니다. 만들어진 값이 리스트가 아니라는 것을 나타내기 위해, Common Lisp는 배열 앞에 해쉬 표시(#)를 답니다.
 배열에 있는 항목을 얻거나 설정하기 위해선 aref함수를 사용합니다. 예를 들어, 여기 인덱스 1에 있는 항목을 어떻게 얻는지 나와 있습니다:
[REPL]

 물론 지금 당장 배열은 nil로 체워져 있어서, 얻어낼 가치가 없습니다. 배열에 있는 항목을 보다 흥미로운 값으로 설정하기 위해, setf 명령어와 함께 aref를 사용하겠습니다:
[REPL]

 aref는 보통 배열에서 값을 얻는데 사용되지만, 이 예제에서 나타난 특별한 방법으로 사용될 때에는 배열의 값을 설정합니다. setf와 aref 명령어를 같이 사용하는 능력은 Common Lisp의 능력을 보여줍니다: 제네릭(generic) 프로그래밍을 지원합니다. 어떻게 이 기능이 동작하는지를 좀 더 알아내기위해 setf명령어를 자세히 살펴봅시다.


제네릭 Setter의 사용
 Common Lisp 언어는 제네릭 setter를 지원한다고 말합니다. 대부분 이것이 의미하는 것은 데이터 구조(배열, 리스트, 문자열, 혹은 다른 것)에서 값을 빼내오는 코드가 동일한 데이터 구조에 데이터를 집어 넣는 코드와 동일하다는 것입니다. setf명령어는 얻어오는(getting) 연산을 하는 함수와 결합하여 사용할 수도 있고, 설정하는(setting) 연산을 하는 함수와도 사용할 수도 있습니다.
 이미 저희는 aref를 배열에서 값을 얻을 때 사용할 수 있다는 것을 보았고, setf와 사용하여 배열의 값을 설정할때 사용할 수 있다는 것을 보았습니다. 자료구조에서 항목을 얻는 대다수의 Common Lisp의 명령어에서, setf명령어는 제레닉한 방식으로 이러한 묘기를 수행할 수 있습니다. 예를 들어, 리스트에 관한 다음 예제를 살펴봅시다:
[REPL]

 예상했던것 처럼 표현식 (second foo)는 B를 반환합니다. 그러나 setf명령어에 (second foo)를 통과시켰을 때, 이것은 B가 어디서 왔는지 알고 표현식 (second foo)를 평범한 변수인 것처럼 다룰 수 있습니다. 기본적으로, setf명령어는 자기 자신에게 질문합니다 "첫 번째 인자로 들어온 항목이 본디 어디서 왔을까?" 이번 경우에, 값은 foo라는 이름의 리스트의 두 번째 항목에서 왔습니다. 그러므로, 이 지점에서 setf를 시도한다면 원본 변수 foo는 반응하며 수정됩니다.
 사실 setf의 첫번째 인자는 generalized reference라고 불리는 Common Lisp의 특별한 하부언어(sublanguage)입니다. 모든 Lisp 명령어가 generalized reference를 허용하는 것은 아니지만, 여전히 저희는 어떠한 것을 매우 복잡한 무언가에 넣을 수 있습니다.
[REPL]

 이번 예제는 Common Lisp에서 setf의 진정한 힘을 보여줍니다. 첫번째 사용한 것에서, 리스트 (x y z) 를 배열의 세번째 항목으로 넣었습니다. 만일 지금 foo를 출력한다면, 이것이 동작한 것을 볼 수 있습니다. 두번째로 사용한 것에서, foo 배열에 있는 이 리스트의 첫번째 항목을 해쉬 테이블로 바꾸었습니다. 해쉬 테이블 은 157쪽에서 짧게 배울 또 다른 진보된 자료구조입니다. setf로 이 일을 하는 것은 놀랄 만큼 쉬운데, setf의 첫번째 인자에 있는 generalized reference는 임의로 복잡해질 수 있기 때문입니다.
 마지막으로, 해쉬 테이블 내부 키는 zoink로 하여 값 5를 삽입하였습니다. gethash함수는 해쉬 테이블 밖으로 값을 얻어오도록 합니다. 대신 여기서는 setf의 도움으로 해시 테이블에 숫자 5를 넣었습니다.
 이번 예제로부터 프로그램에서 복잡한 자료구조를 수정할때 setf가 유용할 수 있다는 것을 명심하길 바랍니다.
 setf의 또 다른 멋진 기능은 값에 접근하는 새로운 방식을 지원하도록 generalized reference 문법을 확장 시킬 수 있다는 것입니다. setf는 중첩된 수준이나 쓰여진 자료구조에 구애받지 않고 값을 수정하는 진정한 제네릭한 방식입니다.


배열 대 리스트
 이제 저희는 Lisp에서 배열이 행동하는 기본 예제를 살펴보았습니다. 그러나 배열의 이점을 완전히 이해하기 위해선, 리스트와 비교해볼 필요가 있습니다.
 리스트로 할 수 있는 대부분의 것들은 배열로도 할 수 있습니다. 그러나, 일반적으로 배열은 특정 원소에 접근할시 리스트보다 빨라서 성능면에서는 다릅니다.
 예를들어 배열을 다루는 함수 aref는, 배열을 이용하지 않고 평범한 리스트의 특정 지점에 있는 항목에 접근하는 nth라 불리는 리스트를 다루는 함수와 매우 유사흡니다. 여기 리스트에 nth를 사용하는 예제가 있습니다:
[REPL]

 그러나, 매우 작은 리스트에만 nth 함수를 사용하는게 이치에 맞습니다. 예를들어, 리스트 X가 수천개의 항목을 가졌고 (nth 1000 x)명령어를 실행하면 실로 느릴것인데, Lisp 리스트는 cons cells의 사슬로 만들어졌기 때문입니다. Lisp에서 리스트에 있는 수천개의 항목을 찾을 수 있는 유일한 방법으로는 999개를 먼저 휘졋고 다니는 것입니다.
 대조적으로, 큰 배열에서 (aref x 1000)명령어를 수행하는것은 이전 999항목을 거쳐 세는것 없이 천번째 항목을 직접 접근합니다. 이것이 의미하는 것은 큰 배열에서의 aref는 큰 리스트에서의 nth명령어보다 더욱 빠르게 수행될 것이라는 것입니다. 10억개의 항목을 가진 배열이 있을지라도, 마지막 항목을 검색하는 것은 여전히 매우 빠를것입니다. 실제 제한하는 요소는 오직 여러분의 시스템 뿐입니다: 여러분의 컴퓨터의 RAM용량과 이를 이용하는 Lisp 환경의 저장 방식.
[PIC]

 배열은 값에 빠르게 접근할 수 있을 뿐만아니라, 평범한 리스트로 같은 작업을 하는 것보다 빠르게 특정 장소에 있는 값을 바꿀 수 있습니다.
 큰 자료구조에서 특정 값을 설정하거나 얻는 것은 매우 중요하므로, 배열을 여러분의 코드에서 가능한 최적의 성능을 얻도록 여러분을 도와줄 수 있는 도구라고 명심하시기 바랍니다.


해쉬 테이블(Hash Tables)
 배열이 리스트과 비슷하듯이, 임의의 요소에 빠르게 접근한다는 점을 제외한다면 해쉬 테이블은 alist와 비슷합니다.
 사실, 해쉬 테이블은 때때로 마법처럼 보여질 정도로 매우 효율적입니다. 은하수를 여행하는 히치하이커를 위한 안내서의 Babel fish을 떠올려봅시다 - 실제로는 존재하지 않지만 매우 놀랄만한게 유용한 것. 이것이 대다수의 모든 현대 언어들이 이제 해쉬 테이블을 제공하는지에 대한 이유입니다.
[PIC]


해쉬 테이블로 작업하기
 make-hash-table명령어로 새로운 해쉬 태이블을 만듭니다:
[REPL]

 alist처럼, 해쉬 테이블은 색인 키와 값을 이용하여 항목을 저장합니다. 항목의 키와 gethash 함수를 이용하여 해쉬 테이블로부터 하나의 항목을 얻을 수 있습니다:
[REPL]

 아직까진 해쉬 테이블은 비어있습니다. 이것이 의미하는 것은 해쉬 테이블에서 어떤 키를 살펴볼때, 이번 예제에서 'yup의 대답으로 NIL을 받는다는 것입니다. 실제로, 저희는 두개의 NIL을 받았습니다 - gethash 명령어는 Common Lisp에서 여러개의 값을 반환합니다(다음 단락에서 다룰것입니다). 반환된 첫번째 값은 해쉬 테이블에 저장된 실제 값이며, 두번째는 테이블에서 키를 찾았는지를 나타냅니다(이번 경우에는 없습니다).
 배열로 했을때처럼, 데이터로 테이블을 체우기 위해, setf명령어와 데이터 요소를 참조하는데 사용하는 명령어를 조합할 수 있습니다 - 이번 경우에는 gethash:
[source]

 이번 예제에서, yup을 색인 키로써 해쉬 테이블에 값 25를 저장했습니다. 그 다음, 테이블에서 yup을 살펴보면, 25라는 답을 얻게 됩니다. 또한 t라는 두번째 값을얻는데 이것이 의미하는 것은 "예, 저는 테이블에서 키를 찾았습니다" 입니다.
 alist를 다루었을때, 커피주문담을 자료구조를 만들었던것이 기억나십니까? 여기 동일한 데이터가 있으며, 이번에는 해쉬 테이블을 사용하여 저장됩니다:
[REPL]

 이제 누군가의 음료 주문을 확인하는게 간단해졌습니다:
[REPL]


다수의 값을 반환하기
 Common Lisp는 결과로 하나의 값보다 더 많이 반환하는 것을 허용합니다. 저희가 봐왔던것 처럼 gethash함수를 포함하여 Common Lisp의 몇몇 core 함수는 이러한 일을 합니다. 또 다른 일반적으로 사용되는 함수는 수를 반올림하는 round 함수입니다:
[REPL]

 이 함수를 호출하면 수를 알맞게 2로 반올림하면서, 반올림 연산의 나머지인 두번째 값도 생성합니다. 이 함수 호출에서 두 값이 반환됩니다.
 또한 여러분의 코드에서 values함수를 이용해서 다수의 값들을 생성할 수 있습니다. 예를들어, 여기서 여러분은 3과 7를 반환하는 foo라는 함수를 작성할 수 있습니다:
[REPL]

 round 함수와 마찬가지로 이 값들은 모두 REPL에서 출력됩니다. 그러나, Lisp는 첫번째 값을 더욱 중요하게 여기며, 후속 계산동안 항상 기본으로 사용될 것입니다. 예를들어, foo함수를 호출한 뒤 이와 같이 추가 작업을 수행할 수 있습니다:
[REPL]

 이번 경우에, 추가 연산은 foo가 반환한 두번째 값을 무시합니다.
 그러나, 때때로 추가적인 반환 값을 사용해야 할 필요가 있습니다. multiple-value-bind명령어를 사용하여 이러한 일을 할 수 있습니다:
[REPL]

 이번 예제에서, a와 b 변수를 foo에 의해 반환된 값 (3과 7)로 묶었습니다. multiple-value-bind와 함께 함수를 호출하여, 다른 경우에는 무시되어지는 함수로부터 반환된 추가 값들을 사용하도록 합니다.
 여러분은 multiple-value기능을 사용하는 대신에 함수로부터 리스트를 반환 할 수 있는지 궁금해할 지도 모릅니다. 답은 "할 수 있다" 입니다. 그러나 mutiple-value기능을 사용하면 더욱 최적화되고 깔끔한 코드를 이끌어내는 것이 가능합니다.
 이 책에서는, 다중 값의 사용이 많지는 않을 것입니다. 사실, Arc나 Clojure와 같은 최근 Lisp방언들은 다중 값을 전혀 지원하지 않습니다. 대신에, 하나의 값보다 많이 반환될 필요가 있을 경우에 리스트를 반환합니다.


해쉬 테이블 성능
 배열처럼, 해쉬 테이블이 얼마나 많은 항목들을 갖고 있던지 간에 해쉬 테이블 안에 있는 값의 접근과 수정은 상수 시간을 요구합니다. 예를 들어, 해쉬 테이블이 10개의 항목을 가지고 있다고 가정해 봅시다. 키를 사용하여 테이블에서 값을 접근하고 이것을 찾아내는데 걸린 시간은 평균 0.001초가 걸립니다. 이제 해쉬 테이블이 1,000,000 항목을 가졌다고 가정해봅시다. (해쉬 테이블이 그렇게 설계되었기 때문에) 값을 받는데 여전히 0.001초가 걸릴 것이라고 예상할 수 있습니다. 다시말하자면, 테이블이 얼마나 크든지간에, 0.001초라는 상수 시간에 항목에 접근 할 수 있습니다.
 어떻게 엄청난 이 일이 가능한지 생각해 보십시요! 해쉬 테이블이 1,000,000개의 항목을 포함할지라도, gethash함수는 키를 취하여 상수 시간안에 여러분이 원하는 항목을 찾을수 있는 곳을 정확히 결정할 수 있습니다!
 어마어마한 양의 데이터를 뒤로하는 웹 기반 프로그램 시대에서, 많은 양의 값들을 저장하고 빠르게 반환하는 해쉬 테이블의 능력은 필수입니다. 키/값을 쌍으로 저장하는 효율성은 대다수의 온라인 저장 시스템에서 필수입니다. 구글의 BigTable이나 아마존의 S3와 같은 막대한 양의 온라인 데이터를 저장하는 최신 도구라도, 해쉬 테이블과 유사하게 만들어 키를 사용함으로써 값을 재빨리 받아오도록 만들어졌습니다.
 그러나, 해쉬 테이블이 항상 최고의 성능을 제공한다고 단언할 수는 없습니다. 여기에 왜 그런지에 대해 나와 있습니다:


가상 메모리 패이징(virtual memory paging)과 캐시 미스(cache misses):
 배열과 마찬가지로, 큰 해쉬 테이블은 여러분의 운영체제로 하여금 하드 드라이브의 가상 메모리 패이징을 유발시킵니다. 따라서 성능이 줄어들게 됩니다. 유사하게, CPU 캐시 미스의 수도 증가 할 수 있습니다.

해쉬 충돌:
 내부적으로 해쉬 테이블은 키를 숫자로 변환시키는 hash함수라 불리는 특별한 함수를 사용합니다. 이와 같은 해쉬 함수는 해쉬 충돌을 유발시킵니다. 본질적으로 해쉬 충돌은 우연히 두 키가 hash함수에 의해 같은 수로 변환될때 일어납니다. 이 경우에 미세한 성능 감소가 있을지라도 해쉬 테이블은 여전히 정확하게 행동합니다. 드믄 경우에, 특정 키가 충돌 횟수를 증가시키도록 hash 함수에 영향을 미칠 수 있어 어플리케이션의 검색 능력을 지연시켜 성능은 더욱 더 감소하게 됩니다.

작은 테이블의 비효율성:
 매우 작은 테이블에서 해쉬 테이블이 요구하는 생성과 찾는 시간은 alist와 같은 간단한 구조보다 비효율적입니다. 해쉬 테이블의 성능 이점은 데이터의 양이 큰 경우에만 두드려집니다.

변하는 연산 속도:
 만약 여러분이 Common Lisp에서 작은 해쉬 테이블을 만들고 값으로 체워넣다보면 새로운 값을 추가하는 것이 때때로 비정상적으로 느리다는 것을 발견할 것입니다. make-hash-table함수가 작은 해쉬 테이블을 만드는 비용을 최소화하도록 설계되었기 때문입니다. 그러나 테이블을 크게 만드는 값을 추가하기 시작한다면 Lisp는 더 많은 메모리를 할당하기위해 여분의 시간을 요구하며, 테이블은 더 많은 항목을 담을 수 있게 됩니다. 이러한 추가 할당은 테이블이 자라면서 종종 느린 삽입을 야기시킵니다.

해쉬 테이블이 항상 최선의 해결책이 아닌 마지막 이유:
 cons cells로부터 세워진 전통적인 Lisp 구조만큼 Lispy하지 않습니다. 이것이 의미하는 것은 Lisp REPL에서 자연스럽게 출력되거나 읽을 수 없기 때문에 디버그하기에 cons cells보다 어렵다는 것입니다. 그러므로, 바람직한 경험법칙으로는 배열과 해쉬 테이블을 새로운 code조각으로써 염두에 두고 멀어지는 것입니다. 그리고 만약 성능이 이슈로 떠올랐을때, 성능 문제의 해결을 위해 배열과 해쉬 테이블의 이점을 취하도록, 여러분의 코드의 임계 구역을 신중하게 수정해야 합니다.


해쉬 테이블을 이용한 빨라진 Grand Theft Wumpus
 해쉬 테이블이 여러분의 코드를 위해 무엇을 할 수 있는지 연습 문제를 살펴봅시다. 게임 Grand Theft Wumpus에서 눈에띄는 비효율적인게 있었는데, 이제 그것을 해쉬 테이블로써 바로잡을 수 있습니다.
 Grand Theft Wumpus에서 도시 그래프를 표현하기 위해 노드와 간선 리스트를 사용한 이전 장을 회상해봅시다. 주어진 노드로 찾는 것 대신에, 리스트를 통해 선형적으로 찾아야 합니다. Congestion City는 많은 교차로를 가지고 있지 않기 때문에, Grand Theft Wumpus에서 큰 작업을 요구하지 않습니다. 그러나 도시가 1000개의 노드와 1000개의 간선를 가진다면 어떨까요? get-commected 함수의 시간을 재보고 어느 정도의 수치를 얻는지 봅시다:
[REPL]

 time명령어는 코드덩어리에 관한 모든 종류의 유용한 시간 정보를 출력하는 Lisp의 유틸리티이며, dotimes함수는 코드를 100번 수행하게 하여, 100개의 도시를 건설하게 합니다. 이 명령을 사용해서 제 컴퓨터에서 코드를 돌렸을때 1분 정도 걸렸습니다. CPU가 1분간 처리할 수 있는 엄청난 수의 명령이 주어졌고, 이것은 명백하게 끔찍한 성능을 나타냅니다.
 이 문제를 해결하기 위해, 간선 리스트를 해쉬 테이블로 변경하고, 따라서 get-conncted함수는 상수 시간에 연결을 찾을 수 있을 것입니다. 또한 방문했던 리스트를 방문했던 테이블로 교체할 것이며, 따라서 함수는 빠르게 어떤 노드가 이미 방문했는지를 답할 수 있을 것입니다.
 여기 이것을 수행하는 해쉬화된 버전으로 구성된 코드가 있습니다:
[SOURCE]

 우선, 간선 리스트를 해쉬 테이블로 변환시키는 hash-edges함수가 필요합니다. 함수의 시작 부분에서, tab이라는 새로운 해쉬 태이블을 만들었습니다. 그 다음, mapc로 테이블을 순회합니다. 부수효과(side effect)에 대해 주의하거나 결과로 최종 리스트를 생성하는 것에 신경쓰지 않는 곳에 사용한다는 점을 제외하고, mapc는 mapcar와 같다는 것을 기억하시기 바랍니다.
 모든 노드들에 대해 저희는 이것과 연결된 노드들의 리스트를 포함할 테이블을 원합니다. 그러므로, 리스트를 순회하면서 시작 노드에 대한 이웃 리스트에 새로운 이웃을 push 합니다. 일반적인 Lisp 변수값처럼 해쉬 테이블 값에 push명령어를 사용할 수 있습니다. 다시 말해, 166쪽 "제레닉한 방식으로 데이터 다루기" 에서 다룰, Common Lisp에서 만들어진 제네널(general) 변수 시스템을 사용합니다.
 테이블에 노드 값이 없는 경우를 처리할 필요가 없어 혼란스러울지도 모릅니다. 어떻게 값이 존재하지 않는데 테이블에 무언가를 push할 수 있을까요? 테이블에서 키를 찾을 수 없을 시 gethash함수는 NIL을 반환하기에, 이 코드는 단순히 새로운 이웃를 비어있는 리스트에 push하고, 이전에 값을 찾을 수 없었던 테이블에 새로운 기록을 집어넣습니다. 이리하여, push명령어는 노드가 새 것이거나 이전 것이든 상관치않고 마법과도 같이 "정확한 일"을 수행합니다.
 마지막으로, 테이블이 차있으면 결과로 반환합니다. 이것은 원래 간선 리스트와 같은 데이터를 포함하고 있습니다. 다른점은 Congestion City안의 어떤 노드의 이웃들을 광속으로 찾을 수 있습니다.
[source]

 이제 저희는 Congestion City에서 시작 노드에 연결된 모든 노드들을 되돌려 받는 get-connected-hash를 작성할 준비가 되었습니다. 이것은 get-connected와 행하는 것은 동일하지만, 해쉬 테이블을 통해 최적화 되었습니다.
 이 함수가 하는 첫번째 일은 방문했던 노드들의 해쉬 테이블을 만드는 것입니다. 그 다음 출발 노드로부터 시작해서 Congestion City의 노드들을 이동합니다. 새로운 노드를 방문할 때마다, 이전에 방문했었는지 스스로 물어봅니다. 이제 저희는 방문했던 테이블에 있는 현재 노드를 살펴봄으로써 이 질문에 매우 효율적으로 대답할 수 있습니다. 만일 아니라면, 이 노드를 방문했다고 표시할 필요가 있고 mapc로 이것의 모든 이웃들을 확인해야합니다 - 간선 테이블을 확인. 마지막으로, 시작 노드와 연결된 모든 노드들을 담고있을 방문했던 테이블을 반환합니다.
 이제 저희는 새로운 로직으로 다시 테스트할 수 있습니다:
[REPL]

 보시다시피, 그래프의 연결을 계산하는데 1분 정도 걸렸던데 반해, 이제는 같은 일을 하는데 단지 1초정도 빢에 걸리지 않습니다!
 이것이 해쉬 테이블의 사용법을 알고 있어야 하는 이유입니다.


Common Lisp 구조체(Structures)
 구조체는 Common Lisp에서 사용가능한 진보된 자료구조입니다. 구조체와 속성(property)은 여러분의 코드에서 데이터를 표현할 유용한 방법이 될 수 있습니다.


구조체로 작업하기
 구조체는 이와 같이 defstruct 명령어를 사용하여, 전통적인 객체-지향 프로그래밍(OOP) 언어에서 찾을 수 있는 것처럼 객체(objects)와 속성(properties)을 나타내는데 이용할 수 있습니다:
[REPL]

 이 구조체의 정의를 따르자면, person은 네가지 속성을 가집니다(Lisper들이 슬롯(slots)이라고 부르는): name, age, waist-size, favorite-color.
 이 구조체를 정의하면, person대신에 defstruct가 자동적으로 생성한 특별한 함수 make-person명령어를 사용하여 생성할 수 있습니다:
[REPL]

 이제 *bob*을 REPL에 입력하면, 구조체 접두사 #S가 표기된 새로운 person을 보게될 것입니다. 저희는 또한 구조체가 person 형식이라는 것과 각 속성(name, age, waist-size, favorite-color)의 값을 알 수 있습니다:
[REPL]

 또 다른 자동적으로 생성된 person-age함수를 호출함으로써 Bob의 나이를 알 수 있습니다:
[REPL]

 우리는 또한 setf와 이 명령어를 사용하여 Bob의 나이를 바꿀 수 있습니다.(생일 축하해, Bob!)
[REPL]

 Lisp의 입/출력 대칭성에 대한 또 다른 좋은 예제로, Lisp reader는 출력된 person의 모습으로부터 person을 직접 생성할 수도 있습니다:
[REPL]

 여기서 새로운 변수 *that-guy*를 만들고, 출력된 person의 모습만을 이용하여 이 값을 설정하였습니다. 이 변수는 이제 make-person함수를 사용한것 처럼 실제 person 구조체를 가지게 되었습니다.
 보시다시피, defstruct는 특별한 함수를 만드는데 사용할 수 있고, 새로운 객체를 생성하고 속성에 접근하기 쉽게 만들어주는 매우 강력한 명령어 입니다.


언제 구조체를 사용하는가
 오늘날, 많은 주류 프로그래머들은 크고 견고한 어플리케이션을 개발할 때 객체지향이 필수라고 믿고 있습니다. 반면, 많은 Lisper들은 전적으로 OOP 접근없이 고품질의 소프트웨어를 만드는 것이 가능하다고 믿고 있습니다.
 14장 시작부분에서, 고-수준 함수형 프로그래밍과 영역 특수적(domain-specific) 언어 프로그래밍을 포함하여 이러한 접근 방식을 보여줄 것입니다. Lisp언어의 설계는 다른 가능한 객체지향적 언어보다 더욱 이러한 대안 접근을 이용하기가 쉽게 만듭니다.
 비록 여러분이 OOP 소프트웨어를 작성하지 않을지라도, 구조체와 속성은 여전히 코드에서 데이터를 표현할 유용할 방법입니다. 예를들어, defstruct로 person 클래스를 생성하는 대신에, 표준 리스트와 저희만의 make-person함수로 동일한 일을 할 수 있습니다. 그렇다면, 이와 같이 리스트를 사용하여 person기능을 할 수 있는데, 왜 구조체에 애를 쓸까요?
[REPL]

 비록 이런 접근방식이 통할지라도, 나쁜 점이 있습니다. 우선 person의 age나 다른 속성들을 확인하기 위해, 정확한 위치에서 속성을 얻어오는 에러를 유발하기 쉬운 함수를 많이 작성해야만 할 것입니다. 또한, 즉석에서 마련된 저희 객체의 출력은 매우 이해하기 어렵습니다. BOB이 person이라는 것을 알겠습니까? Bob의 나이는 35살입니까 아니면 32살입니까? 평범한 리스트는 객체와 다수의 속성을 인코딩하기에 적합하지 않습니다.
 실제 사회에서 리스트를 사용하여 객체를 표현하는데 또 다른 문제로는, (person 객체처럼) 객체의 속성은 시간에 따라 변화될 수 있다는 것입니다. Lisp에서 리스트는 생성됬을때부터 변치않는 정보를 다룰 때 제대로 동작합니다. 그러나 Bob이 36살이 되었을때, 그의 age 속성을 바꿔야됩니다.
 구조체의 데이터 부분이 시간 지남에 따라 바뀌는 것을 컴퓨터 과학자들은 mutation(변화)라 부릅니다. defstruct에 의해 만들어진 구조체의 특정 속성의 값을 쉽게 바꿀 수 있어서, 변화하는 데이터를 다루기에 매우 적합합니다. 그러므로 person(혹은 시간이 지남에 변하는 객체)을 구조체에 저장하는게 이치에 맞습니다. 저희는 14장에서 mutation 문제를 더욱 자세히 다룰 것입니다.

NOTE 
 defstrcut기능은 Common Lisp에서 객체를 생성하는 곳에만 이용할 수 있는 도구가 아닙니다. 예를 들어, 책의 에필로그에서 여러분은 Common Lisp의 Common Lisp Object System(CLOS)가 매우 정교한 객체 기반 시스템을 만드는 것을 볼 수 있습니다. 만일 여러분이 강건한 객체지향적 사고방식을 지녔다면, 아마도 필요한 모든 OOP 언어의 기능들을 Common Lisp에서 찾을 것입니다. 실제로, CLOS는 많은 다른 곳에서 발견하지 못한 객체지향적 기능의 이점을 가지고 있습니다. 이러한 이유로, CLOS는 OOP idea를 공부하는 연구도구로 자주 이용됩니다.


제레닉한 방식으로 데이터 다루기
 Common Lisp는 우아하고 효율적인 프로그램을 작성하기 위한 다양한 자료구조을 지녔습니다. 그러나 주의하지 않으면, 이러한 많은 자료구조를 지닌것은 못생기고 중복되는 코드를 야기할 수 있습니다.
 예를들어, 리스트와 배열에 저장된 수들을 더한다고 가정해봅시다. 리스트와 배열의 행동방식이 다르므로, (하나는 리스트 다른 하나는 배열를 위한) 서로 다른 두가지 덧셈 함수를 작성해야 합니다. 어떤 수가 저장되었는지 신경쓸 필요 없이 두 경우 모두 다룰 단일 코드덩어리를 작성할 수 있으면 좋을 것입니다.
 Common Lisp는 제네릭 라이브러리 함수, type predicates, defmethod, 제네릭 접근자를 포함하여 제네릭 코드를 작성할때 필요한 모든 기능을 지녔습니다. (내장된 것(built-in)뿐만아니라 defstruct로 만든 사용자 타입을 포함하여) 많은 데이터 형식을 다루는 코드를 작성하기 위해 코드의 불필요한 중복됨이 없이 이러한 기능들을 사용할 수 있습니다.


시퀀스(Sequence)로 작업하기
 어떤 타입과도 작동하는 코드를 작성하기 가장 쉬운 방법으로는 타입을 검사하는 작업을 다른 쪽에 넘겨주는 것입니다. Common Lisp 라이브러리들은 인자에 있는 다양한 종류의 데이터를 제레닉하게 다룰 수 있는 함수들로 가득차 있습니다. 시퀀스함수들은  세 종류의 Lisp 시퀀스 객체에 대해 제네릭하게 동작합니다: 리스트, 배열, 문자열.
 여러분은 이미 이러한 시퀀스 함수 중 하나를 보았습니다: length 함수. 세 종류의 시퀀스의 길이를 확인하기 위해 length 함수를 사용할 수 있습니다:
[REPL]

 제네릭 length 함수가 없다면, 여러분은 문자열, 배열, 리스트의 길이를 판별하기 위해 세개의 다른 함수들을 사용해야만 합니다.

NOTE
 Common Lisp는 리스트의 길이를 확인하는 특별한 함수 list-length를 가졌습니다 왜냐하면 제네릭 함수는 정확한 행동을 결정하기 위해 추가로 타입을 검사하는 작업이 필요로 하는 경향이 있고, 실행시 느려질 수 있습니다. list-length함수가 성능에 예민한 코드에 유용하지만, 대다수의 Lisper들은 일반적인 코드에서 제네릭 length 함수를 사용합니다.


시퀀스 탐색 함수
 시퀀스를 뒤지는 몇몇 함수들:

z find-if : predicate를 만족하는 첫번째 값을 찾는다.
z count : sequence에 특정 객체의 빈도를 알아낸다.
z position : 어떤 항목이 위치한 곳을 알려준다.
z some과 every : 시퀀스에 있는 모든 값이 지정된 predicate를 따르는지 알려준다.

 여기 몇몇 예가 있습니다:
[REPL]

 이번 예제에서, 시퀀스에서 첫번째 수 5를 찾기 위해 find-if를 사용했습니다. "mississippi"에서 문자 s가 얼마나 많이 나오는지 알기 위해 count를 사용했습니다. 문자 4가 보이는 위치를 찾기 위해 position을 사용하였습니다. 이번 경우에, 이것은 0부터 세기 시작하여 5번째 위치에 있습니다. 시퀀스에 있는 어떤 항목에 숫자가 들어있는지 알기위해 some을 사용했습니다. 실제로, 그곳에 숫자가 있었습니다. 마지막으로, 리스트에 있는 모든 항목이 숫자인지 확인하기 위해 every를 사용하였고, 이번에는 아니였습니다.


시퀀스를 순환하기 위한 시퀀스 함수들
 특히 유용한 제네릭 시퀀스함수 중 하나는 reduce입니다. reduce함수는 시퀀스를 순환하고 다듬어서 단일 결과로 내보냅니다. 여기에선, 리스트에 있는 항목들을 모두 더하기 위해 reduce를 사용하였습니다:
[REPL]

 이 수들의 합은 20으로 밝혀졌습니다. 여기 이번 예제에서 정확히 어떤 일이 벌어졌는지 보여주는 도해(圖解, diagram)가 있습니다:
[PIC]

 회색으로 보이는 오른쪽 부분이 저희 리스트입니다. 왼쪽 부분에서 plus (+) 함수를 채우는 숫자 쌍과 계산되어 나온 중간결과물을 볼수 있습니다. plus함수가 리스트에 있는 다음 숫자와 같이 하나의 중간 결과물을 인자로 받는다는 것을 보여줍니다. plus 함수를 처음 호출할때 하나의 예외가 있습니다. 처음 plus함수를 호출할때 중간 결과물이 없기에, 리스트의 시작 부분에 있는 3을 뽑아서 중간 결과물로 이동시킵니다. 그러므로, plus함수가 첫번째로 호출되었을때 실제로 리스트의 상단에 있는 두 항목을 받아옵니다.
 조금 더 복잡한 예제를 살펴볼 것인데, 이번에는 저희만의 reduction함수를 사용하였습니다. 리스트에서 가장 큰 짝수를 찾아낼 것입니다:
[REPL]

 저희 reduction 함수는 두 인자를 받습니다. 첫번째 인자는 지금까지 찾은 최선의 값입니다 - 다시말해, 지금까지 찾은 가장 큰 짝수. 두번째 인자는 리스트에서 다음 숫자 입니다. 저희 reduce함수는 결과로 새로운 최선의 숫자를 반환합니다. 그러므로 나중 수가 이전 최선값보다 더 좋다면, 그것을 반환합니다. 반대의 경우, 이전 최선값를 반환합니다.
 리스트에 있는 첫번째 수가 초기 값으로 쓰여진다는 것을 기억하시기 바랍니다. 만약 이것이 문제가 된다면, :initial-value란 keyword 인자로 명시적인 초기 값을 넣을 수도 있습니다.
 보통 reduce함수에 초기 값 지정이 필수적이며, 그렇지 않으면 버그가 여러분의 코드에 기어들어올 수 도 있습니다. 저희 예제에서, 리스트 앞에 있는 홀수를 가장 큰 짝수로 잘못 여길수도 있습니다. 초기 값을 빼먹엇을때 무슨 일이 일어나는지 살펴봅시다.
[REPL]

 예, 초기 reduce값을 지정하지 않은 결과는 무시무시 합니다.
 reduce함수의 또 다른 이점으로는 제네릭이라는 것입니다. 리스트, 배열, 혹은 문자열을 같은 방식으로 reduce할 수 있고, 다른 시퀀스 타입의 차이를 판별하지 않는 함수를 작성하기 위해 reduce를 사용할 수 있습니다.
 일찍이, 제가 리스트나 배열에 있는 수를 더할 수 있는 함수를 편리하게 작성 할 수 있다고 언급드린 적이 있습니다. 이제 그 함수를 작성 할 수 있습니다:
[REPL]
[PIC]

 sum은 무지하여 배열과 리스트의 차이를 인지하지 못합니다; 둘 다 동작합니다. 그러나, 덧셈은 어떠한 문장을 만들지 못하므로, 문자열을 사용했을때 sum함수는 에러를 반환합니다.
 시퀀스를 순한하기에 유용한 또 다른 함수는 map함수입니다. 이 함수는 mapcar와 동일하게 행동합니다. 그러나, mapcar와는 달리 map함수는 리스트뿐만아니라 모든 시퀀스 타입에 동작합니다. mapping된것을 반환하기 위해 map함수에 추가 인자를 넣어 시퀀스의 타입을 지정합니다.
 여기 map의 한 예가 있습니다:
[REPL]

 이번 예제에선, 문자열에 있는 모든 문자을 대문자로 바꿨습니다. map함수는 단순히 현재 문자 s를 확인하여 맞다면 대문자 S를 반환합니다
 계산 결과는 문자 리스트입니다. map함수에게 결과로 list를 원한다고 말했기 때문입니다. string을 원한다 했다면, 문자열을 결과로 얻었을것입니다.


중요한 시퀀스 함수 2개
 subseq 함수는 시작과 끝을 지정하여, 보다 큰 시퀀스에서 하위 시퀀스를 뽑아옵니다:
[source]

 보시다시피, america단어는 2번째부터 6번째를 끝으로하는 eric을 포함하고 있습니다.
 sort함수는 정렬하기 위해 이를 임의의 함수에 통과시킵니다. 이번에는, <(작다)함수를 사용하였습니다:
[REPL]

 저희가 다루었던 것보다 더 많은 시컨스 함수가 있지만, 이 예제가 좋은 시작점이 될 것입니다.

NOTE
 포괄적인 시퀀스함수 목록과 실제 모든 Common Lisp 함수들을 원한다면, Common Lisp가 제공하는 완벽하지만 위압적인 설명을 제공하는 Comon Lisp Hyperspec(http://www.snipurl.com/rz3h0)을 방문하시기 바랍니다.


Type Predicate로 사용자 제레닉 함수 만들기
 다른 Lisp들과 같이 Common Lisp는 동적 타입 언어입니다. 이것은 코드에 있는 인자 혹은 변수에 어떠한 자료구조라도 넣을 수 있다는 것을 의미합니다 - 심볼, 문자열, 숫자, 함수들, 혹은 여러분이 그곳에 넣기 원하는 무언가. 사실, 같은 인자 혹은 변수는 프로그램이 동작중에 매번 다른 자료구조를 받을 수 있습니다
 그러므로, 변수가 어떤 자료구조를 지녔는지 알려주는 분기함수가 있어야 합니다. 예를 들어, numberp로 숫자를 가졌는지 확인할 수 있습니다:
[REPL]

 아마도 여러분이 가장 많이 사용하게 될 type predicate들은 arrayp, characterp, consp, functionp, hash-table-p, lispp, stringp, 그리고 symbolp일 것입니다.
 서로 다른 자료구조를 제네릭하게 다루는 함수를 작성하기 위해 type predicate를 이용할 수 있습니다. 숫자나 리스트를 더하는 함수를 작성하기 원한다고 가정해봅시다. 여기 그와 같은 함수를 작성한 방법이 나와있습니다:
[REPL]

 add 함수에서 인자로 들어온것이 숫자인지 리스트인지 확인하기 위해 predicate를 사용하였고, 적절하게 처리하였습니다. 만약 두개의 숫자나 두개의 리스트가 아니라면, 단순히 nil을 리턴할 것입니다.
 비록 다양한 자료구조를 지원하는 함수를 작성할 수 있을지라도, 대다수의 Lisper들은 다음과 같은 이유로 인해 이러한 방식으로 add함수를 작성하지 않습니다:


모든 타입을 위한 하나의 덩어리monolithic 함수:
 단지 2가지라면 괜찮지만, 만일 12개 혹은 더 많은 종류를 다루기 원한다면 함수는 거대한 괴물로 변하고 말것입니다.

새로운 경우를 추가하기 위한 수정:
 새로운 타입을 지원하도록 add함수를 바꿔야 한다면, 기존에 있던 코드를 망칠 경우의 수도 증가하게 됩니다. 이상적인것은 이미 작업한 코드를 건들지 않고 각각의 새로운 상황을 다루도록 하는 것입니다.

이해하기에 여려움:
 주된 cond문이 무얼하는지 이 타입에 맞게 가는 것인지 정확히 이해하는데 어렵습니다.

성능:
 함수의 결과는 느릴 것입니다. 예를들어, Lisp 인터프리터/컴파일러는 appending이 일어날때 두 항목이 리스트라는것을 미리 안다면 두 리스트를 빠르게 appending하는 더 빠른 코드를 생성할 수 있습니다. 그러나 add함수에 첫번째 시도에서 두 인자의 타입은 다릅니다. 두 변수가 리스트라는 것을 (and (listp a) (listp b))라는 조건에서 알려면 컴파일러가 좀 더 똑똑해야합니다. 각 타입의 상황에 맞게 인자의 타입을 정확히 기술한다면 컴파일러가 좀더 편해질 것입니다.


 특정 자료구조가 주어졌을때 다른일을 수행하는 함수를 갖는게 유용하므로, Common Lisp 명령어 defmethod는 각각 다른 타입을 지원하는 다수의 함수를 정의할 수 있도록 합니다. 함수가 호출될때, Lisp는 인자의 종류를 호출될시 확인하고 정확한 함수의 버전을 자동으로 선택합니다. 컴파일러/인터프리터가 인자의 타입에 기반하여 다른 함수를 선택하는것을 type dispatching 이라 합니다.
 여기 defmethod를 이용하여 어떻게 add함수를 작성하는지가 나와있습니다:
[REPL]

 보시다시피, add함수는 분리된 함수로써 각 타입의 상태을 조정하고, 기존에 존재하는 코드에 수정 없이 새로운 상황을 추가할 수 있습니다. 종합적으로 코드가 더욱 이해하기 쉬워집니다. 또한, 컴파일러는 인자의 타입을 알아볼 수 있고 이를 활용하여 더 빠른 코드를 작성할지도 모릅니다.
 defmethod함수는 같은 이름을 갖는 다수의 함수를 작성한다는 점을 제외하면 defun과 비슷합니다. defmethod를 사용하면 함수의 인자 리스트에서 각 인자의 종류를 정확히 나타낼 수 있으며, Lisp는 각 상황에 맞는 add를 밝혀내기 위해 이 타입의 선언을 이용할 수 있습니다.
 만일 여러분께서 OOP 세계와 친숙하다면, 아마도 method란 단어가 여러분에게 특별한 의미를 지닐 것입니다. 이 새로운 명령어가 defmethod라 불리기 때문에, OOP와 관계가 있을까요? 예 맞습니다. 이 명령어는 단지 Common Lisp의 built-in 타입뿐만 아니라 여러분이 defstruct로 만든 structure 또한 이용할 수 있습니다. 기본적으로 defstruct와 demethod 조합은 간단한 객체 시스템을 구성합니다
 이제 게임을 작성하기위해 이러한 객체 시스템을 이용할 수 있게 되었습니다!


Orc Battle 게임
 Orc Battle 게임에서 여러분은 12마리의 몬스터에 둘러싸여 죽음에 맞써 싸우고 있는 기사입니다. 여러분의 지혜와 검술을 가지고 오크, 히드라, 그리고 다른 끔찍한 적들에 맞서 신중히 전략을 짜야만 합니다. 한번 잘못 움직이면, 그들 모두 쓰러트리기 전에 머릿수에 밀려버릴 것입니다. defmethod와 defstruct를 사용하여, 이 쓰레기들 해치워 버립시다!
[PIC]


플레이어와 몬스터에 대한 전역 변수
 저희는 플레이어의 상태를 추적하길 원합니다: 체력(health), 민첩(agility), 그리고 힘(strength). 플레이어의 체력이 0에 도달하면 사망합니다. 민첩은 얼마나 많이 공격할 수 있는지를, 그리고 공격력은 공격의 흉폭함을 조절합니다. 게임 진행에서 각각 변할 것이고, 게임진행과 전략에 미묘하게 영향을 줄 것입니다
[SOURCE]

 *monsters* 배열에 몬스터들을 저장하였습니다. 이 배열은 오크, 히드라, 혹은 다른 몬스터들을 저장할 수 있습니다. defstruct로 몬스터의 종족을 결정할 수 있습니다. 물론, Lisp의 제네릭 기능에서 리스트에 있는 각 타입을 어떻게 다루어야할지 계산해야 합니다.
 또한 *monster-builders* 변수에 저장되어 있는 몬스터를 만들기위해, 함수 리스트를 선언해야합니다. 몬스터 타입에 관한 코드를 각각 작성함으로써, 각각의 타입에 맞는 몬스터를 만들어주는 함수를 생성할 것입니다. 몬스터를 생성하는 것 각각을 이 리스트에 넣어야 합니다. 이 리스트가 생성하는 모든 함수들을 갖음으로써 게임에서 무작위로 몬스터를 만들기가 쉬워질 것입니다.
 마지막으로, 저희가 싸워야만하는 몬스터의 수를 조정할 *monster-num*변수를 만들어야 합니다. 이 변수를 증가시켜 (혹은 감소시켜) Orc Battle의 난이도를 변경하시기 바랍니다.
[SOURCE]


주 게임 함수
 이제 나머지 시스템을 이끌어줄 도안으로써 실제 게임 코드를 작성할 준비가 되었습니다.
 우선, orc-battle 함수를 정의할 것입니다. 이 함수는 몹을 초기화하고 게임루프를 시작하며, 전투가 끝나면, 승자를 판단하여 적절한 엔딩 메시지를 출력할 것입니다. 보시다시피, orc-battle 실제 작업을 하기 위해 충분한 도움함수들을 호출합니다.
[SOURCE]

 상단 부분에서 몹과 게이머를 위한 초기화 함수를 호출합니다. 다음 게임루프를 시작합니다. 게임루프는 플레이어나 몬스터들이 죽을때까지 지속될 것입니다. 저희는 플레이어나 몬스터가 죽었는지에 맞춰 게임 엔딩 메시지를 출력할 것입니다.
 다음으로, 게임루프를 다루기 위해 game-loop 함수를 만들 것입니다. 이 함수는 배틀 라운드를 처리하고, 다음 라운드를 위해 자기 자신을 반복적으로 호출합니다:
[SOURCE]

 game-loop함수는 몬스터와 플레이어의 반복되는 공격을 처리합니다. 싸움에서 살아있는 동안, 이 함수는 처음 REPL에서 플레이어에 대한 정보를 보여줄 것입니다.
 다음으로, 플레이어가 몬스터를 공격하도록 합시다. game-loop함수는 전투에서 한 라운드당 얼마나 많은 공격을 가할 수 있는지 조절하기 위해 플레이어의 agility을 이용하며, 오차범위를 이용하여 agility를 적절하게 작은 수로 변환시킵니다. 게임이 시작될때 플레이어는 라운드당 세번의 공격을 할 수 있습니다. 전투 후반에는 이 수가 라운드당 한번으로 떨어질 것입니다.
 플레이어의 공격루프를 위한 계산된 agility양을, 변수 이름과 숫자 n을 받아 코드 덩어리를 n번 실행하는 dotimes 명령어에 넣습니다:
[SOURCE]

 dotimes함수는 10장에서 더욱 자세하게 다룰 Common Lisp의 루핑함수중 하나 입니다.
 플레이어가 공격한 후, 몬스터가 공격을 하게금 해야 합니다. 몬스터 리스트를 map함수로 하여금 순환하게 하여 이 일을 수행합니다. 모든 몬스터는 몬스터가 살아 있는 동안 호출 할 수 있는 특별한 monster-attack 명령어를 가졌습니다.
 마지막으로, game-loop 함수는 자기자신을 반복하여 호출하므로, 전투는 어느 한쪽이 몰살당할때까지 계속됩니다.


플레이어 관리 함수
 플레이어의 속성(health, agility, strength)을 관리하는데 필요한 함수는 매우 간단합니다. 다음은 플레이어를 초기화하고, 죽었는지 확인하고, 상태를 출력하는데 필요한 함수입니다:
[SOURCE]

 player-attack 함수는 플레이어의 공격을 관장합니다.
[SOURCE]

 우선, 이 함수는 플레이어가 선택할 수 있는 몇몇 다른 공격 형식을 출력합니다. 보시다시피, 세가지의 공격이 플레이어에게 제공되었습니다: stab, double swing, roundhouse swing. 플레이어의 선택을 읽어, 상황에 맞게 각 공격의 형태를 조정합니다.
 stab공격은 가장 강렬한 공격이며 하나의 적을 공격합니다. stab가 단일 적에게만 효과가 있기에, 플레이어가 공격할 몬스터를 고르기 위해 pick-monster함수를 호출해야합니다. 공격력은 *player-strength*에 무작위 factor와 약간의 수정(너무 강력하지는 않도록 하여)을 가해 계산됩니다. 플레이어가 공격할 몬스터를 지정한후 공격력이 계산되면, 공격을 적용하는 monster-hit 함수를 호출합니다.
 stab 공격과는 달리, double swing은 약하지만, 한번에 두마리의 적을 공격합니다. 공격의 추가적인 이점으로는, 휘두르기 시작할때 얼마나 강한지 기사에게 알릴 수 있습니다 - 공격하기에 최선의 적을 선택하는데 이용되어지는 정보. 이러한 double swing의 이점은 게임의 적략적인 재미를 가미시킵니다. 반면, double-swing 코드는 메시지를 출력하고 플레이어가 누굴 공격할지 고른다는 면에서 stab 코드와 유사합니다. 그러나, 이번 경우에는 두 몬스터를 선택할 수 있습니다.
 마지막 공격 roundhouse swing은 적을 식별하지 못하는 야만적인 공격입니다. 플레이어의 strength를 기반으로 dotimes 루프를 돌아 무작위 적을 여러번 공격합니다. 그러나, strength가 단지 1빡에 안되어 각 공격은 매우 약합니다.
 승리하기 위해 이 공격을 올바른 상황에서 정확하게 사용해야 합니다. player-attack 함수에서 공격에 무작위성을 부여하기 위해, 무작위 수를 생성하는 randval 도움함수를 사용하였습니다. 이것은 다음과 같이 정의되었습니다:
[SOURCE]

 randval 함수는 1부터 n까지 무작위 숫자를 반환하며, n이 얼마나 작은지 상관치 않으며, 최소한 숫자 1이 반환될 것입니다. 0은 계산에서 사용되는 값으로 적절하지 않기 때문에, 무작위 수를 생성하기 위해 단순히 random함수 대신 randval를 사용함으로써 실제 게임의 무작위성을 검사합니다. 예를들어, 기진맥진한 플레이어나 몬스터라도 최소한 1을 공격력으로 가집니다.
 randval에서 사용된 random함수는 Lisp에서 고전적인 무작위 함수입니다. 몇몇 다른 방법으로 사용될 수 있으며, 주로 정수 n을 받아 0에서 n-1의 무작위 정수를 받아오는데 사용됩니다:
[REPL]


플레이어의 공격을 도와주는 함수
 player-attack 함수는 2개의 도움함수를 필요로 합니다. 우선, 아직 죽지 않은 혼동의 roundhouse 공격의 타겟 몬스터를 지정할 random-monster 함수가 필요합니다:
[SOURCE]

 random-monster 함수는 우선 몬스터 배열에서 무작위로 몬스터를 골라 변수 m에 저장합니다. 공격을 위해 살아있는 몬스터를 집기를 원하기 때문에, 우연히 죽은 몬스터를 집었다면 반복하여 다시 함수를 시도합니다. 그렇지 않으면, 선택된 몬스터를 반환합니다.
 player-attack 함수는 또한 플레이어가 무작위가 아닌 공격목표로 몬스터를 집을 수 있도록 하는 함수가 필요합니다. 이것은 pick-monster함수의 일입니다:
[SOURCE]

 플레이어가 공격하기 위해 몬스터를 선택하기 위해, 우선 프롬프트를 출력해야하고 플레이어의 선택을 읽어와야 합니다.
 그런 다음 플레이어의 결정이 너무 크지도 너무 작지도 않은 정수라는 것을 확인할 필요가 있습니다. 만약 그렇다면, 메시지를 출력하고 선택을 다시하기 위해 pick-monster를 다시 호출합니다. 그렇지 않다면, 선택한 몬스터를 변수 m에 안전히 넣을 수 있습니다.
 플레이어가 발생시킬 수 있는 또 다른 에러는 이미 죽은 몬스터를 공격하는 것입니다. 이러한 가능성을 확인하고, 다시한번 플레이어가 다른 선택을 하도록 만듭니다. 그렇지 않다면 플레이어는 성공적으로 선택을 하였고, 선택된 몬스터를 결과로 반환 합니다.
 이제 몬스터를 가지고 작업을 해 봅시다.


몬스터 관리 함수
 *monsters* 배열에 저장되어있는 나쁜놈들을 초기화 시키기 위해 init-monsters함수를 사용할 것입니다. 이 함수는 몬스터를 만들기 위해 *monster-builders* 리스트에서 함수는 무작위로 함수를 꺼내서 funcall로 호출합니다:
[SOURCE]

 우선, init-monsters 함수로 몬스터들을 담기 위한 빈 배열을 만듭니다. 그 다음 map으로 이 배열을 체웁니다. 이 lambda 함수에서, 몬스터 생성 리스트에 있는 함수를 무작위로 함수호출함으로써 몬스터가 생성되는걸 수 있습니다.
 다음으로, 몬스터가 죽었는지 확인할 간단한 함수가 필요합니다. 모든 몬스터에 대해서 monster-dead 함수가 참인지 확인하기 위해, *monsters* 배열에 있는 명령어를 어떻게 사용하는지 주목하시기 바랍니다. 이는 몬스터가 전부 죽었는지 알려줍니다.
[SOURCE]

 몬스터 목록을 모두 보여주기 위해 show-monsters 함수를 사용할 것입니다. 여기서 이 함수는 다른 함수로 그 작업의 일부를 미룰것이며, 따라서 실제로 다른 몬스터 타입에 대해 많이 알 필요가 없습니다:
[SOURCE]

 플레이어가 숫자로 몬스터를 선택할 것이므로, 변수 x를 몬스터 리스트로 루프시 얻는 것과 동일한 수치로 유지합니다. 다음으로 몬스터 리스트를 통해 각 몬스터에 맞게 텍스트를 출력할 lambda함수의 호출을 각 몬스터에 map시킵니다. 수치화된 리스트에 있는 각 몬스터를 변수 x를 이용하여 숫자로 출력합니다. 이를 수행할시, 리스트를 통해 작업할때 x를 증가시키는 incf 함수를 사용합니다.
 죽은 몬스터에 대한 정보를 출력하길 원치 않으므로, 단순히 죽었다는 메시지만 보여줍니다. 살아있는 몬스터에 대해서는, 제레닉 몬스터 함수를 호출합니다. health를 계산하고 각각의 적의 타입에 맞춰 몬스터의 설명을 생성합니다.


몬스터
 지금까지 실제로 몬스터에게 생명을 불어넣는 어떠한 함수도 보지 못하였습니다. 그것을 고쳐봅시다. 우선 제네릭 몬스터를 기술 할 것입니다.


제네릭 몬스터
 예상했듯이 오크, 히드라, 그리고 모든 나쁜 놈들에겐 하나의 공통점이 있습니다: 죽기전에 얼마나 많은 공격을 견뎌낼지 결정하는 체력. monster구조체에 이 행동양식을 넣을 수 있습니다:
[SOURCE]

 defstruct 함수를 사용함으로써 얻을 특별한 기능의 이점이 있습니다: 구조체에 있는 각각의 항목(이번 경우에, health)을 선언할때 괄호로 둘러싸 이름과 초기값을 넣을 수 있습니다. 그러나 더욱 중요한 점은, 새로운 몬스터가 생성될때 평가되는 form을 선언할 수 있다는 것입니다. 이 form이 randval을 호출하기 때문에, 모든 몬스터는 다르고 무작위의 체력을 지니고 전투를 시작하게 될것입니다.
 몬스터를 만들어 봅시다:
[REPL]

 또한 공격 받을때 몬스터의 체력을 줄여주는 함수가 필요합니다. 저희는 몬스터가 죽었을때 보여지는 메시지를 포함하여 어떤 일이 있어났는지 설명하는 메시지를 출력하는 함수를 가질것 입니다. 그러나, 이 함수를 defun으로 생성하는 대신에, 기사가 특별한 몬스터를 쓰려뜨렸을때 특별한 메시지를 보여줄 제네릭 defmethod를 사용할 것입니다:
[SOURCE]

 decf 함수는 변수로부터 하나를 빼게하는 setf의 변종입니다. type-of 함수는 monster-hit을 공격당한 몬스터의 타입을 아는 것처럼 행동하게 합니다. 이 함수는 어떤 Lisp 값의 타입을 찾는 데 사용할 수 있습니다:
[REPL]

 현재 몬스터의 종은 항상 monster가 될 것이지만, 곧 이 값은 각각에 대한 몬스터의 종으로 바뀌게 될 것입니다.
 또한 몬스터를 만들기 위해 두 개의 제네릭 메소드를 사용할 수 있습니다: monster-show 와 monster-attack.
 monster-attack함수는 실제로 어떠한 일도 하지 않습니다. 모든 몬스터 공격은 고유하여 제레닉 attack에서 정의할 필요가 없습니다. 이 함수는 단순히 자리만 차지하는 것입니다.
[SOURCE]

 이제 저희는 제네릭 몬스터 코드를 가졌고, 마침네 나쁜놈들을 생성할 수 있게 되었습니다!


강력한 오크(The Wicked Orc)
 orc는 단순한 적입니다. 몽둥이로 강력한 공격을 하는것 말곤, 별볼일 없습니다. 모든 orc는 고유한 공격 level의 몽둥이를 가졌습니다. 비정상적으로 강력한 몽둥이질을 하지 않는한 Orc들은 무시하는게 최선입니다. 
 orc를 만들기 위해, defstruct로 orc 자료구조를 정의합니다. 여기서, 저희는 defstruct의 또다른 진보된 기능을 사용하여 monster범주에 orc를 포함하도록 선언할 것입니다.
 orc타입을 범주에 포함시키기 위해 orc는 체력과 같은 모든 몬스터에 적용되는 영역을 상속 받아야합니다. C++나 Java와 같은 유명한 언어에서도 제네릭 클래스를 정의하고 이로부터 상속받는 더욱 특화된 클래스를 생성함으로써 이와 유사한 일을 할 수 있습니다.
 구조체가 일단 선언되면, (defstruct에 의해 자동적으로 생성된)make-orc함수를 *monster-builders* 리스트에 집어 넣습니다:
[SOURCE]

NOTE
 이러한 접근법은 정말로 강력합니다. 기본 Orc Battle 코드의 수정없이 저희가 원하는 새로운 몬스터 타입을 추가할 수 있습니다. 이것은 동적 타입과 first-class value로 함수를 지원하는 Lisp와 같은 언어에서만 가능합니다. 정적 타입 프로그래밍 언어에서의 Orc Battle 코드는, 새로운 타입의 몬스터마다 생성자를 호출하는 껄끄러운 방법이 필요할지도 모릅니다. first-class 함수로 인해, 이것에 대해 걱정할 필요가 없습니다.

[PIC]

 이제 orc에 맞게 monster-show와 monster-attack함수를 특화시킵시다. 이 함수의 인자 리스트가 orc에 특화되도록 명시적으로 선언한다는 점을 제외하면, 이 함수의 이전 버전과 동일한 방법으로 정의되었습니다:
[SOURCE]

 orc 타입에 관해 고유한 특성은 각 orc는 orc-club-level을 지녔다는 것입니다. 이 orc에 특화된 monster-show와 monster-attack버전은 이러한 것들을 고려합니다. monster-show함수에서 이 club레벨을 보여줌으로써, 플레이어는 각 orc의 위험수준을 측정할 수 있습니다.
 monster-attack함수에서, 이 club레벨을 사용하여 플레이어를 때릴때 얼마나 타격을 입히게 될 지를 결정합니다.


사악한 히드라(The Malicious Hydra)
[PIC]

 hydra는 매우 위험한 적입니다. 이것은 (무찌르기 위해선 잘라내야만 하는)많은 머리로 공격합니다. hydra의 특별한 능력은 매 배틀 라운드마다 새로운 머리가 자라날 수 있다는 것이며, 이는 가능한 빨리 이걸 쓰려뜨려야 한다는 것을 의미합니다.
[SOURCE]

 hydra를 다루는 코드는 orc를 다루는 코드와 유사합니다. 주요한 차이점은 hydra머리 수가 hydra의 health의 대리 역활을 한다는 것입니다. 다시 말해서, hydra가 3만큼의 체력을 지녔다면 3개의 머리를 가졌다는 것과 같습니다. 그러므로, hydra에 특화된 monster-show 함수를 작성시, 몬스터의 health를 이용하여 알맞게 hydra의 머리 수를 출력할 것입니다.
 orc와 hydra의 또 다른 차이점은 orc는 플레이어에게 맞았을때 딱히 흥미로운 일을 하지 않는다는 것입니다. 왜냐하면, orc에게 특화된 monster-hit함수를 작성하지 않았기 때문입니다; orc는 단순히 제네릭 monster를 위해 생성한 제네릭 monster-hit함수를 사용합니다.
 반면, hydra는 공격받았을때 어떤 흥미로운 일을 합니다: 머리가 떨어져 나갑니다! 그러므로 공격에 의해 머리가 사라지는 곳에 hydra의 health가 낮아지도록하는 hydra에 특화된 monster-hit함수를 작성합니다. 따라서, 저희는 이제 기사가 머리를 잘라내는 것에 관한 다이나믹한 메시지를 출력할 수 있습니다.
 hydra의 monster-attack함수는 orc와 유사합니다. 한가지 흥미로운 차이점은 매 공격마다 health가 증가한다는 점이며, 따라서 매 턴마다 hydra의 새로운 머리가 자라납니다.


끈끈한 슬라임 곰팡이(The Slimy Slime Mold)
 slime mold는 희귀한 몬스터입니다. 이것의 공격은, 다리를 감싸서 못움직이게 만들어 다른 나쁜놈들이 해치우도록 만듭니다. 또한 이것은 얼굴에 찐득 찐득한것을 뱉습니다. 민첩을 유지하기 위해 초기에 slime을 제거해버리는게 나은지, 무시하고 흉칙한 적에 집중하는지 빠르게 결정해야 합니다. (slime mold가 민첩을 낮추므로 나중에 있을 배틀 라운드에서 여러분의 공격 횟수가 줄어든다는 것을 명심하시기 바랍니다.)
[PIC]
[SOURCE]
<<<<<<<<<<<<<<<<<<<<<<<<<<<
 slime mold의 monster-attack 함수는 플레이어를 움직이지 못하게 하는 특별한 일을 합니다. 우선 slime mold의 (각 slime mold가 만들어질 때 생성된)끈끈이를 사용하여 변수 x에 저장된 플레이어에게 무작위 공격을 생성합니다. 게임에서의 다른 공격과는 달리 이 slime mold 공격은 플레이어의 health보다는 agility에 영향을 미칩니다.
 그러나, 만약 slime mold가 플레이어의 health를 조금이라도 깍아날 수 없다면, 아무런 소용없이 플레이어와 slime mold가 계속 꼼짝 못하게 되어 전투는 형편없이 끝나게 될 것 입니다.
 그러므로, 이 slime mold는 또한 매 공격마다 플레이어의 health를 1씩 빼는 superwimpy squirt 공격을 합니다


교활한 도적(The Cunning Brigand)
 brigand는 여러분의 적들 중 가장 작습니다. 그는 채찍이나 새총을 사용하고 여러분의 최고의 자산assets을 무효화시키려 합니다. 그의 공격은 강력하진 않지만, 매 라운드마다 2 포인트씩 거듭됩니다.
[SOURCE]
[PIC]

 약삭빠른 brigand가 공격할때 하는 첫번째 일은 플레이어의 체력, 민첩, 공격력을 살펴보고, 공격 목표로 이 세가지중 가장 높은것을 선택하는 것입니다. 모든 속성이 높다면, brigand는 민첩보다 체력을 공격력보다 민첩을 공격에 초점을 둡니다. 만약 체력이 높다면, 플레이어는 새총으로 맞을 것 입니다. 민첩이 높다면, brigand는 플레이어의 다리를 채찍질 할 것입니다. 공격력이 높다면, brigand는 플레이어의 팔에 채찍질 할 것입니다.
 이제 저희는 저희 게임의 모든 몬스터들을 완벽히 정의하였습니다!


전투!
 게임을 시작하기 위해, REPL에서 orc-battle을 호출합니다:
[REPL]

 매우 끝내주게 생긴 7개의 머리를 가진 hydra - 우선 이것을 stab로 끝내버립시다:
[REPL]

 딱히 눈에 띄는 나쁜 놈이 없으므로, 전체적으로 이들의 체력을 조금씩 깍아 내기위해 roundhouse를 시도 합시다:
[REPL]

 훌륭합니다! 약한 몬스터중 하나가 죽었습니다. 이제 민첩이 가득 찼으므로 라운드당 3번 공격할 수 있습니다. 이는 나중에 좀더 강력한 나쁜놈을 날려버리기 위해 전략적으로 마지막 공격에 이용해야만 한다는 것을 의미합니다. double swing을 이용해 봅시다:
[REPL]

 적에게 한방 먹었지만, 여전히 많은 싸움이 남아 있습니다. 이 싸움은 아직 끝나지 않았습니다!
 보시다시피, Orc Battle에서 살아 남으려면 뛰어난 전략이 필요합니다. 저는 여러분께서 이 새로운 게임을 마음껏 즐겼으면 합니다!


여러분이 배운것
 이번 장에서, Common Lisp에 있는 더욱 진보된 데이터 구조를 다루었습니다. 그후 이를 이용하여 괴물들과 대적하는 게임을 만들었습니다. 이러한 과정을 거치며, 저희는 다음과 같은것을 배웠습니다:

z 배열은 리스트와 유사하나, 특정 offset에 있는 항목에 효율적으로 접근한다.
z 해쉬 테이블은 alist와 유사하나, 키와 연관된 값을 효율적으로 찾는다.
z 적절한 장소에서 배열과 해쉬 테이블을 사용하는 것은 코드를 보다 빠르게 해 줄 것이다.
z  데이터 구조나 알고리즘을 바꾸는 것이 여러분의 프로그램을 빠르게 만들어 주는지 아는 유일한 방법으로는 time 명령어로 여러분의 코드의 시간을 제는 것이다.
z Common Lisp는 다양한 자료구조에 사용할 수 있는 generic 함수들을 가졌다. 이러한 sequence 함수들의 유용함은 리스트, 배열, 문자열을 명료하게 다룰 수 있다는 것입니다.
z defstruct 명령어를 사용하여 object와 properties를 list로 만들 수 있다.