9장.진보된 데이터형식과 제네릭 프로그래밍

9.ADVANCED DATATYPES AND GENERIC PROGRAMMING


 봐왔던 것과 같이, Lisp에서  cons cells, symbols, 문자열, 수치 데이터형식으로
수행할 수 있는 많은것들이 있습니다. 매우 성숙한 언어답게, Common Lisp는 이러한 기본적인 것을 뛰어넘을 더 많은 데이터 형식을 포함하고 있습니다. 이번장에서는, 이러한 배열arrays,  해쉬테이블hash tables, 그리고 구조체structures포함해서 진보된 데이터형식의 유용함을 다룰 것입니다.


Arrays

 Common Lisp 배열은 list와 매우 유사합니다. 배열을 사용함으로 얻는 주요 이점은 어떤 특정 지점에 있는 값에 접근하기 위해 상수 시간을 요구한다는 것입니다. 이것이 의미하는 것이 무엇인지 짧게 다룰 것입니다.


Working with Arrays

 새로운 배열을 만들기 위해선 배열의 크기를 지정하여 make-array 명령어를 사용합니다:
[source]

 이것은 길이가 3인 배열을 만듭니다. 만들어진 값이 list가 아니라는 것을 나타내기 위해, Common Lisp는 배열 앞에 해쉬 표시(#)를 답니다.

 배열에 있는 항목을 얻거나 설정하기 위해선 aref함수를 사용합니다. 예를 들어, 여기 index 1에 있는 항목을 어떻게 얻는지 나와 있습니다:
[source]

 물론 지금 당장 배열은 nil로 체워져 있어서, getting 할 가치가 없습니다. 배열에 있는 항목을 더 흥미를 끄는 값들로 설정하기 위해, setf 명령어와 함께 aref를 사용합니다:
[source]

 aref가 배열에서 값을 얻기에 유용하지만, 이 예제에서 나타난 특별한 방법으로 사용될때에는 배열의 값을 설정합니다. setf와 aref 명령어를 같이 사용하는 능력은 Common Lisp의 능력을 보여줍니다: 제네릭 프로그래밍을 지원합니다. 어떻게 이 기능이 동작하는지 더 배우기 위해 setf명령어를 자세히 살펴봅시다.



Using a Generic Setter

 Common Lisp 언어는 제네릭generic setter를 지원한다고 말합니다. 대부분 이것이 의미하는 것은 데이터 구조(배열, 리스트, 문자열, 혹은 다른 것)에서 값을 빼내오는 code가 같은 데이터 구조에 넣는 code와 동일하다는 것입니다. setf명령어는 getting 연산을 하는 함수와 결합하여 사용할 수 있고, setting 연산을 하는 함수와도 사용할 수 있습니다.

 이미 저희는 aref 배열에서 값을 얻을 때 사용할 수 있다는 것을 보았고, setf와 사용하여 배열의 값을 setting시 사용할 수 있다는 것을 보았습니다. data 구조로부터 항목을 얻는 대다수의 Common Lisp의 명령어에서, setf명령어는 제네릭 방식으로 이 trick을 수행할 수 있습니다. 예를 들어
, list와 관련 있는 다음 예제를 봅시다:
[source]

 기대했던 것과 같이 표현식 (second foo)는 B를 반환합니다. 그러나 setf명령어에 (second foo)를 통과시켰을 때, 이것은 B가 어디서 왔는지 알고 표현식 (second foo)를 regular 변수인 것처럼 다룰 수 있습니다. 기본적으로, setf명령어는 자기 자신에게 질문합니다 "첫 번째 인자에 있는 항목이 본디 어디서 왔을까?" 이번 경우에, 값은 foo라는 이름의 list의 두 번째 항목에서 왔습니다. 그러므로, 이 지점에서 setf를 시도한다면 원본 변수 foo는 반응하여 수정됩니다.

 사실 setf의 첫번째 인자는 generalized reference라고 불리는 Common Lisp의 특별한 sublanguage입니다. 모든 Lisp 명령어가 generalized reference를 허용하는 것은 아니지만, but you can still put in some pretty complicated stuff:
[source]

 이번 예제는 Common Lisp에서 setf의 진정한 힘을 보여줍니다. 첫번째 사용한 것에서, list (x y z) 를 배열의 세번째 항목으로 넣었습니다. 만일 지금 foo를 출력한다면, 이것이 동작한 것을 볼 수 있습니다. 두번째로 사용한 것에서, foo 배열에 있는 이 list의 첫번째 항목을 해쉬테이블로 바꾸었습니다. 해쉬 태이블 은 157쪽에서 짧게 배울 또 다른 진보된 data 형식입니다. setf로 이 일을 하는 것은 놀랄 만큼 쉬운데, setf의 첫번째 인자에 있는 generalized reference는 임의로 복잡해질 수 있기 때문입니다.

 마지막으로, 해쉬 테이블안에 key는 zoink로 하여 값 5를 삽입하였습니다. gethash함수는 해쉬 테이블 밖으로 값을 얻어오도록 합니다. 대신 여기서는 setf의 도움으로 해시 테이블에 숫자 5를 넣었습니다.

 이번 예제로부터 프로그램에서 복잡한 data 구조를 수정할때 setf가 유용할 수 있다는 것을 인지하길 바랍니다.

 setf의 또 다른 멋진 기능은 값에 접근하는 새로운 방식을 지원하도록 generalized reference 문법을 확장 시킬 수 있다는 것입니다. setf는 내포된 단계(level of nesting)나 쓰여진 데이터형식에 구애받지 않고 값을 수정하는 진정한 generic 방식입니다.


Arrays vs. Lists

 여러분은 이제 Lisp에서 배열이 동작하는 기본 예제를 살펴보았습니다. 그러나 배열의 이점을 완전히 이해하기 위해, list와 비교해볼 필요가 있습니다.

 list로 할 수 있는 대다수는 배열로도 할 수 있습니다. 그러나, 일반적으로 배열은 특정 원소에 접근할때 list보다 빨라서 성능면에서는 다릅니다.

 예를들어 array-handling함수 aref는, 배열을 사용하지 않고 regular list의 특정 지점에 있는 항목에 접근하는 nth라 불리는 list-handling함수와 매우 유사흡니다. 여기 list에 nth를 사용하는 예제가 있습니다:
[source]

 그러나, 매우 작은 list에만 nth 함수를 사용하는게 이치에 맞습니다. 예를들어, list X가 수천개의 항목을 가졌고 (nth 1000 x)명령어를 실행하면 정말로 느릴것인데, Lisp list는 cons cells의 chain으로 만들어 졌기 때문입니다. Lisp에서 list에 있는 수천개의 항목을 찾을 수 있는 유일한 방법은 999개의 object를 먼저 휘졋고 다니는 것입니다.

 대조적으로, 큰 배열에서 (aref x 1000)명령어를 수행하는것은 이전 999항목을 거쳐 세는것 없이 천번째 항목을 직접 접근합니다. 이것이 의미하는 것은 큰 배열에서의 aref는 큰 list에서의 nth명령어보다 더욱 빠르게 수행될 것이라는 것입니다. 10억개의 항목을 가진 배열이 있을지라도, 마지막 항목을 검색하는 것은 여전히 매우 빠를것입니다. 실제 제한하는 요소는 오직 여러분의 시스템 뿐입니다: 여러분의 컴퓨터의 RAM용량과 이것을 이용하는 Lisp 환경의 저장 방식.
[pic]

 배열 값에 빠르게 접근할 수 있을 뿐만아니라, 일반적으로 여러분이 list로 같은 작업을 수행 할 수 있는 것보다 빠르게 특정 장소에 있는 값을 바꿀 수 있습니다.

 큰 data 구조에서 특정 값을 setting하거나 getting 하는 것은 매우 중요하므로, 배열을 여러분의 코드에서 가능한 최상의 성능을 얻도록 여러분을 도와줄수 있는 툴이라 명심하시기 바랍니다.


Hash Tables

 배열이 list과 비슷하듯이, 임의의 요소에 빠르게 접근한다는 점을 제외한다면 해쉬 테이블은 alist와 비슷합니다.

 사실, 해쉬 테이블은 때때로 마법처럼 보여질 정도로 매우 효율적입니다. 은하수를 여행하는 히치하이커를 위한 안내서의 Babel fish을 떠올려봅시다- 실제로는 존재하지 않지만 매우 놀랄만한게 유용한 것. 이것이 대다수의 모든 현대 언어들이 이제 해쉬 테이블 데이터형식을 제공하는지에 대한 이유입니다.
[pic]


Working with Hash Tables

 make-hash-table명령어로 새로운 해쉬 태이블을 만듭니다:
[source]

 alist와 같이 해쉬 테이블은 lookup key와 값을 이용하여 항목을 저장합니다. 항목의 key와 gethash 함수를 사용하여 해쉬 테이블로부터 하나의 항목을 받을 수 있습니다:
[source]

 지금까지 해쉬 테이블은 비어있습니다. 이것이 의미하는 것은 해쉬 테이블에서 어떤 key를 살펴볼때, 이번 예제에서 'yup  대답으로 NIL을 받는다는 것입니다. 실제로, 저희는 두개의 NIL을 받았습니다 - gethash 명령어는 Common Lisp에서 할 수 있는 여러개의 값을 반환합니다(다음 section에서 다룰것입니다). 반환된 첫번째 값은 해쉬 테이블에 저장된 실제 값이며, 두번째는 테이블에서 찾은 key가 무엇인지 가리킵니다(이번 경우에는, 없습니다).

 배열로 했을때 처럼, 여러분은 data로 테이블을 체우는 대신에 setf명령어와 data 요소를 참조하는데 사용하는 명령어를 조합할 수 있습니다 - 이번 경우에는 gethash:
[source]

 이번 예제에서, yup을 lookup key로써 해쉬 테이블에 값 25를 저장했습니다. 그 다음, 테이블에서 yup을 살펴보면, 25라는 답을 얻게 됩니다. 또한 t라는 두번째 값을얻는데 이것이 의미하는 것은 "예, 저는 테이블에서 key를 찾았습니다" 입니다.

 alist를 다루었을때, coffee 음료 주문을 포함하는 data 구조를 설정했던것이 기억나십니까? 여기 동일한 data가 있으며, 이번에는 해쉬 테이블을 사용하여 저장됩니다:
[source]

 누군가의 음료 주문을 찾아보는것이 이제 간단해졌습니다:
[source]


Returning Multiple Values

 Common Lisp는 여러분이 결과로 하나의 값보다 더 많이 반환하는 것을 허용합니다. 여러분이 봐왔던것 처럼 gethash함수를 포함하여 Common Lisp의 몇몇 core 함수는 이러한 일을 합니다. 일반적으로 사용되는 다른 함수는 수를 반올림하는 round 함수입니다:
[source]

 이 함수를 호출하면 수를 알맞게 2로 반올림하지만, 반올림 연산의 나머지인 두번째 값도 생성합니다. 이 함수 호출에서 두 값이 반환됩니다.

 또한 여러분의 code에서 values함수를 사용해서 다수의 값들을 생성할 수 있습니다. 예를들어, 여기서 여러분은 3과 7를 반환하는 foo라는 함수를 작성할 수 있습니다:
[source]

 round 함수와 마찬가지로 이 값들은 모두 REPL에서 출력됩니다. 그러나, Lisp는 첫번째 값을 더욱 중요하게 여기며, 후속 계산동안 항상 default로 사용될 것입니다. 예를들어, foo함수를 호출한 뒤 이와 같이 추가 작업을 수행할 수 있습니다:
[source]

 이번 경우에, 추가 연산은 foo가 반환한 두번째 값을 무시합니다.

 그러나, 종종 추가적인 반환 값을 사용해야 할 필요가 있습니다. multiple-value-bind명령어를 사용하여 이러한 일을 할 수 있습니다:
[source]

 이번 예제에서, a와 b 변수를 foo에 의해 반환된 값 (3 과 7)로 묶었습니다. multiple-value-bind와 함께 함수를 호출하여, 다른 경우에는 무시되어지는 함수로부터 반환된 추가 값들을 사용하도록 합니다.

 여러분은 multiple-value기능을 사용하는 대신에 함수로부터 list를 반환 할 수 있는지 궁금해할 지도 모릅니다. 정답은 "할 수 있다" 입니다. 그러나 mutiple-value기능을 사용하면 더욱 최적화되고 깔끔한 code를 이끌어내는 것이 가능합니다

 이 책에서는, multiple value를 사용하지 않습니다. 사실, Arc나 Clojure와 같은 최근 Lisp방언들은 multiple 값을 전혀 지원하지 않습니다. 대신에, 하나의 값보다 많이 반환될 필요가 있을 경우에 list를 반환합니다.


Hash Table Performance

 배열처럼, 해쉬 테이블이 얼마나 많은 항목들을 갖고 있던지 간에 해쉬 테이블 안에 있는 값의 접근과 수정은 상수 시간을 요구합니다. 예를 들어, 해쉬 테이블이 10개의 항목을 가지고 있다고 가정해 봅시다. key를 사용하여 테이블에서 값을 접근하고 이것을 찾아내는데 걸린 시간은 평균 0.001초가 걸립니다. 이제 해쉬 테이블이 1,000,000 항목을 가졌다고 가정해봅시다. (해쉬 테이블이 그렇게 설계되었기 때문에) 값을 받는데 여전히 0.001초가 걸릴 것이라고 예상할 수 있습니다. 다시말하자면, 테이블이 얼마나 크든지간에, 0.001초라는 상수 시간에 항목에 접근 할 수 있습니다.

 어떻게 엄청난 이 일이 가능한지 생각해 보십시요! 해쉬 테이블이 1,000,000개의 항목을 포함할지라도, gethash함수는 key를 취하여 상수 시간안에 여러분이 원하는 항목을 찾을수 있는 곳을 정확히 결정할 수 있습니다!

 어마어마한 양의 data를 뒤로하는 web-기반 프로그램의 시대에서, 많은 양의 값들을 저장하고 빠르게 반환하는 해쉬 테이블의 능력은 필수입니다. 키/값의 쌍으로 저장하는 효율성은 대다수의 온라인 저장 시스템에서 필수입니다. 구글의 BigTable이나 아마존의 S3와 같은 막대한 양의 온라인 데이터를 저장하는 최근 툴이라도, 해쉬테이블과 유사하게 만들어 키를 사용함으로써 값을 재빨리 받아오도록 만들어졌습니다

 그러나, 여러분은 항상 해쉬 테이블이 최고의 성능을 제공한다고 단언 할 수 는 없습니다. 여기에 왜 그런지에 대해 나와 있습니다:

가상 메모리 패이징virtual memory paging과  cache misses:
 배열과 마찬가지로, 큰 해쉬 테이블은 여러분의 운영체제로 하여금 하드 드라이브의 가상 메모리 패이징 유발시킵니다. 따라서 성능이 줄어들게 됩니다. 유사하게, CPU cache missed의 수도 증가 할 수 있습니다.

해쉬 충돌:
 내부적으로 해쉬 테이블은 키를 수로 변환시키는 hash함수라 불리는 특별한 함수를 사용합니다. 이와 같은 해쉬 함수는 해쉬 충돌을 유발시킵니다. 본질적으로 해쉬 충돌은 우연히 두키가 hash함수에 의해 같은 수로 변환될때 일어납니다. 이 경우에 미세한 성능 감소가 있을지라도 해쉬 테이블은 여전히 정확하게 행동합니다. 드믄 경우에, 특정 종류의 key가 충돌 횟수를 증가시키도록 hash 함수에 영향을 미칠 수가 있고 어플리케이션의 찾는 능력을 지연시켜 성능은 더욱더 감소하게 됩니다.

작은 테이블의 비효율성:
 매우 작은 테이블에서 해쉬 테이블이 요구하는 생성과 찾는 시간은 alist와 같은 간단한 구조보다 비효율적입니다. 해쉬 테이블의 성능 이점은 data양이 큰 경우에만 두드려집니다.


변하는 연산 속도:
 만약 여러분이 Common Lisp에서 작은 해쉬 테이블을 만들고 값으로 체워넣다보면 새로운 값을 추가하는 것이 때때로 비정상적으로 느리다는 것을 발견할 것입니다. make-hash-table함수가 작은 해쉬 테이블을 만드는 비용을 최소화하게 설계되었기 때문입니다. 그러나 테이블을 크게 만드는 값을 추가하기 시작한다면 Lisp는 더 많은 메모리를 할당하기위해 여분의 시간을 요구하며, 테이블은 더 많은 항목을 담을 수 있게 됩니다. 이러한 추가 할당은 테이블이 자라면서 종종 느린 삽입을 야기시킵니다.

해쉬 테이블이 항상 최선의 해결책이 아닌 마지막 이유:
 cons cells로부터 세워진 전통적인 Lisp 구조만큼 Lispy하지 않습니다. 이것이 의미하는 것은 Lisp REPL에서 자연스럽게 출력되거나 읽을 수 없기 때문에 디버그하기에 cons cells보다 어렵다는 것입니다. 그러므로, 좋은 rule of thumbs는 배열과 해쉬 테이블을 새로운 code조각으로써 염두에 두고 멀어지는 것입니다. 그리고 만약 성능이 이슈로 떠올랐을때, 어떤 성능 문제를 해결하기 위해 배열과 해쉬 테이블의 이점을 얻을 수 있는, 여러분의 code의 critical section을 신중하게 수정합시다.


A Faster Grand Theft Wumpus Using Hash Tables

 해쉬 테이블이 여러분의 code를 위해 무엇을 할 수 있는지 연습 문제를 살펴봅시다. 최근 게임 Grand Theft Wumpus에서 눈에띄는 비효율적인게 있었는데, 이제 그것을 해쉬 테이블로써 바로잡을 수 있습니다.

 Grand Theft Wumpus에서 도시 graph를 표현하기 위해 nodes와 edges의 list를 사용한 이전 장을 회상해봅시다. 주어진 node로 찾는 것 대신에, list를 통해 선형적으로 찾아야 합니다. Congestion City는 많은 교차로를 가지고 있지 않기 때문에, Grand Theft Wumpus에서 큰 작업을 요구하지 않습니다 그러나 도시가 천개의 node와 천개의 edge를 가진다면 어떨까요? get-commected 함수를 보고 어느 정도의 수치를 얻는지 봅시다:
[source]

 time명령어는 code 덩어리에 관한 모든 종류의 유용한 시간 정보를 출력하는 Lisp의 utility이며, dotimes함수는 code를 100번 수행하게 하고, 100개의 도시를 건설합니다. 이 명령을 사용해서 제 컴퓨터에서 이 code를 돌렸을때 일분 정도 걸렸습니다. CPU가 일분동안 처리할수 있는 엄청난 수의 instruction이 주어졌고, 이것은 명백하게 끔찍한 성능을 나타냅니다.

 이 문제를 해결하기 위해, edge list를 해쉬 테이블로 변경하고, 따라서 get-conncted함수는 상수 시간에 연결을 찾을 수 있을 것입니다. 또한 방문했던 list를 방문했던 table로 교체할 것이며, 따라서 함수는 빠르게 어떤 node가 이미 방문했는지 답할 수 있습니다.

 여기 이것을 수행하는 해쉬화된 버전으로 구성된 코드가 있습니다:
[source]

 우선, edge list를 해쉬 테이블로 변환시키는 hash-edges함수가 필요합니다. 함수의 시작 부분에서, tab이라는 새로운 해쉬 태이블을 만들었습니다. 그 다음, mapc로 테이블을 iterate합니다. side effect에 관해 주의해야 하거나 결과로 최종 list를 생성하는 것에 신경쓰지 않는 곳에 사용한다는 점을 제외하고, mapc는 mapcar와 같다는 것을 기억하시기 바랍니다.

 모든 node들에 대해 저희는 이것과 연결된 node들의 list를 포함할 table을 원합니다. 그러므로, list를 iterate하면서 starting node를 위해 neighbors의 list에 새로운 neighbor를 push합니다. regular Lisp 변수값처럼 해쉬 테이블 값에 push명령어를 사용할 수 있습니다. 다시 말해서 이것은, 166쪽 "Handling Data in a Generic Way" 에서 다룰, Common Lisp에서 만들어진 general 변수 시스템을 사용합니다.

 테이블에 있는 node의 값이 없는 경우를, 처리할 필요가 없어 혼란스러울지도 모릅니다. 어떻게 값이 존재하지 않는데 테이블에 무언가를 push할 수 있을까요? 테이블에서 key를 찾을 수 없을때 gethash함수는 NIL을 반환하기 때문에, 이 code는 단순히 새로운 neghbor를 empty list에 push하고 이전에 none을 찾았던 테이블에 새로운 기록을 집어넣습니다. 이리하여, push명령어는 node가 새것이거나 이전것이든 상관치않고 마법과도 같이 "정확한 일"을 수행합니다.

 마지막으로, 테이블이 가득차면 이것을 결과로 반환합니다. 이것은 원래 edge list와 같은 data를 포함하고 있습니다. 다른점은 Congestion City안의 어떤 node의 neighbors를 광속으로 찾을 수 있습니다.
[source]

 이제 저희는 Congestion City에서 시작 node에 연결된 모든 node들을 되돌려받을 get-connected-hash를 작성할 준비가 되었습니다. 이것은 get-connected와 행하는 것은 동일하지만, 해쉬 테이블을 통해 최적화 되었습니다.

 이 함수가 하는 첫번째 일은 방문했던 node들의 해쉬 테이블을 만드는 것입니다. 그 다음 starting node로부터 출발해서 Congestion City의 node들을 이동합니다. 새로운 node를 방문할 때마다, 이전에 방문했었는지 스스로 물어봅니다. 이제 저희는 방문했던 테이블에 있는 현재 node를 살펴봄으로써 이 질문에 매우 효율적으로 대답할 수 있습니다. 만일 아니라면, 이 노드를 방문했다고 표시할 필요가 있고 mapc로 이것의 모든 neighbors를 확인해야합니다 - edge table을 확인. 마지막으로, starting node와 연결된 모든 node들을 담고있을 방문했던 table을 반환합니다.

 이제 저희는 새로운 logic으로 다시 테스트할 수 있습니다:
[source]

 보시다시피, graph의 연결을 계산하는데 일분 정도 걸렸던데 반해, 이제는 같은 일을 하는데 단지 일초정도 빢에 걸리지 않습니다!

 이것이 해쉬 테이블의 사용법을 알고 있어야 하는 이유입니다.


Common Lisp Structures


 structure는 Common Lisp에서 사용가능한 진보된 데이터형식입니다. structure와 속성property은 여러분의 code에서 data를 표현할 유용한 방법이 될 수 있습니다.

Working with Structures

 Structure는 이와 같이 defstruct 명령어를 사용하여, 전통적인 객체-지향 프로그래밍(OOP) 언어에서 찾을 수 있는 것처럼 객체objects와 속성properties을 나타내는데 이용할 수 있습니다:
[source]

 이 structure의 정의를 따르자면, person은 네가지 속성을 가집니다(Lisper들이 slots이라고 부르는): name, age, waist-size, 그리고 favorite-color.

 이 structure를 정의하면, person대신에 defstruct가 자동적으로 생성한 특별한 함수 make-person명령어를 사용하여 생성할 수 있습니다:
[source]

 이제 *bob*을 REPL에 입력하면, structure 접두사 #S가 표기된 새로운 person을 보게될 것입니다. 저희는 또한 structure가 person 형식이라는 것과 이것의 각 속성(name, age, waist-size, 그리고 favorite-color)의 값을 알 수 있습니다:
[source]

 또 다른 자동적으로 생성된 person-age함수를 호출함으로써 Bob의 나이를 알 수 있습니다:
[source]

 우리는 또한 setf와 이 명령어를 사용하여 Bob의 나이를 바꿀 수 있습니다.(생일 축하해, Bob!)
[source]

 Lisp의 print/read symmetry에 대한 또 다른 좋은 예제로, Lisp reader는 또한 출력된 person의 모습으로부터 person을 직접 생성할 수 도 있습니다:
[source]

 여기서 새로운 변수 *that-guy*를 만들고, 출력된 person의 모습만을 이용하여 이 값을 설정하였습니다. 이 변수는 이제 make-person함수를 사용한것 처럼 실제 person structure를 가지게 되었습니다.

 보시다시피, defstruct는 특별한 함수를 만드는데 사용할 수 있고, 새로운 object를 생성하고 속성에 접근하기 쉽게 만들어주는 매우 강력한 명령어 입니다.


When to Use Structures

 오늘날, 많은 mainstream 프로그래머들은 크고 견고한 어플리케이션을 개발할때 객체 지향이 필수라고 믿고 있습니다. 반면, 많은 Lisper들은 purely OOP 접근없이 고품질의 소프트웨어를 만드는 것이 가능하다고 믿고 있습니다.

#TODO
 14장 시작부분에서, 고-수준 함수형 프로그래밍과 domain-specific 언어 프로그래밍을 포함하여 이러한 반대되는 접근 방식을 보여줄 것입니다.


Lisp언어의 설계
이러한 대안 접근의 이점을 쉽게 가져오도록 합니다
다른 걸로 가능한 것보다
객체-지향적 언어보다 더욱 
 The design of the Lisp language makes it much easier to take advantage of these alternate approaches than is possible with other, more object-oriented languages.


 비록 여러분이 purely OOP-style 소프트웨어를 작성하지 않을지라도, structure와 properties는 여전히 여러분의 code에서 data를 표현할 유용할 방법입니다.
Regardless, even if you’re not writing purely OOP-style software, structures 
and their properties can still prove to be a useful way to represent data in 
your code.

 예를들어, defstruct로 person class를 생성하는 대신에, 표준 list와 여러분만의 make-person함수로도 이와 동일한 일을 할 수 있습니다. 그렇다면, 이와 같이 list를 사용하여 person기능 할 수 있는데, 왜 structures에 애를 쓸까요?
[source]

#TODO
 비록 이런 접근방식이 통할지라도, 나쁜 점이 있습니다. ??? 우선 person의 age나 다른 properties를 확인하기 위해 정확한 위치에서 properties를 빼내는 많은 수의 error-prone 함수를 많이 작성해야만 합니다 First, in order to check a person’s age or other properties, we would need to write a lot of error-prone functions that pull properties out of the list from the correct locations. ??? 또한, 출력된 ad hoc object버전은 매우 이해하기 어렵습니다. BOB이 person이라는 것을 알겠습니까? Bob의 나이는 35살입니까 아니면 32살입니까?  Regular lists just don’t lend themselves well to encoding objects with multiple properties.

 실제 사회에서 list를 사용하여 object를 표현하는데 또 다른 문제로는 object의 property는 시간의 흘러 변화될 수 있다는 것입니다(person object와 같이). Lisp에서 list는 생성됬을때부터 변하지 않는 정보를 다룰때 제대로 동작합니다. 그러나 Bob이 36살이 되었을때, 그의 age property를 바꿔야됩니다.

 structure의 data부분이 시간 지남에 따라 바뀌는 것을 computer scientist들은 mutation이라 부릅니다. defstruct에 의해 만들어진 structure에 있는 특정 property(변하는 property)의 값을 쉽게 바꿀수 있어서, 변화하는 data를 다루기에 매우 적합합니다. 그러므로 person(혹은 시간이 지남에 변하는 object)을 structure에 저장하는게 이치에 맞습니다. 저희는 14장에서 mutation 문제를 더욱 자세히 다룰 것입니다.

NOTE 
 defstrcut기능은 Common Lisp에서 object를 만드는 곳에만 사용할 수 있는 툴이 아닙니다. 예를들어, 책의 에필로그에서 여러분은 Common Lisp의 Common Lisp Object System(CLOS)가 매우 정교한 객체-기반 시스템을 만드는 것을 볼 수 있습니다. 만일 여러분이 강건한 객체-지향적 사고방식을 지녔다면, 아마도 필요한 모든 OOP 언어의 기능들을 Common Lisp에서 찾을 것입니다. 실제로, CLOS는 많은 다른 곳에서 발견하지 못한 객체-지향적 기능의 이점을 가지고 있습니다. 이러한 이유로, CLOS는 OOP idea들을 공부하는 연구 도구로 자주 사용됩니다.


Handling Data in a Generic Way

 Common Lisp는 우아하고 효율적인 프로그램을 작성하기 위한 다양한 데이터형식을 지녔습니다. 그러나 주의하지 않으면, 많은 데이터형식을 지닌것은 못생기고 반복되는repetitive code를 야기할 수 있습니다.

 예를들어, list와 array에 저장된 몇몇 수를 더하기 원한다고 가정해봅시다. list와 array의 행동방식이 다르므로, 서로 다른 두가지 -하나는 list다른 하나는 array를 위한- 덧셈 함수를 작성할 필요가 있습니다. 어떤 수가 저장되었는지 신경쓸 필요 없이 두 경우 모두 다룰 단일 code 덩어리를 작성할 수 있으면 좋을 것입니다.

 Common Lisp는 generic library 함수, type predicates, defmethod, 그리고 generic accessor를 포함하여, 여러분이 제네릭 code를 작성할때 필요한 모든 기능을 지녔습니다.  - built-in뿐만아니라 defstruct로 만든 custom types을 포함하여 - 많은 데이터 형식을 다루는 code를 작성하기 위해 여러분의 code에서 불필요한 repetition없이 이 기능들을 사용할 수 있습니다


Working with Sequences

 어떤 type의 인자와도 작동하는 code를 작성하기 가장 쉬운 방법으로는 type-checking 작업을 다른 이에게 넘겨주는 것입니다. Common Lisp 라이브러리들은 인자에 있는 다양한 종류의 data를 제네릭generic하게 다룰 수 있는 함수들로 가득차 있습니다. sequence함수들은 Lisp sequencing objects 세 종류에 대해 generically하게 동작합니다: lists, arrays, and strings.

 여러분은 이미 이러한 sequence function중 하나를 보았습니다: length 함수. 여러분은 세가지 sequence 종류의 길이를 확인하기 위해 length 함수를 사용할 수 있습니다:
[source]

 제네릭 length 함수가 없다면, 여러분은 문자열, 배열, list의 길이를 판별하기 위해 세개의 다른 함수들을 사용해야만 합니다.


NOTE

 Common Lisp는 list의 길이를 확인하는 특별한 함수 list-length를 가졌습니다 왜냐하면 제네릭 함수는 정확한 행동을 결정하기 위해 추가 type-checking이 필요로 하는 경향이 있고, 실행시 느려질 수 있습니다. list-length함수가 성능에 예민한 code에 유용하지만, 대다수의 Lisper들은 regular code에서 제네릭 length 함수를 사용합니다.


Sequence Functions for Searching

 sequence를 뒤지는 몇몇 sequence 함수들:

z find-if predicate를 만족하는 첫번째 값을 찾는다.
z count sequence에 특정 objects의 빈도를 알아낸다.
z position 어떤 항목이 위치한 곳을 알려준다.
z some 과 every sequence에 있는 모든 값이 지정된 predicate를 따르는지 알려준다.

 여기 몇몇 예가 있습니다:

[source]

 이번 예제에서, sequence에서 첫번째 수 5를 찾으려 find-if를 사용했습니다.
"mississippi"에서 문자 s가 얼마나 많이 나오는지 알기 위해 count를 사용했습니다. 문자 4가 보이는 위치를 찾기 위해 position을 사용하였습니다. 이번 경우에, 이것은 영부터 세기 시작하여 다섯 번째 위치에 있습니다. sequence에 있는 어떤 항목에 숫자가 들어있는지 알기위해 some을 사용했습니다. 실제로, 그곳에 숫자가 있었습니다. 마지막으로, list에 있는 모든 항목이 숫자인지 확인하기 위해 every를 사용하였고, 이번에는 아니였습니다.


Sequence Functions for Iterating Across a Sequence

 특별히 유용한 generic sequence함수 중 하나는 reduce입니다. reduce함수는 sequence를 iterate하고 정제distill하여 단일 결과로 내보냅니다. 여기에선, list에 있는 항목들을 모두 더하기 위해 reduce를 사용하였습니다:
[source]

 이 수들의 합은 20으로 밝혀졌습니다. 여기 이번 예제에서 정확히 어떤 일이 벌어졌는지 보여주는 diagram이 있습니다:
[pic]

 회색으로 보이는 오른쪽 부분이 저희 list입니다. 왼쪽부분에서 plus (+) 함수를 체우는 숫자 쌍과 계산되어 나온 중간결과물을 볼수 있습니다. plus함수가 list에 있는 다음 번의 숫자와 같이 하나의 중간 결과물을 인자로 받는다는 것을 보여줍니다. plus 함수를 처음 호출할때 하나의 예외가 있습니다. 처음 plus함수를 호출할때 중간 결과물이 없기 때문에, list의 시작 부분에 있는 3을 뽑아서 중간 결과물로 이동시킵니다. 그러므로, plus함수가 첫번째로 호출되었을때 실제로 list의 상단에 있는 두 항목을 받아옵니다.

 조금 더 복잡한 예제를 살펴보는데, 이번에는 저희만의 reduction함수를 사용하였습니다. list에서 가장 큰 짝수를 찾아낼 것입니다:
[source]

#TODO
 저희 reduction 함수는 두 인자를 받습니다. 첫번째 인자는 지금까지 찾은 best 값입니다 - 다시말해, 지금까지 찾은 가장 큰 짝수. 두번째 인자는 list에서 다음 숫자 입니다. 저희 reduce함수는 결과로 새로운 best 수를 반환합니다. 그러므로 나중 수가 이전 best보다 더 좋다면, 그것을 반환합니다. 반대의 경우, 이전 best를 반환합니다.

 list에 있는 첫번째 수가 starting value로 쓰여진다는 것을 기억하십시오.
 만약 이것이 문제가 된다면, :initial-value란 keyword 인자로 명시적인 초기 값을 넣을 수도 있습니다.

 보통 reduce함수에 초기 값을 지정이 필요하고 그렇지 않으면 bug가 여러분의 code에 기어들어올 수 도 있습니다. 저희 예제에서, list앞에 있는 홀수를 가장 큰 짝수로 잘못 여길 수 도 있습니다 초기 값을 빼먹엇을때 무슨 일이 일어나는지 살펴봅시다.
[source]

 예, 초기 reduce값을 지정하지 않은 결과는 무시무시 합니다.
 
  reduce함수의 또 다른 훌륭한 이점으로는 이것이 generic이라는 것입니다. 리스트, 배열, 혹은 문자열을 같은 방식으로 reduce할 수 있고, 다른 sequence type들의 차이를 인지하지 못하는 함수를 작성하기 위해 reduce를 사용할 수 있습니다.

 일찍이, 제가 리스트나 배열에 있는 수를 더할 수 있는 단일 함수를 편리하게 작성 할 수 있다고 언급드린 적이 있습니다. 이제 그 함수를 작성 할 수 있습니다:
[source]
[pic]

 sum은 무지하여 배열과 리스트의 차이를 인지하지 못합니다; 둘 다 동작합니다. 그러나, 덧셈은 어떠한 문장을 만들지 못하므로,  문자열을 사용했을때 sum함수는 error를 반환합니다.

 sequence를 iterating하기에 유용한 또 다른 함수는 map 함수입니다. 이 함수는 mapcar와 동일하게 행동합니다. 그러나, mapcar와는 달리 map함수는 list뿐만아니라 모든 sequence type에 동작합니다. mapping된것을 반환하기 위해 map함수에 추가 인자를 넣어 sequence의 type을 지정합니다.

 여기 map의 한 예가 있습니다:
[source]

 이번 예제에선, 문자열에 있는 모든 문자을 대문자로 바꿨습니다.

mapping함수는
map에 넣은 것을
단순히 확인합니다
현재 문자가 s라면 대문자 S를 반환합니다
 The mapping function we pass into map simply checks if the current 
character is an s and returns the uppercase S if it is Y.

계산 결과는 문자 list입니다. 

결과로 list를 원했기 때문에
 This is because we 
told the map function that we wanted a list as a result X.

대신 string을
 Had we asked for a 
string instead, a string would have been our result.



Two More Important Sequence Functions


The subseq function lets you pull a subsequence out of a larger sequence by 
specifying starting and ending points:
[source]


As you can see, the word america contains the name eric, starting from 
the second character and ending at the sixth character.

The sort function lets you pass it an arbitrary function to use for the sort-
ing. In this case, we’re just using the less-than (<) function:
[source]

There are many more sequence functions than we’ve discussed so far, 
but the examples in this chapter will get you off to a good start.
NOTE For a comprehensive list of sequence functions, and indeed all Common Lisp functions, 
visit the Common Lisp Hyperspec at http://www.snipurl.com/rz3h0?an 
exhaustive, but daunting, description of all Common Lisp has to offer.
Creating Your Own Generic Functions with Type Predicates
Common Lisp, like virtually all other Lisps, is a dynamically typed language. 
This means that parameters or variables in your code can hold any type of 
data?symbols, strings, numbers, functions, or whatever else you want to place in 
them. In fact, the same parameter or variable can even hold different types 
of data at different times in a running program.
Therefore, it makes sense to have a bunch of functions that tell you whether 
a variable has a certain type of data in it. For instance, you can check whether 
you have a number with numberp:
[source]

The type predicates you will probably use most frequently are arrayp, 
characterp, consp, functionp, hash-table-p, listp, stringp, and symbolp.

You can use type predicates to write functions that handle different types 
of data generically. Suppose we wanted to write a function that lets us add 
both numbers or lists. Here’s one way we could write such a function:

[source]

In this add function, we use predicates to see if the arguments passed in 
are numbers or lists, and then we act appropriately. If we aren’t given two 
numbers or two lists, it simply returns nil.
Although you can write functions supporting multiple types of data using 
type predicates, most Lispers wouldn’t write an add function this way, for the 
following reasons:
A single, monolithic function for all types: This is fine for just two types, 
but if we wanted to handle a dozen or more types, our function would 
quickly turn into a giant monstrosity.
Modifications required to accommodate new cases: We would need to 
change the add function whenever we want to support a new type, 
increasing the chance that we would break existing code. Ideally, we 
would like to handle each new situation by itself without touching 
already working code.
Hard to understand: It is hard to see exactly what the main cond state-
ment is doing and if the types are all being routed to the right place.
Performance: The resulting function might be slow. For instance, a Lisp 
interpreter/compiler might be able to create faster code for appending 
two lists if it knew for sure that both items were lists when the appending 
happens. However, in our first attempt at the add function, the type of 
the two arguments is never really completely obvious. Our compiler would 
need a bit of smarts to be able to tell from the condition (and (listp a) 
(listp b)) that both variables are guaranteed to be lists. Life would be 
easier for the compiler if we explicitly stated the types of arguments for 
each type situation.
Because it is so useful to be able to have a single function that does differ-
ent things when given certain datatypes, the Common Lisp command defmethod 
lets us define multiple versions of a function that each supports different 
types. When that function is called, Lisp checks the argument types at the 

time of the call and chooses the correct version of the function automati-
cally. The proper term for having a compiler/interpreter choose among dif-
ferent versions of a function based on argument types is type dispatching.
Here’s how we would write our add function using defmethod:
[source]

As you can see, this version of the add function handles every type of situ-
ation with a separate function, and new cases can be added without modifying 
existing code. Overall, the code is much easier to understand. Also, the compiler 
can see the type of the parameters and may be able to write faster code using 
this knowledge.
The defmethod function is like defun, except that it allows us to write multiple 
functions with the same name. When using defmethod, we can explicitly state 
the type of each parameter in the function’s argument list so that Lisp can 
use these type declarations to figure out the correct version of add for each 
situation.
If you’re familiar with the world of OOP, the word method probably has a 
special meaning to you. Since this new command is called defmethod, does it 
have anything to do with OOP? In short, yes. This command can be used not 
only with Common Lisp’s built-in types, but also with structures you’ve cre-
ated with defstruct. The combination of defstruct and defmethod basically con-
stitutes a simple object system.
Now we’ll use this object system to write a game!

