9장.진보된 데이터형식과 제네릭 프로그래밍

9.ADVANCED DATATYPES AND GENERIC PROGRAMMING

 봐왔던 것과 같이, Lisp에서  cons cells, symbols, 문자열, 수치 데이터형식으로
수행할 수 있는 많은것들이 있습니다. 매우 성숙한 언어답게, Common Lisp는 이러한 기본적인 것을 뛰어넘을 더 많은 데이터 형식을 포함하고 있습니다. 이번장에서는, 이러한 배열arrays,  해쉬테이블hash tables, 그리고 구조체structures포함해서 진보된 데이터형식의 유용함을 다룰 것입니다.


Arrays

 Common Lisp 배열은 list와 매우 유사합니다. 배열을 사용함으로 얻는 주요 이점은 어떤 특정 지점에 있는 값에 접근하기 위해 상수 시간을 요구한다는 것입니다. 이것이 의미하는 것이 무엇인지 짧게 다룰 것입니다.


Working with Arrays

 새로운 배열을 만들기 위해선 배열의 크기를 지정하여 make-array 명령어를 사용합니다:
[source]

 이것은 길이가 3인 배열을 만듭니다. 만들어진 값이 list가 아니라는 것을 나타내기 위해, Common Lisp는 배열 앞에 해쉬 표시(#)를 답니다.

 배열에 있는 항목을 얻거나 설정하기 위해선 aref함수를 사용합니다. 예를 들어, 여기 index 1에 있는 항목을 어떻게 얻는지 나와 있습니다:
[source]

 물론 지금 당장 배열은 nil로 체워져 있어서, getting 할 가치가 없습니다. 배열에 있는 항목을 더 흥미 있는 값들로 설정하기 위해, setf 명령어와 함께 aref를 사용합니다:
[source]

 aref가 보통 배열에서 값을 얻는데 사용되지만, 이 예제에서 나타난 특별한 방법으로 사용될 때에는 배열의 값을 설정합니다. setf와 aref 명령어를 같이 사용하는 능력은 Common Lisp의 능력을 보여줍니다: generic programming을 지원합니다. 어떻게 이 기능이 동작하는지 더 배우기 위해 setf명령어를 자세히 살펴봅시다.


Using a Generic Setter

 Common Lisp 언어는 generic setter를 지원한다고 말합니다. 대부분 이것이 의미하는 것은 데이터 구조(배열, 리스트, 문자열, 혹은 다른 것)에서 값을 빼내오는 code가 동일한 데이터 구조에 data를 집어 넣는 code와 동일하다는 것입니다. setf명령어는 getting 연산을 하는 함수와 결합하여 사용할 수 있고, setting 연산을 하는 함수와도 사용할 수 있습니다.

 이미 저희는 aref를 배열에서 값을 얻을 때 사용할 수 있다는 것을 보았고, setf와 사용하여 배열의 값을 setting시 사용할 수 있다는 것을 보았습니다. data 구조로부터 항목을 얻는 대다수의 Common Lisp의 명령어에서, setf명령어는 generic 방식으로 이 trick을 수행할 수 있습니다. 예를 들어
, list와 연관된 다음 예제를 봅시다:
[source]

 기대했던 것과 같이 표현식 (second foo)는 B를 반환합니다. 그러나 setf명령어에 (second foo)를 통과시켰을 때, 이것은 B가 어디서 왔는지 알고 표현식 (second foo)를 regular 변수인 것처럼 다룰 수 있습니다. 기본적으로, setf명령어는 자기 자신에게 질문합니다 "첫 번째 인자에 있는 항목이 본디 어디서 왔을까?" 이번 경우에, 값은 foo라는 이름의 list의 두 번째 항목에서 왔습니다. 그러므로, 이 지점에서 setf를 시도한다면 원본 변수 foo는 반응하여 수정됩니다.

 사실 setf의 첫번째 인자는 generalized reference라고 불리는 Common Lisp의 특별한 sublanguage입니다. 모든 Lisp 명령어가 generalized reference를 허용하는 것은 아니지만, 몇몇 복잡한 것에는 넣을 수 있습니다.

[source]

 이번 예제는 Common Lisp에서 setf의 진정한 힘을 보여줍니다. 첫번째 사용한 것에서, list (x y z) 를 배열의 세번째 항목으로 넣었습니다. 만일 지금 foo를 출력한다면, 이것이 동작한 것을 볼 수 있습니다. 두번째로 사용한 것에서, foo 배열에 있는 이 list의 첫번째 항목을 해쉬 테이블로 바꾸었습니다. 해쉬 테이블 은 157쪽에서 짧게 배울 또 다른 진보된 data 형식입니다. setf로 이 일을 하는 것은 놀랄 만큼 쉬운데, setf의 첫번째 인자에 있는 generalized reference는 임의로 복잡해질 수 있기 때문입니다.

 마지막으로, 해쉬 테이블안에 key는 zoink로 하여 값 5를 삽입하였습니다. gethash함수는 해쉬 테이블 밖으로 값을 얻어오도록 합니다. 대신 여기서는 setf의 도움으로 해시 테이블에 숫자 5를 넣었습니다.

 이번 예제로부터 프로그램에서 복잡한 data 구조를 수정할때 setf가 유용할 수 있다는 것을 인지하길 바랍니다.

 setf의 또 다른 멋진 기능은 값에 접근하는 새로운 방식을 지원하도록 generalized reference 문법을 확장 시킬 수 있다는 것입니다. setf는 내포된 단계(level of nesting)나 쓰여진 데이터형식에 구애받지 않고 값을 수정하는 진정한 generic 방식입니다.


Arrays vs. Lists

 이제 여러분은 Lisp에서 배열이 동작하는 기본 예제를 살펴보았습니다. 그러나 배열의 이점을 완전히 이해하기 위해, list와 비교해볼 필요가 있습니다.

 list로 할 수 있는 대부분의 것들은 배열로도 할 수 있습니다. 그러나, 일반적으로 배열은 특정 원소에 접근할때 list보다 빨라서 성능면에서는 다릅니다.

 예를들어 array-handling함수 aref는, 배열을 사용하지 않고 regular list의 특정 지점에 있는 항목에 접근하는 nth라 불리는 list-handling함수와 매우 유사흡니다. 여기 list에 nth를 사용하는 예제가 있습니다:
[source]

 그러나, 매우 작은 list에만 nth 함수를 사용하는게 이치에 맞습니다. 예를들어, list X가 수천개의 항목을 가졌고 (nth 1000 x)명령어를 실행하면 정말로 느릴것인데, Lisp list는 cons cells의 chain으로 만들어 졌기 때문입니다. Lisp에서 list에 있는 수천개의 항목을 찾을 수 있는 유일한 방법은 999개의 object를 먼저 휘졋고 다니는 것입니다.

 대조적으로, 큰 배열에서 (aref x 1000)명령어를 수행하는것은 이전 999항목을 거쳐 세는것 없이 천번째 항목을 직접 접근합니다. 이것이 의미하는 것은 큰 배열에서의 aref는 큰 list에서의 nth명령어보다 더욱 빠르게 수행될 것이라는 것입니다. 10억개의 항목을 가진 배열이 있을지라도, 마지막 항목을 검색하는 것은 여전히 매우 빠를것입니다. 실제 제한하는 요소는 오직 여러분의 시스템 뿐입니다: 여러분의 컴퓨터의 RAM용량과 이것을 이용하는 Lisp 환경의 저장 방식.
[pic]

 배열 값에 빠르게 접근할 수 있을 뿐만아니라, 일반적으로 특정 장소에 있는 값을 list로 같은 작업을 하는 것보다 빠르게 바꿀 수 있습니다.

 큰 data 구조에서 특정 값을 설정setting하거나 얻는getting 것은 매우 중요하므로, 배열을 여러분의 코드에서 가능한 최적의 성능을 얻도록 여러분을 도와줄 수 있는 도구라고 명심하시기 바랍니다.


Hash Tables

 배열이 list과 비슷하듯이, 임의의 요소에 빠르게 접근한다는 점을 제외한다면 해쉬 테이블은 alist와 비슷합니다.

 사실, 해쉬 테이블은 때때로 마법처럼 보여질 정도로 매우 효율적입니다. 은하수를 여행하는 히치하이커를 위한 안내서의 Babel fish을 떠올려봅시다- 실제로는 존재하지 않지만 매우 놀랄만한게 유용한 것. 이것이 대다수의 모든 현대 언어들이 이제 해쉬 테이블 데이터형식을 제공하는지에 대한 이유입니다.
[pic]


Working with Hash Tables

 make-hash-table명령어로 새로운 해쉬 태이블을 만듭니다:
[source]

 alist와 같이 해쉬 테이블은 lookup key와 value를 이용하여 항목을 저장합니다. 항목의 key와 gethash 함수를 사용하여 해쉬 테이블로부터 하나의 항목을 받을 수 있습니다:
[source]

 아직까진 해쉬 테이블은 비어있습니다. 이것이 의미하는 것은 해쉬 테이블에서 어떤 key를 살펴볼때, 이번 예제에서 'yup의 대답으로 NIL을 받는다는 것입니다. 실제로, 저희는 두개의 NIL을 받았습니다 - gethash 명령어는 Common Lisp에서 여러개의 값을 반환합니다(다음 section에서 다룰것입니다). 반환된 첫번째 값은 해쉬 테이블에 저장된 실제 값이며, 두번째는 테이블에서 key를 찾았는지를 나타냅니다(이번 경우에는 없습니다).

 배열로 했을때처럼, 여러분은 data로 테이블을 체우는 대신에 setf명령어와 data 요소를 참조하는데 사용하는 명령어를 조합할 수 있습니다 - 이번 경우에는 gethash:
[source]

 이번 예제에서, yup을 lookup key로써 해쉬 테이블에 값 25를 저장했습니다. 그 다음, 테이블에서 yup을 살펴보면, 25라는 답을 얻게 됩니다. 또한 t라는 두번째 값을얻는데 이것이 의미하는 것은 "예, 저는 테이블에서 key를 찾았습니다" 입니다.

 alist를 다루었을때, coffee 음료 주문을 포함하는 data 구조를 설정했던것이 기억나십니까? 여기 동일한 data가 있으며, 이번에는 해쉬 테이블을 사용하여 저장됩니다:
[source]

 누군가의 음료 주문을 살펴보는게 이제 간단해졌습니다:
[source]


Returning Multiple Values

 Common Lisp는 결과로 하나의 값보다 더 많이 반환하는 것을 허용합니다. 저희가 봐왔던것 처럼 gethash함수를 포함하여 Common Lisp의 몇몇 core 함수는 이러한 일을 합니다. 또 다른 일반적으로 사용되는 함수는 수를 반올림하는 round 함수입니다:
[source]

 이 함수를 호출하면 수를 알맞게 2로 반올림하면서, 반올림 연산의 나머지인 두번째 값도 생성합니다. 이 함수 호출에서 두 값이 반환됩니다.

 또한 code에서 values함수를 사용해서 다수의 값들을 생성할 수 있습니다. 예를들어, 여기서 여러분은 3과 7를 반환하는 foo라는 함수를 작성할 수 있습니다:
[source]

 round 함수와 마찬가지로 이 값들은 모두 REPL에서 출력됩니다. 그러나, Lisp는 첫번째 값을 더욱 중요하게 여기며, 후속 계산동안 항상 기본으로 사용될 것입니다. 예를들어, foo함수를 호출한 뒤 이와 같이 추가 작업을 수행할 수 있습니다:
[source]

 이번 경우에, 추가 연산은 foo가 반환한 두번째 값을 무시합니다.

 그러나, 때때로 추가적인 반환 값을 사용해야 할 필요가 있습니다. multiple-value-bind명령어를 사용하여 이러한 일을 할 수 있습니다:
[source]

 이번 예제에서, a와 b 변수를 foo에 의해 반환된 값 (3 과 7)로 묶었습니다. multiple-value-bind와 함께 함수를 호출하여, 다른 경우에는 무시되어지는 함수로부터 반환된 추가 값들을 사용하도록 합니다.

 여러분은 multiple-value기능을 사용하는 대신에 함수로부터 list를 반환 할 수 있는지 궁금해할 지도 모릅니다. 정답은 "할 수 있다" 입니다. 그러나 mutiple-value기능을 사용하면 더욱 최적화되고 깔끔한 code를 이끌어내는 것이 가능합니다

 이 책에서는, multiple values를 사용이 많지 않을 것입니다. 사실, Arc나 Clojure와 같은 최근 Lisp방언들은 multiple 값을 전혀 지원하지 않습니다. 대신에, 하나의 값보다 많이 반환될 필요가 있을 경우에 list를 반환합니다.


Hash Table Performance

 배열처럼, 해쉬 테이블이 얼마나 많은 항목들을 갖고 있던지 간에 해쉬 테이블 안에 있는 값의 접근과 수정은 상수 시간을 요구합니다. 예를 들어, 해쉬 테이블이 10개의 항목을 가지고 있다고 가정해 봅시다. key를 사용하여 테이블에서 값을 접근하고 이것을 찾아내는데 걸린 시간은 평균 0.001초가 걸립니다. 이제 해쉬 테이블이 1,000,000 항목을 가졌다고 가정해봅시다. (해쉬 테이블이 그렇게 설계되었기 때문에) 값을 받는데 여전히 0.001초가 걸릴 것이라고 예상할 수 있습니다. 다시말하자면, 테이블이 얼마나 크든지간에, 0.001초라는 상수 시간에 항목에 접근 할 수 있습니다.

 어떻게 엄청난 이 일이 가능한지 생각해 보십시요! 해쉬 테이블이 1,000,000개의 항목을 포함할지라도, gethash함수는 key를 취하여 상수 시간안에 여러분이 원하는 항목을 찾을수 있는 곳을 정확히 결정할 수 있습니다!

 어마어마한 양의 data를 뒤로하는 web-based 프로그램의 시대에서, 많은 양의 값들을 저장하고 빠르게 반환하는 해쉬 테이블의 능력은 필수입니다. key/value의 쌍으로 저장하는 효율성은 대다수의 온라인 저장 시스템에서 필수입니다. 구글의 BigTable이나 아마존의 S3와 같은 막대한 양의 온라인 데이터를 저장하는 최근 tool이라도, 해쉬 테이블과 유사하게 만들어 키를 사용함으로써 값을 재빨리 받아오도록 만들어졌습니다

 그러나, 여러분은 항상 해쉬 테이블이 최고의 성능을 제공한다고 단언 할 수 는 없습니다. 여기에 왜 그런지에 대해 나와 있습니다:

가상 메모리 패이징virtual memory paging과  cache misses:
 배열과 마찬가지로, 큰 해쉬 테이블은 여러분의 운영체제로 하여금 하드 드라이브의 가상 메모리 패이징을 유발시킵니다. 따라서 성능이 줄어들게 됩니다. 유사하게, CPU cache missed의 수도 증가 할 수 있습니다.

해쉬 충돌:
 내부적으로 해쉬 테이블은 key를 number로 변환시키는 hash함수라 불리는 특별한 함수를 사용합니다. 이와 같은 해쉬 함수는 해쉬 충돌을 유발시킵니다. 본질적으로 해쉬 충돌은 우연히 두키가 hash함수에 의해 같은 수로 변환될때 일어납니다. 이 경우에 미세한 성능 감소가 있을지라도 해쉬 테이블은 여전히 정확하게 행동합니다. 드믄 경우에, 특정 종류의 key가 충돌 횟수를 증가시키도록 hash 함수에 영향을 미칠 수가 있고 어플리케이션의 찾는 능력을 지연시켜 성능은 더욱 더 감소하게 됩니다.

작은 테이블의 비효율성:
 매우 작은 테이블에서 해쉬 테이블이 요구하는 생성과 찾는 시간은 alist와 같은 간단한 구조보다 비효율적입니다. 해쉬 테이블의 성능 이점은 data양이 큰 경우에만 두드려집니다.


변하는 연산 속도:
 만약 여러분이 Common Lisp에서 작은 해쉬 테이블을 만들고 값으로 체워넣다보면 새로운 값을 추가하는 것이 때때로 비정상적으로 느리다는 것을 발견할 것입니다. make-hash-table함수가 작은 해쉬 테이블을 만드는 비용을 최소화하게 설계되었기 때문입니다. 그러나 테이블을 크게 만드는 값을 추가하기 시작한다면 Lisp는 더 많은 메모리를 할당하기위해 여분의 시간을 요구하며, 테이블은 더 많은 항목을 담을 수 있게 됩니다. 이러한 추가 할당은 테이블이 자라면서 종종 느린 삽입을 야기시킵니다.

해쉬 테이블이 항상 최선의 해결책이 아닌 마지막 이유:
 cons cells로부터 세워진 전통적인 Lisp 구조만큼 Lispy하지 않습니다. 이것이 의미하는 것은 Lisp REPL에서 자연스럽게 출력되거나 읽을 수 없기 때문에 디버그하기에 cons cells보다 어렵다는 것입니다. 그러므로, 좋은 rule of thumbs는 배열과 해쉬 테이블을 새로운 code조각으로써 염두에 두고 멀어지는 것입니다. 그리고 만약 성능이 이슈로 떠올랐을때, 어떤 성능 문제를 해결하기 위해 배열과 해쉬 테이블의 이점을 얻을 수 있는, 여러분의 code의 critical section을 신중하게 수정합시다.


A Faster Grand Theft Wumpus Using Hash Tables

 해쉬 테이블이 여러분의 code를 위해 무엇을 할 수 있는지 연습 문제를 살펴봅시다. 최근 게임 Grand Theft Wumpus에서 눈에띄는 비효율적인게 있었는데, 이제 그것을 해쉬 테이블로써 바로잡을 수 있습니다.

 Grand Theft Wumpus에서 도시 graph를 표현하기 위해 nodes와 edges의 list를 사용한 이전 장을 회상해봅시다. 주어진 node로 찾는 것 대신에, list를 통해 선형적으로 찾아야 합니다. Congestion City는 많은 교차로를 가지고 있지 않기 때문에, Grand Theft Wumpus에서 큰 작업을 요구하지 않습니다. 그러나 도시가 천개의 node와 천개의 edge를 가진다면 어떨까요? get-commected 함수를 보고 어느 정도의 수치를 얻는지 봅시다:
[source]

 time명령어는 code 덩어리에 관한 모든 종류의 유용한 시간 정보를 출력하는 Lisp의 utility이며, dotimes함수는 code를 100번 수행하게 하고, 100개의 도시를 건설합니다. 이 명령을 사용해서 제 컴퓨터에서 이 code를 돌렸을때 일분 정도 걸렸습니다. CPU가 일분동안 처리할수 있는 엄청난 수의 instruction이 주어졌고, 이것은 명백하게 끔찍한 성능을 나타냅니다.

 이 문제를 해결하기 위해, edge list를 해쉬 테이블로 변경하고, 따라서 get-conncted함수는 상수 시간에 연결을 찾을 수 있을 것입니다. 또한 방문했던 list를 방문했던 table로 교체할 것이며, 따라서 함수는 빠르게 어떤 node가 이미 방문했는지 답할 수 있을 것입니다.

 여기 이것을 수행하는 해쉬화된 버전으로 구성된 코드가 있습니다:
[source]

 우선, edge list를 해쉬 테이블로 변환시키는 hash-edges함수가 필요합니다. 함수의 시작 부분에서, tab이라는 새로운 해쉬 태이블을 만들었습니다. 그 다음, mapc로 테이블을 iterate합니다. side effect에 관해 주의해야 하거나 결과로 최종 list를 생성하는 것에 신경쓰지 않는 곳에 사용한다는 점을 제외하고, mapc는 mapcar와 같다는 것을 기억하시기 바랍니다.

 모든 node들에 대해 저희는 이것과 연결된 node들의 list를 포함할 table을 원합니다. 그러므로, list를 iterate하면서 starting node를 위해 neighbors의 list에 새로운 neighbor를 push합니다. regular Lisp 변수값처럼 해쉬 테이블 값에 push명령어를 사용할 수 있습니다. 다시 말해서 이것은, 166쪽 "Handling Data in a Generic Way" 에서 다룰, Common Lisp에서 만들어진 general 변수 시스템을 사용합니다.

 테이블에 있는 node의 값이 없는 경우를, 처리할 필요가 없어 혼란스러울지도 모릅니다. 어떻게 값이 존재하지 않는데 테이블에 무언가를 push할 수 있을까요? 테이블에서 key를 찾을 수 없을때 gethash함수는 NIL을 반환하기 때문에, 이 code는 단순히 새로운 neghbor를 empty list에 push하고 이전에 none을 찾았던 테이블에 새로운 기록을 집어넣습니다. 이리하여, push명령어는 node가 새것이거나 이전것이든 상관치않고 마법과도 같이 "정확한 일"을 수행합니다.

 마지막으로, 테이블이 가득차면 이것을 결과로 반환합니다. 이것은 원래 edge list와 같은 data를 포함하고 있습니다. 다른점은 Congestion City안의 어떤 node의 neighbors를 광속으로 찾을 수 있습니다.
[source]

 이제 저희는 Congestion City에서 시작 node에 연결된 모든 node들을 되돌려받을 get-connected-hash를 작성할 준비가 되었습니다. 이것은 get-connected와 행하는 것은 동일하지만, 해쉬 테이블을 통해 최적화 되었습니다.

 이 함수가 하는 첫번째 일은 방문했던 node들의 해쉬 테이블을 만드는 것입니다. 그 다음 starting node로부터 출발해서 Congestion City의 node들을 이동합니다. 새로운 node를 방문할 때마다, 이전에 방문했었는지 스스로 물어봅니다. 이제 저희는 방문했던 테이블에 있는 현재 node를 살펴봄으로써 이 질문에 매우 효율적으로 대답할 수 있습니다. 만일 아니라면, 이 노드를 방문했다고 표시할 필요가 있고 mapc로 이것의 모든 neighbors를 확인해야합니다 - edge table을 확인. 마지막으로, starting node와 연결된 모든 node들을 담고있을 방문했던 table을 반환합니다.

 이제 저희는 새로운 로직으로 다시 테스트할 수 있습니다:
[source]

 보시다시피, graph의 연결을 계산하는데 일분 정도 걸렸던데 반해, 이제는 같은 일을 하는데 단지 일초정도 빢에 걸리지 않습니다!

 이것이 해쉬 테이블의 사용법을 알고 있어야 하는 이유입니다.


Common Lisp Structures

 structure는 Common Lisp에서 사용가능한 진보된 데이터형식입니다. structure와 속성property은 여러분의 code에서 data를 표현할 유용한 방법이 될 수 있습니다.

Working with Structures

 Structure는 이와 같이 defstruct 명령어를 사용하여, 전통적인 객체-지향 프로그래밍(OOP) 언어에서 찾을 수 있는 것처럼 객체objects와 속성properties을 나타내는데 이용할 수 있습니다:
[source]

 이 structure의 정의를 따르자면, person은 네가지 속성을 가집니다(Lisper들이 slots이라고 부르는): name, age, waist-size, 그리고 favorite-color.

 이 structure를 정의하면, person대신에 defstruct가 자동적으로 생성한 특별한 함수 make-person명령어를 사용하여 생성할 수 있습니다:
[source]

 이제 *bob*을 REPL에 입력하면, structure 접두사 #S가 표기된 새로운 person을 보게될 것입니다. 저희는 또한 structure가 person 형식이라는 것과 이것의 각 속성(name, age, waist-size, 그리고 favorite-color)의 값을 알 수 있습니다:
[source]

 또 다른 자동적으로 생성된 person-age함수를 호출함으로써 Bob의 나이를 알 수 있습니다:
[source]

 우리는 또한 setf와 이 명령어를 사용하여 Bob의 나이를 바꿀 수 있습니다.(생일 축하해, Bob!)
[source]

 Lisp의 print/read symmetry에 대한 또 다른 좋은 예제로, Lisp reader는 또한 출력된 person의 모습으로부터 person을 직접 생성할 수 도 있습니다:
[source]

 여기서 새로운 변수 *that-guy*를 만들고, 출력된 person의 모습만을 이용하여 이 값을 설정하였습니다. 이 변수는 이제 make-person함수를 사용한것 처럼 실제 person structure를 가지게 되었습니다.

 보시다시피, defstruct는 특별한 함수를 만드는데 사용할 수 있고, 새로운 object를 생성하고 속성에 접근하기 쉽게 만들어주는 매우 강력한 명령어 입니다.


When to Use Structures

 오늘날, 많은 mainstream 프로그래머들은 크고 견고한 어플리케이션을 개발할때 객체 지향이 필수라고 믿고 있습니다. 반면, 많은 Lisper들은 purely OOP 접근없이 고품질의 소프트웨어를 만드는 것이 가능하다고 믿고 있습니다.

 14장 시작부분에서, 고-수준 함수형 프로그래밍과 domain-specific 언어 프로그래밍을 포함하여 이러한 접근 방식을 보여줄 것입니다. Lisp언어의 설계는 다른 가능한 더욱 객체-지향적 언어보다 이러한 대안 접근을 이용하기가 쉽게 만듭니다.

 비록 여러분이 purely OOP-style 소프트웨어를 작성하지 않을지라도, structure와 properties는 여전히 여러분의 code에서 data를 표현할 유용할 방법입니다. 예를들어, defstruct로 person class를 생성하는 대신에, 표준 list와 여러분만의 make-person함수로도 이와 동일한 일을 할 수 있습니다. 그렇다면, 이와 같이 list를 사용하여 person기능 할 수 있는데, 왜 structures에 애를 쓸까요?
[source]

 비록 이런 접근방식이 통할지라도, 나쁜 점이 있습니다. 우선 person의 age나 다른 properties를 확인하기 위해 정확한 위치에서 properties를 빼내는 많은 수의 error-prone 함수를 많이 작성해야만 할것입니다. 또한, 출력된 ad hoc object버전은 매우 이해하기 어렵습니다. BOB이 person이라는 것을 알겠습니까? Bob의 나이는 35살입니까 아니면 32살입니까? regular 리스트는 object와 다수의 property를 인코딩하기에 적합하지 않습니다.

 실제 사회에서 list를 사용하여 object를 표현하는데 또 다른 문제로는 object의 property는 시간의 흘러 변화될 수 있다는 것입니다(person object와 같이). Lisp에서 list는 생성됬을때부터 변하지 않는 정보를 다룰때 제대로 동작합니다. 그러나 Bob이 36살이 되었을때, 그의 age property를 바꿔야됩니다.

 structure의 data부분이 시간 지남에 따라 바뀌는 것을 computer scientist들은 mutation이라 부릅니다. defstruct에 의해 만들어진 structure에 있는 특정 property(변하는 property)의 값을 쉽게 바꿀수 있어서, 변화하는 data를 다루기에 매우 적합합니다. 그러므로 person(혹은 시간이 지남에 변하는 object)을 structure에 저장하는게 이치에 맞습니다. 저희는 14장에서 mutation 문제를 더욱 자세히 다룰 것입니다.

NOTE 
 defstrcut기능은 Common Lisp에서 object를 만드는 곳에만 사용할 수 있는 툴이 아닙니다. 예를들어, 책의 에필로그에서 여러분은 Common Lisp의 Common Lisp Object System(CLOS)가 매우 정교한 객체-기반 시스템을 만드는 것을 볼 수 있습니다. 만일 여러분이 강건한 객체-지향적 사고방식을 지녔다면, 아마도 필요한 모든 OOP 언어의 기능들을 Common Lisp에서 찾을 것입니다. 실제로, CLOS는 많은 다른 곳에서 발견하지 못한 객체-지향적 기능의 이점을 가지고 있습니다. 이러한 이유로, CLOS는 OOP idea들을 공부하는 연구 도구로 자주 사용됩니다.


Handling Data in a Generic Way

 Common Lisp는 우아하고 효율적인 프로그램을 작성하기 위한 다양한 데이터형식을 지녔습니다. 그러나 주의하지 않으면, 많은 데이터형식을 지닌것은 못생기고 중복되는 code를 야기할 수 있습니다.

 예를들어, list와 array에 저장된 몇몇 수를 더하기 원한다고 가정해봅시다. list와 array의 행동방식이 다르므로, 서로 다른 두가지 -하나는 list다른 하나는 array를 위한- 덧셈 함수를 작성할 필요가 있습니다. 어떤 수가 저장되었는지 신경쓸 필요 없이 두 경우 모두 다룰 단일 code 덩어리를 작성할 수 있으면 좋을 것입니다.

 Common Lisp는 generic library 함수, type predicates, defmethod, 그리고 generic accessor를 포함하여, 여러분이 generic code를 작성할때 필요한 모든 기능을 지녔습니다.  - built-in뿐만아니라 defstruct로 만든 custom types을 포함하여 - 많은 데이터 형식을 다루는 code를 작성하기 위해 여러분의 code에서 불필요한 중복됨이 없이 이 기능들을 사용할 수 있습니다


Working with Sequences

 어떤 type의 인자와도 작동하는 code를 작성하기 가장 쉬운 방법으로는 type-checking 작업을 다른 이에게 넘겨주는 것입니다. Common Lisp 라이브러리들은 인자에 있는 다양한 종류의 data를 generic하게 다룰 수 있는 함수들로 가득차 있습니다. sequence함수들은 Lisp sequencing objects 세 종류에 대해 generically하게 동작합니다: lists, arrays, 그리고 strings.

 여러분은 이미 이러한 sequence function중 하나를 보았습니다: length 함수. 여러분은 세가지 sequence 종류의 길이를 확인하기 위해 length 함수를 사용할 수 있습니다:
[source]

 generic length 함수가 없다면, 여러분은 문자열, 배열, list의 길이를 판별하기 위해 세개의 다른 함수들을 사용해야만 합니다.


NOTE
 Common Lisp는 list의 길이를 확인하는 특별한 함수 list-length를 가졌습니다 왜냐하면 제네릭 함수는 정확한 행동을 결정하기 위해 추가 type-checking이 필요로 하는 경향이 있고, 실행시 느려질 수 있습니다. list-length함수가 성능에 예민한 code에 유용하지만, 대다수의 Lisper들은 regular code에서 제네릭 length 함수를 사용합니다.


Sequence Functions for Searching

 sequence를 뒤지는 몇몇 sequence 함수들:

z find-if predicate를 만족하는 첫번째 값을 찾는다.
z count sequence에 특정 objects의 빈도를 알아낸다.
z position 어떤 항목이 위치한 곳을 알려준다.
z some 과 every sequence에 있는 모든 값이 지정된 predicate를 따르는지 알려준다.

 여기 몇몇 예가 있습니다:

[source]

 이번 예제에서, sequence에서 첫번째 수 5를 찾으려 find-if를 사용했습니다.
"mississippi"에서 문자 s가 얼마나 많이 나오는지 알기 위해 count를 사용했습니다. 문자 4가 보이는 위치를 찾기 위해 position을 사용하였습니다. 이번 경우에, 이것은 영부터 세기 시작하여 다섯 번째 위치에 있습니다. sequence에 있는 어떤 항목에 숫자가 들어있는지 알기위해 some을 사용했습니다. 실제로, 그곳에 숫자가 있었습니다. 마지막으로, list에 있는 모든 항목이 숫자인지 확인하기 위해 every를 사용하였고, 이번에는 아니였습니다.


Sequence Functions for Iterating Across a Sequence

 특별히 유용한 generic sequence함수 중 하나는 reduce입니다. reduce함수는 sequence를 iterate하고 정제distill하여 단일 결과로 내보냅니다. 여기에선, list에 있는 항목들을 모두 더하기 위해 reduce를 사용하였습니다:
[source]


 이 수들의 합은 20으로 밝혀졌습니다. 여기 이번 예제에서 정확히 어떤 일이 벌어졌는지 보여주는 도해(圖解, diagram)가 있습니다:
[pic]

 회색으로 보이는 오른쪽 부분이 저희 list입니다. 왼쪽부분에서 plus (+) 함수를 채우는 숫자 쌍과 계산되어 나온 중간결과물을 볼수 있습니다. plus함수가 list에 있는 다음 번의 숫자와 같이 하나의 중간 결과물을 인자로 받는다는 것을 보여줍니다. plus 함수를 처음 호출할때 하나의 예외가 있습니다. 처음 plus함수를 호출할때 중간 결과물이 없기 때문에, list의 시작 부분에 있는 3을 뽑아서 중간 결과물로 이동시킵니다. 그러므로, plus함수가 첫번째로 호출되었을때 실제로 list의 상단에 있는 두 항목을 받아옵니다.

 조금 더 복잡한 예제를 살펴보는데, 이번에는 저희만의 reduction함수를 사용하였습니다. list에서 가장 큰 짝수를 찾아낼 것입니다:
[source]

 저희 reduction 함수는 두 인자를 받습니다. 첫번째 인자는 지금까지 찾은 best 값입니다 - 다시말해, 지금까지 찾은 가장 큰 짝수. 두번째 인자는 list에서 다음 숫자 입니다. 저희 reduce함수는 결과로 새로운 best 수를 반환합니다. 그러므로 나중 수가 이전 best보다 더 좋다면, 그것을 반환합니다. 반대의 경우, 이전 best를 반환합니다.

 list에 있는 첫번째 수가 starting value로 쓰여진다는 것을 기억하십시오.
 만약 이것이 문제가 된다면, :initial-value란 keyword 인자로 명시적인 초기 값을 넣을 수도 있습니다.

 보통 reduce함수에 초기 값 지정이 필수적이며, 그렇지 않으면 bug가 여러분의 code에 기어들어올 수 도 있습니다. 저희 예제에서, list앞에 있는 홀수를 가장 큰 짝수로 잘못 여길수도 있습니다 초기 값을 빼먹엇을때 무슨 일이 일어나는지 살펴봅시다.
[source]

 예, 초기 reduce값을 지정하지 않은 결과는 무시무시 합니다.
 
  reduce함수의 또 다른 훌륭한 이점으로는 이것이 generic이라는 것입니다. 리스트, 배열, 혹은 문자열을 같은 방식으로 reduce할 수 있고, 다른 sequence type들의 차이를 인지하지 못하는 함수를 작성하기 위해 reduce를 사용할 수 있습니다.

 일찍이, 제가 리스트나 배열에 있는 수를 더할 수 있는 단일 함수를 편리하게 작성 할 수 있다고 언급드린 적이 있습니다. 이제 그 함수를 작성 할 수 있습니다:
[source]
[pic]

 sum은 무지하여 배열과 리스트의 차이를 인지하지 못합니다; 둘 다 동작합니다. 그러나, 덧셈은 어떠한 문장을 만들지 못하므로,  문자열을 사용했을때 sum함수는 error를 반환합니다.

 sequence를 iterating하기에 유용한 또 다른 함수는 map 함수입니다. 이 함수는 mapcar와 동일하게 행동합니다. 그러나, mapcar와는 달리 map함수는 list뿐만아니라 모든 sequence type에 동작합니다. mapping된것을 반환하기 위해 map함수에 추가 인자를 넣어 sequence의 type을 지정합니다.

 여기 map의 한 예가 있습니다:
[source]

 이번 예제에선, 문자열에 있는 모든 문자을 대문자로 바꿨습니다.
 mapping함수는 단순히 현재 문자 s를 확인하여 맞다면 대문자 S를 반환합니다

 계산 결과는 문자 list입니다. map함수에게 결과로 list를 원한다고 말했기 때문입니다. string을 원한다 했다면, string을 결과로 얻었을것입니다.


Two More Important Sequence Functions

 subseq 함수는 시작과 끝을 지정하여 보다 큰 sequence에서 subsequence를 뽑아옵니다:
[source]

 보시다시피, america단어는 두번째부터 여섯번째 문자로 eric을 포함하고 있습니다.

 sort함수는 정렬하기 위해 이것을 임의적인 함수에 통과시킵니다. 이번 경우에는, less-than (<)함수를 사용하였습니다:
[source]


 저희가 다루었던 것보다 더 많은 sequence 함수가 있지만, 이 예제가 좋은 시작점이 될 것입니다.

NOTE
 포괄적인 sequence 함수 리스트과 실제 전체 Common Lisp 함수들을 원한다면, Common Lisp가 제공하는 완벽하지만 위압적인 설명을 제공하는 Comon Lisp Hyperspec  http://www.snipurl.com/rz3h0?an 을 방문하시기 바랍니다.


Creating Your Own Generic Functions with Type Predicates

 다른 Lisp들과 같이 Common Lisp는 동적 타입 언어입니다. 이것은 code에 있는 인자 혹은 변수에 어떤 data타입 이라도 넣을 수 있다는 것을 의미합니다 - 심볼, 문자열, 숫자, 함수들, 혹은 여러분이 그곳에 넣기 원하는 무언가. 사실, 같은 인자 혹은 변수는 프로그램이 동작중에 매번 다른 데이터타입을 받을 수 있습니다

 그러므로, 변수가 어떤 data의 종류를 지녔는지 알려주는 bunch of function를 가져야합니다. 예를 들어, numberp로 숫자를 가졌는지 확인할 수 있습니다:
[source]

아마도 여러분이 가장 많이 사용하게 될 type predicate들은 arrayp, characterp, consp, functionp, hash-table-p, lispp, stringp, 그리고 symbolp일 것입니다..

 다른 data타입을 generically하게 다루는 함수를 작성하기 위해 type predicate를 사용할 수 있습니다. 숫자나 리스트를 더하는 함수를 작성하기 원한다고 가정해봅시다. 여기 그와 같은 함수를 작성한 방법이 나와있습니다:
[source]

 add 함수에서 인자로 들어온것이 숫자인지 리스트인지 확인하기 위해 predicate를 사용하였고, 적절하게 행동하였습니다. 만약 두개의 숫자나 두개의 리스트가 아니라면, 단순히 nil을 리턴할 것입니다.

 비록 다양한 data타입을 지원하는 함수를 작성할 수 있을지라도, 대다수의 Lisper들은 다음과 같은 이유로 인해 이러한 방식으로 add함수를 작성하지 않습니다:


모든 타입을 위한 덩어리 함수:
 단지 두 종류라면 괜찮지만, 만일 열 두개 혹은 더 많은 종류를 다루기 원한다면 함수는 거대한 괴물로 변하고 말것입니다.

새로운 경우를 추가하기 위한 수정:
 새로운 타입을 지원하도록 add함수를 바꿔야 한다면, 기존에 있던 code를 망칠 경우의 수도 증가하게 됩니다. 이상적인것은 이미 작업한 code를 건들지 않고 각각의 새로운 상황을 다루도록 하는 것입니다.

이해하기에 여려움:
 main cond statement가 무얼하는지 이 타입에 맞게 가는 것인지 정확히 이해하는데 어렵습니다.

성능:
 함수의 결과는 느릴 것입니다. 예를들어, Lisp 인터프리터/컴파일러는 appending이 일어날때 두 항목이 list라는것을 이미 안다면 두 list를 빠르게 appending하는 더 빠른 code를 생성할 수 있습니다. 그러나 add함수에 첫번째 시도에서 두 인자의 타입은 다릅니다. 두 변수가 list라는 것을 (and (listp a) (listp b)) 조건으로부터 알기 위해서는 컴파일러가 좀 더 똑똑해야합니다. 각 타입의 상황에 맞게 인자의 타입을 정확히 기술한다면 컴파일러가 좀더 편해질 것입니다.


 특정 데이터형식이 주어졌을때 다른일을 수행하는 하나의 함수를 갖는게 유용하므로, Common Lisp 명령어 defmethod는 각각 다른 타입을 지원하는 다수의 함수를 정의할 수 있도록 합니다. 함수가 호출될때, Lisp는 인자의 종류를 호출될시 확인하고 정확한 함수의 버전을 자동으로 선택합니다. 컴파일러/인터프리터가 인자의 타입에 기반하여 다른 함수를 선택하는것을 type dispatching 이라 합니다.

 여기 defmethod를 이용하여 어떻게 add함수를 작성하는지가 나와있습니다:
[source]

 보시다시피, add함수는 분리된 함수로써 각 타입의 상태을 조정하고, 기존에 존재하는 code의 수정 없이 새로운 상황을 추가할 수 있습니다. 종합적으로 code가 더욱 이해하기 쉬워집니다. 또한, 컴파일러는 인자의 타입을 알아볼 수 있고 이를 활용하여 더 빠른 code를 작성 할지도 모릅니다.

 defmethod함수는 같은 이름을 갖는 multiple 함수를 작성하도록 하는 점만 제외하면 defun과 비슷합니다. defmethod를 사용하면 함수의 인자 list에서 각 인자의 종류를 정확히 나타낼 수 있으며, Lisp는 각 상황에 맞는 add를 밝혀내기 위해 이 타입의 선언을 이용할 수 있습니다

 만일 여러분께서 OOP 세계와 친숙하다면, 아마도 method란 단어가 여러분에게 특별한 의미를 지닐 것입니다. 이 새로운 명령어가 defmethod라 불리기 때문에, OOP와 관계가 있을까요? 예 맞습니다. 이 명령어는 단지 Common Lisp의 built-in type에만이 아닌 여러분이 defstruct로 만든 structure 또한 이용할 수 있습니다. 기본적으로 defstruct와 demethod 조합은 간단한 object 시스템을 구성합니다

 이제 게임을 작성하기위해 이 object 시스템을 사용할 수 있습니다!


The Orc Battle Game

 Orc Battle 게임에서 여러분은 12마리의 몬스터에 둘러싸여 죽음에 맞써 싸우고 있는 기사입니다. 여러분의 지혜와 검술을 가지고 오크, 히드라, 그리고 끔찍한 다른 적들에 맞서 신중히 전략을 짜야만 합니다. 한번 잘못 움직이면, 그들 모두 쓰러트리기 전에 그 수에 압도당할 것입니다. defmethod와 defstruct를 사용하여, 이 쓰레기들 해치워 버립시다!(let’s dispatch some whoop ass on these vermin!)
[pic]


Global Variables for the Player and Monsters

게이머의 상태를 track하길 원합니다: 체력health, 민첩agility, 그리고 힘strength. 게이머의 체력이 0에 도달하면 사망합니다. agility는 얼마나 많이 공격할 수 있는지를, 그리고 strength는 공격의 흉폭함을 조절합니다. 게임 진행에서 이 각각은 변할 것이고, 게임진행과 전략에 미묘하게 영향을 줄 것입니다
[source]

 *monsters* 배열에 몬스터들을 저장하였습니다. 이 배열은 orcs, hydras, 혹은 다른 몬스터들을 저장할 수 있습니다. defstruct로 몬스터의 종족을 결정할 수 있습니다. 물론, Lisp의 generic 기능에서 리스트에 있는 각 타입을 어떻게 다루어야할지 밝혀내야합니다.

 또한 *monster-builders* 변수에 저장되어 있는 몬스터를 만들기 위해 함수 list를 선언해야합니다. 몬스터 타입에 관한 code를 각각 작성함으로써, 각각의 타입에 맞는 몬스터를 만들어주는 함수를 생성할 것입니다. 각 몬스터 builder들을 이 리스트에 넣어야 합니다. 이 list에 모든 builder 함수들이 갖음으로써 게임에서 무작위로 몬스터를 만들기가 쉬워질 것입니다.

 마지막으로, 저희가 싸워야만하는 몬스터의 수를 조정할 *monster-num*변수를 만들어야 합니다. 이 변수를 증가시켜 (혹은 감소시켜) Orc Battle의 난이도를 변경합니다.
[source]


Main Game Functions

 이제  나머지 시스템을 이끌어줄 도안으로써의 첫번째 실제 게임 code를 작성할 준비가 되었습니다.

 우선, orc-battle 함수를 정의할 것입니다. 이 함수는 몹을 초기화하고 game loop를 시작하며, 배틀이 끝나면, 승자를 판단하여 적절한 엔딩 메시지를 출력할 것입니다. 보시다시피, orc-battle 실제 작업을 하기 위해 충분한 helper 함수들을 호출합니다.
[source]

 상단 부분에서 몹과 게이머를 위한 초기화 함수를 호출합니다. 다음 game loop를 시작합니다. game loop는 게이머나 몬스터들이 죽을때까지 지속될 것입니다. 저희는 게이머나 몬스터들이 죽었는지에 따라 게임 엔딩 메시지를 출력할 것입니다.

 다음으로, game loop를 다루기 위해 game-loop 함수를 만들 것입니다. 이 함수는 배틀 라운드를 처리하고, 다음 라운드를 위해 자기 자신을 재귀적recursively으로 호출합니다:
[source]

 game-loop함수는 몬스터와 게이머의 반복되는 공격을 처리합니다. 싸움에서 살아있는 동안, 이 함수는 처음 REPL에서 게이머에 대한 정보를 보여줄 것입니다.

 다음으로, 게이머가 몬스터를 공격하도록 합시다. game-loop함수는 배틀에서 한 라운드당 얼마나 많은 공격을 가할 수 있는지 조절하기 위해 게이머의 agility을 이용하며, fudge factor를 사용하여 agility를 적절하게 작은 수로 변환시킵니다.  게임이 시작될때 게이머는 라운드당 세번의 공격을 할 수 있습니다. 배틀 후반에는 이 수가 라운드당 한번으로 떨어질 것입니다.

 게이머의 공격 loop를 위한 계산된 agility factor를 변수 이름과 숫자 n을 받아 코드 덩어리를 n번 실행하는 dotimes 명령어에 넣습니다:
[source]

 dotimes함수는 10장에서 더욱 자세하게 다룰 Common Lisp의 looping 함수중 하나 입니다.

 게이머가 공격한 후, 몬스터가 공격을 하게금 합니다. 몬스터 리스트를 map함수로 하여금 iterating을 하여 이 일을 수행합니다. 모든 몬스터들은 몬스터가 살아 있는 동안 호출 할 수 있는 특별한 monster-attack 명령어를 가졌습니다

 마지막으로, game-loop 함수는 자기자신을 재귀적으로 호출하므로, 배틀은 어느 한쪽이 몰살당할때까지 계속됩니다.


Player Management Function

 게이머의 속성(health, agility, 그리고 strength)을 관리하는데 필요한 함수는 매우 간단합니다. 다음으로는 게이머를 초기화하고, 죽었는지 확인하고, 상태를 출력하는데 필요한 함수입니다:
[source]

 player-attack 함수는 게이머의 공격을 관장합니다.
[source]

 우선, 이 함수는 게이머가 선택할 수 있는 몇몇 다른 공격 형식을 출력합니다. 보시다시피,공격 가능한 세가지가 게이머에게 제공되었습니다: stab, double swing, roundhouse swing. 게이머의 선택을 읽어, 상황에 맞게 각 공격의 형태를 조정합니다

 stab공격은 가장 강렬한 공격이며 하나의 적을 공격합니다. stab가 단일 적에게만 효과가 있어, 게이머가 공격할 것을 고르기 위해 pick-monster함수를 호출해야합니다. 공격력은 *player-strength*로부터 무작위 factor와 공격력이 좋아지기 위한 약간의 수정을 이용하여 계산됩니다. 게이머가 공격할 몬스터를 지정한후 공격력이 계산되면, 공격을 하기 위해 monster-hit 함수를 호출합니다.

 stab 공격과는 달리, double swing은 약하지만, 한번에 두마리의 적을 공격합니다. 공격의 추가적인 이점으로는, 휘두르기 시작할때 얼마나 강한지 기사에게 말해 줄 수 있습니다 - 공격하기에 최선의 적을 선택하는데 이용되어지는 정보. 이러한 double swing의 이점은 게임의 적략적인 재미를 가미시킵니다. 반면, double-swing 코드는 메시지를 출력하고 게이머가 누굴 공격할지 고른다는 면에서 stab 코드와 유사합니다. 그러나, 이번 경우에는 두 몬스터를 선택할 수 있습니다.

 마지막 공격 roundhouse swing은 적을 식별하지 못하는 야만적인 공격입니다. 게이머의 strength를 기반으로 dotimes loop를 돌아 무작위 적을 여러번 공격합니다. 그러나, strength가 단지 1빡에 안되어 각 공격은 매우 약합니다.

 승리하기 위해 이 공격을 올바른 상황에서 정확하게 사용해야 합니다. player-attack 함수에서 공격에 무작위성을 부여하기 위해, randval helper 함수를 무작위 수를 생성하기 위해 사용하였습니다. 이것은 다음과 같이 정의되었습니다:
[source]

 randval 함수는 1부터 n까지 무작위 숫자를 반환하며, n이 얼마나 작은지 상관치 않으며, 최소한 숫자 1이 반환될 것입니다. 0은 계산에서 사용되는 값으로 적절하지 않기 때문에, 무작위 수를 생성하기 위해 단순히 random함수대신 randval를 사용함으로써 실제 게임의 무작위성을 검사합니다. 예를들어, 기진맥진한 게이머나 몬스터라도 최소한 1을 공격력으로 가집니다.

 randval에서 사용된 random함수는 Lisp에서 고전(canonical) random value function 입니다. 몇몇 다른 방법으로 사용될 수 있으며, 주로 정수 n을 받아 0에서 n-1의 무작위 정수를 받아오는데 사용됩니다:
[source]


Helper Functions for Player Attacks

 player-attack 함수는 두개의 helper함수들이 필요합니다. 우선, 아직 죽지 않은 chaotic roundhouse attack의 타겟 몬스터를 지정할 random-monster 함수가 필요합니다:
[source]

 random-monster 함수는 우선 변수 m에 저장된 몬스터 배열에서 무작위로 몬스터를 고릅니다. 공격을 위해 살아있는 몬스터를 집기를 원하기 때문에, 우연히 죽은 몬스터를 집었다면 재귀적으로 다시 함수를 시도합니다. 그렇지않으면, 선택된 몬스터를 반환합니다.

 player-attack 함수는 또한 게이머가 무작위가 아닌 공격을 위해 몬스터를 타겟으로 집을 수 있도록 하는 함수가 필요합니다. 이것은 pick-monster함수의 일입니다:
[source]

 게이머가 공격하기 위해 몬스터를 선택하는 대신에, 우선 prompt를 출력해야하고 게이머의 선택을 읽어와야 합니다.

 그런다음 게이머의 결정이 너무 크지도 너무 작지도 않은 정수라는 것을 확인할 필요가 있습니다. 만약 그렇다면, 메시지를 출력하고 선택을 다시하기 위해 pick-monster를 다시 호출합니다. 그렇지 않다면, 선택한 몬스터를 변수 m에 안전히 넣을 수 있습니다.

 게이머가 발생시킬 수 있는 또 다른 에러는 이미 죽은 몬스터를 공격하는 것입니다. 이러한 가능성을 확인하고, 다시한번 게이머가 다른 선택을 하도록 만듭니다. 그렇지 않다면 게이머는 성공적으로 선택을 하였고, 선택된 몬스터를 결과로 반환 합니다.

 이제 몬스터를 가지고 작업을 해 봅시다.


Monster Management Functions

 *monsters* 배열에 저장되어있는 나쁜넘들을 초기화 시키기 위해 init-monsters함수를 사용할 것입니다. 이 함수는 몬스터를 만들기 위해 *monster-builders* 리스트에서 함수는 무작위로 함수를 꺼내서 funcall로 호출합니다:
[source]

 우선, init-monsters 함수로 몬스터들을 담기 위한 빈 배열을 만듭니다.
그다음 map으로 이 배열을 체웁니다. 이 lambda 함수에서, 여러분은 몬스터 builder 리스트에 있는 함수를 무작위로 funcalling함으로써 몬스터가 생성되어지는걸 수 있습니다.

 다음으로, 몬스터가 죽었는지 확인할 간단한 함수가 필요합니다. 모든 몬스터에 대해서 monster-dead 함수가 참인지 확인하기 위해, 어떻게 *monsters* 배열에 있는 명령어를 사용하는지 주목하시기 바랍니다. 이것은 몬스터가 전부 죽었는지 알려줍니다.
[source]

 모든 몬스터 리스트를 보여주기 위해 show-monsters 함수를 사용할 것입니다. 여기서 이 함수는 다른 함수로 그 작업의 일부를 연기할 것이며, 따라서 실제로 다른 몬스터 타입에 대해 많이 알 필요가 없습니다:
[source]

 게이머가 숫자로 몬스터를 선택해야 하므로, 변수 x에 있는 list에 있는 몬스터를 통해 loop로 얻는 것과 동일한 수치를 유지합니다. 다음으로 몬스터 list를 통해 각 몬스터에 맞게 몇몇 text를 출력할 lambda함수의 호출을 각 몬스터에 map합니다. 수치화된 list에 있는 각 몬스터를 x 변수를 사용하여 숫자로 출력합니다. 이것을 하기 위해, list를 통해 일을 하므로 x를 증가시키는 incf 함수를 사용합니다

 죽은 몬스터에 대해 더 많은걸 출력하길 원치 않으므로, 단순히 죽었다는 메시지만 보여줍니다. 살아있는 몬스터에 대해서는, generic 몬스터 함수를 호출합니다.
health를 계산하고 각각의 적의 타입에 맞춰 몬스터의 설명을 생성합니다


The Monsters

 지금까지 실제로 몬스터에게 life를 주는 어떠한 함수도 보지 못하였습니다. 그것을 고쳐봅시다. 우선 generic 몬스터를 기술 할 것입니다.


The Generic Monster

 예상했듯이 orcs, hydras, 그리고 나쁜 모든 것들은 하나의 공통점을 가지고 있습니다: 죽기전에 얼마나 많은 hits을 견뎌낼지 결정하는 health meter. monster structure에 있는 이 behavior를 잡을 수 있습니다:
[source]

 defstruct 함수를 사용함으로써 얻을 특별한 기능의 이점이 있습니다: structure에 있는 각각의 항목(이번 경우에, health)을 선언할때 괄호로 둘러싸 이름과 초기값을 넣을 수 있습니다. 그러나 더 중요한 점은, 새로운 몬스터가 생성될때 평가되는 form을 선언할 수 있다는 것입니다. 이 form이 randval을 호출하기 때문에, 모든 몬스터는 다르고 무작위의 health를 지니고 전투를 시작하게 될것입니다.

 몬스터를 만들어 봅시다:
[source]

 또한 공격 받을때 몬스터의 health를 줄이는 함수가 필요합니다. 저희는 몬스터가 죽었을때 보여지는 메시지를 포함하여 어떤 일이 있어났는지 설명하는 메시지를 출력하는 함수를 가질것 입니다. 그러나, 이 함수를 defun으로 생성하는 대신에, 기사가 특별한 몬스터를 쓰려뜨렸을때 특별한 메시지를 보여줄 generic defmethod를 사용할 것입니다:
[source]

 decf 함수는 변수로부터 하나를 빼게하는 setf의 변종입니다. type-of 함수는 monster-hit을 공격당한 몬스터의 타입을 아는 것처럼 행동하게 합니다. 이 함수는 어떤 Lisp 값의 타입을 찾는 데 사용할 수 있습니다:
[source]


 현재 the type of monster입은 항상 monster이지만, 곧 이 값은 각 monster type으로 바뀌게 될 것입니다.

 또한 몬스터를 만들기 위해 두 개의 generic method를 사용할 수 있습니다: monster-show 와 monster-attack.

 monster-attack함수는 실제로 어떠한 일도 하지 않습니다. 모든 몬스터 공격은 고유하기 때문에 generic attack에서 정의할 필요가 없습니다. 이 함수는 단순히 자리만 차지하는 것입니다.
[source]

 이제 저희는 generic 몬스터 코드를 가졌고, 마침네 나쁜놈들을 만들 수 있게 되었습니다!


The Wicked Orc

 orc는 단순한 적입니다. 몽둥이로 강력한 공격을 하지만, 거의 해가 없습니다. 모든 orc는 고유한 공격 level의 몽둥이를 가졌습니다. 비정상적으로 강력한 몽둥이 공격을 하지 않는한 Orc들은 무시하는게 최선입니다. 

 orc를 만들기 위해, defstruct로 orc 데이터형식을 정의합니다. 여기서, 저희는 defstruct의 또다른 진보된 기능을 사용하여 monster범주에 orc를 포함하도록 선언할 것입니다.

 orc타입을 범주에 포함시키기 위해 orc는 health field와 같은 모든 몬스터에 적용되는 field들을 상속 받아야합니다. C++나 Java와 같은 유명한 언어에서도 generic class를 정의하고 이 generic class로부터 상속받는 더욱 특화된 classes를 생성함으로써 이와 유사한 일을 할 수 있습니다.


 일단 structure가 선언되면, (defstruct에 의해 자동적으로 생성된)make-orc함수를 *monster-builders* 리스트에 집어 넣습니다:
[source]

NOTE
 이러한 접근은 정말로 강력합니다. 기본 Orc Battle code를 수정할 필요없이 저희가 원하는 새로운 몬스터 타입을 추가할 수 있습니다. 이것은 동적 타입과 first-class value로 함수를 지원하는 Lisp와 같은 언어에서만 가능합니다. 정적 타입 프로그래밍 언어에서, Orc Battle 코드는 새로운 타입의 몬스터의 생성자를 호출하는 hardwired 방법이 필요할지도 모릅니다. first-class 함수로 인해, 이것에 대해 걱정할 필요가 없습니다.

[pic]

 이제 orc에 맞게 monster-show와 monster-attack함수를 특수화시킵시다specialize. 인자 리스트에서 이 함수가 orc-특화되도록 명시적으로 선언한다는 점을 제외하면, 이 함수의 이전 버전과 동일한 방법으로 정의되었다는 것을 알립니다:
[source]

 orc 타입에 관해 고유한 특성은 각 orc는 orc-club-level field를 가졌다는 것입니다. 이 orc-특화된 monster-show와 monster-attack버전은 이 filed를 고려합니다. monster-show함수에서 이 club 레벨을 보여줌으로써, 게이머는 각 orc의 위험수준을 측정할 수 있습니다.

 monster-attack함수에서, 이 club레벨을 사용하여 게이머를 때릴때 얼마나 나쁘게 될지를 결정합니다.


The Malicious Hydra
[pic]

 hydra는 매우 위험한 적입니다. 이것은 (이것을 이기기 위해 짜를 필요가 있는)많은 머리로 공격합니다. hydra의 특별한 능력은 매 배틀 라운드마다 새로운 머리가 자라날 수 있다는 것이며, 이는 가능한 빨리 이걸 쓰려뜨려야 한다는 것을 의미합니다.
[source]

 hydra를 다루는 이 code는 orc를 다루는 code와 유사합니다. 주요한 차이점은 hydra머리 수가 hydra의 health의 대리 역활을 한다는 것입니다. 다시 말해서, hydra 3 health point를 가졌다면 3개의 머리를 가졌다는 것과 같습니다. 그러므로, hydra-특화된 monster-show 함수를 작성할때, 몬스터의 health를 사용하여 hydra의 머리 수를 알맞게 출력할 것입니다.

 또 다른 orc와 hydra의 차이점은 orc는 게이머에게 맞았을때 특히 흥미있는 일을 하지 않는다는 것입니다. 왜냐하면, orc에게 custom monster-hit함수를 작성할 필요가 없기 때문입니다; orc는 단순히 generic monster를 위해 생성한 generic monster-hit함수를 사용합니다.

 반면, hydra는 이것이 공격받았을때 어떤 흥미로운 일을 합니다: 머리가 떨어져 나갑니다! 그러므로 blow에 의해 머리가 사라지는 곳에 hydra의 health가 낮아지도록하는 hydra-특화된 monster-hit함수를 작성합니다. 또한, 저희는 이제 기사가 머리를 잘라내는 것에 관한 다이나믹한 메시지를 출력할 수 있습니다

 hydra의 monster-attack함수는 orc와 유사합니다. 한가지 흥미로운 차이점은 매 공격마다 health가 증가한다는 점이며, 따라서 매 턴마다 hydra의 새로운 머리가 자라납니다.


The Slimy Slime Mold

 slime mold는 희귀한 몬스터입니다. 이것이 여러분을 공격할때, 이것자체가 여러분의 다리를 감싸서 못움직이게 만들어, 다른 나쁜놈들이 여러분을 끝내도록 만듭니다. 이것은 또한  여러분의 얼굴에 찐득 찐득한것을 뱉습니다. agility를 유지하기 위해 초기에 slime을 제거해버리는게 나은지, 무시하고 더 흉칙한 적에 집중하는지 빠르게 결정해야 합니다. (slime mold가 agility를 낮추므로 나중에 있을 배틀 라운드에서 여러분의 공격 횟수가 줄어든다는 것을 명심하시기 바랍니다.)
[pic]
[source]

 slime mold의 monster-attack 함수는 게이머를 움직이지 못하게 하는 특별한 일을 합니다. 우선 slime mold의 (각 slime mold가 만들어질 때 생성된)끈끈이를 사용하여 변수 x에 저장된 게이머에게 무작위 공격을 생성합니다. 게임에 다른 공격과는 달리 이 slime mold 공격은 게이머의 health보다 agility에 영향을 미칩니다.

 그러나, 만약 slime mold가 게이머의 health를 조금이라도 공격을 할 수 없으면 이것은 소용없을 것이며 게이머와 slime mold가 계속 꼼짝 못하게 되어 전투는 형편없이 끝나게 될 것 입니다.

 그러므로, 이 slime mold는 또한 모든 공격 중간에 게이머 health point를 단지 1만 빼는 superwimpy squirt attack을 합니다


The Cunning Brigand

 brigand는 여러분의 적들중 가장 작습니다. 그는 그의 채찍이나 새총을 사용하고 여러분의 최고의 자산assets을 무효화시키려 합니다. 그의 공격은 강력하진 않지만, 매 라운드마다 2 포인트씩 거듭됩니다.
[source]
[pic]

 약삭빠른 brigand가 공격할때 하는 첫번째 일은 게이머의 health, agility, strength를 살펴보고 공격 목표로 이 세가지중 가장 높은것을 선택하는 것입니다. 각 속성이 모두 높다면, brigand는 agility보다 health를 strength보다 agility공격에 초점을 둡니다. 만약 health가 높다면, 게이머는 새총으로 맞을 것 입니다. agility가 높다면, brigand는 게이머의 다리를 채찍질 할 것입니다. strength가 높다면, brigand는 게이머의 팔을 채찍질 할 것입니다.

 저희는 이제 완전히 저희 게임의 모든 몬스터들을 정의하였습니다!


To Battle!

 게임을 시작하기 위해, REPL에서 orc-battle을 호출합니다:
[source]

 매우 끝내주게 생긴 7개의 머리를 가진 hydra - 우선 이것을 stab로 끝내버립시다:
[output]

 딱히 눈에 띄는 나쁜 놈이 없으므로, 전체적으로 이들의 health 수치를 조금 낮추기 위해 roundhouse 를 시도할 것입니다:
[output]

 훌륭합니다! 약한 몬스터중 하나가 죽었습니다. 이제 agility가 가득 찼으므로 라운드당 3번 공격할 수 있습니다. 이것은 좀더 강력한 나쁜놈을 날려버리기 위해 전략적으로 마지막 공격을 사용해야만 한다는 것을 의미합니다. double swing을 이용해 봅시다:
[output]

 적에게 한방 먹었지만, 여전히 많은 싸움이 남아 있습니다. 이 싸움은 아직 끝나지 않았습니다!

 보시다시피, Orc Battle에서 살아남길 원한다면 사려 깊은 전략이 필요합니다. 여러분께서 이 새로운 게임을 즐겼으면 합니다!


What You’ve Learned

이번 장에서, Common Lisp에 있는 더욱 진보된 데이터 구조를 다루었습니다. 그후 이것을 사용하여 monster-fighting 게임을 만들었습니다. 이러한 과정을 거치며, 저희는 다음과 같은것을 배웠습니다:

z 배열은 리스트와 유사하나, 특정 offset에 있는 항목에 효율적으로 접근한다.

z 해쉬 테이블은 alist와 유사하나, 키와 연관된 값을 효율적으로 찾는다.

z 적절한 장소에서 배열과 해쉬 테이블을 사용하는 것은 code를 보다 빠르게 해 줄 것이다.

z  데이터 구조나 알고리즘을 바꾸는 것이 여러분의 프로그램을 빠르게 만들어 주는지 아는 유일한 방법으로는 time 명령어로 여러분의 코드의 시간을 제는 것이다.

z Common Lisp는 다양한 데이터형식에 사용할 수 있는 generic 함수들을 가졌다. 이러한 sequence 함수들의 유용함은 리스트, 배열, 문자열을 명료하게 다룰 수 있다는 것입니다.

z defstruct 명령어를 사용하여 object와 properties를 list로 만들 수 있다.