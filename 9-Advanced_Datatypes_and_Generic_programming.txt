9장.진보된 데이터형식과 제네릭 프로그래밍

9.ADVANCED DATATYPES AND GENERIC PROGRAMMING


 봐왔던 것과 같이, Lisp에서  cons cells, symbols, 문자열, 수치 데이터형식으로
수행할 수 있는 많은것들이 있습니다. 매우 성숙한 언어답게, Common Lisp는 이러한 기본적인 것을 뛰어넘을 더 많은 데이터 형식을 포함하고 있습니다. 이번장에서는, 이러한 배열arrays,  해쉬테이블hash tables, 그리고 구조체structures포함해서 진보된 데이터형식의 유용함을 다룰 것입니다.


Arrays

 Common Lisp 배열은 list와 매우 유사합니다. 배열을 사용함으로 얻는 주요 이점은 어떤 특정 지점에 있는 값에 접근하기 위해 상수 시간을 요구한다는 것입니다. 이것이 의미하는것이 무엇인지 짥게 다룰 것입니다.


Working with Arrays

 새로운 배열을 만들기 위해선 배열의 크기를 지정하여 make-array명령어를 사용합니다:
[source]

 이것은 길이가 3인 배열을 만듭니다. 만들어진 값이 list가 아니라는 것을 나타내기 위해, Common Lisp는 배열 앞에 해쉬 표시(#)를 답니다.

 배열에 있는 항목을 얻거나 설정하기 위해선 aref함수를 사용합니다. 예를 들어, 여기 index 1에 있는 항목을 어떻게 얻는지 나와있습니다:
[source]

 물론 지금 당장 배열은 nil로 체워져 있어서, getting 할 가치가 없습니다. 배열에 있는 항목을 더 흥미를 끄는 값들로 설정하기 위해, setf 명령어와 함께 aref를 사용합니다:
[source]

 aref가 배열에서 값을 얻기에 유용하지만, 이 예제에서 나타난 특별한 방법으로 사용될때에는 배열의 값을 설정합니다. setf와 aref 명령어를 같이 사용하는 능력은 Common Lisp의 능력을 보여줍니다: 제네릭 프로그래밍을 지원합니다. 어떻게 이 기능이 동작하는지 더 배우기 위해 setf명령어를 자세히 살펴봅시다.



Using a Generic Setter

 Common Lisp 언어는 제네릭generic setter를 지원한다고 말합니다. 대부분의 경우, 이것이 의미하는 것은 데이터 구조(배열, 리스트, 문자열, 혹은 다른 것)에서 값을 빼내오는 code가 같은 데이터 구조에 넣는 code와 동일하다는 것입니다. setf명령어는 getting 연산을 하는 함수와 결합되어 사용할 수 있고, setting 연산을 하는 함수와도 사용할 수 있습니다.

 이미 저희는 aref 배열에서 값을 얻을때 사용할 수 있다는 것을 보았고, setf와 사용하여 배열의 값을 setting시 사용할 수 있다는 것을 보았습니다. data 구조로부터 항목을 얻는 대다수의 Common Lisp의 명령어에서, setf명령어는 제네릭 방식으로 이 trick을 수행할 수 있습니다. 예를들어, list와 관련있는 다음 예제를 봅시다:
[source]

 기대했던 것과 같이 표현식 (second foo)는 B를 반환합니다. 그러나 setf명령어에 (second foo)를 통과시켰을때, 이것은 B가 어디서 왔는지 알고 표현식 (second foo)를 regular 변수인것처럼 다룰 수 있습니다. 기본적으로, setf명령어는 자기 자신에게 질문합니다 "첫번째 인자에 있는 항목이 본디 어디서 왔을까?" 이번 경우에, 값은 foo라는 이름의 list의 두번째 항목에서 왔습니다. 그러므로, 이 지점에서 setf를 시도한다면 원본 변수 foo는 반응하여 수정됩니다.

 사실 setf의 첫번째 인자는 generalized reference라고 불리는 Common Lisp의 특별한 sublanguage입니다. 모든 Lisp 명령어가 generalized reference를 허용하는 것은 아니지만, but you can still put in some pretty complicated stuff:
[source]

 이번 예제는 Common Lisp에서 setf의 진정한 힘을 보여줍니다. 첫번째 사용한 것에서, list (x y z) 를 배열의 세번째 항목으로 넣었습니다. 만일 지금 foo를 출력한다면, 이것이 동작한 것을 볼 수 있습니다. 두번째로 사용한 것에서, foo 배열에 있는 이 list의 첫번째 항목을 해쉬테이블로 바꾸었습니다. 해쉬 태이블 은 157 쪽에서 짧게 배울 또 다른 진보된 data 형식입니다. setf로 이 일을 하는 것은 놀랄만큼 쉬운데, setf의 첫번째 인자에 있는 generalized reference는 임의로 복잡해 질 수 있기 때문입니다.

 마지막으로, 해쉬 테이블안에 key는 zoink로 하여 값 5를 삽입하였습니다. gethash함수는 해쉬 테이블 밖으로 값을 얻어오도록 합니다. 대신 여기서는 setf의 도움으로 해시 테이블에 숫자 5를 넣었습니다.

 이번 예제로부터 프로그램에서 복잡한 data 구조를 수정할때 setf가 유용할 수 있다는 것을 인지하길 바랍니다.

 setf의 또 다른 멋진 기능은 값에 접근하는 새로운 방식을 지원하도록 generalized reference 문법을 확장 시킬 수 있다는 것입니다. setf는 내포된 단계(level of nesting)나 쓰여진 데이터형식에 구애받지 않고 값을 수정하는 진정한  generic 방식입니다.


Arrays vs. Lists

 여러분은 이제 Lisp에서 배열이 동작하는 기본 예제를 살펴보았습니다. 그러나 배열의 이점을 완전히 이해하기 위해, list와 비교해볼 필요가 있습니다.

 list로 할 수 있는 대다수는 배열로도 할 수 있습니다. 그러나, 일반적으로 배열은 특정 원소에 접근할때 list보다 빨라서 성능면에서는 다릅니다.

 예를들어 array-handling함수 aref는, 배열을 사용하지 않고 regular list의 특정 지점에 있는 항목에 접근하는 nth라 불리는 list-handling함수와 매우 유사흡니다. 여기 list에 nth를 사용하는 예제가 있습니다:
[source]

 그러나, 매우 작은 list에만 nth 함수를 사용하는게 이치에 맞습니다. 예를들어, list X가 수천개의 항목을 가졌고 (nth 1000 x)명령어를 실행하면 정말로 느릴것인데, Lisp list는 cons cells의 chain으로 만들어 졌기 때문입니다. Lisp에서 list에 있는 수천개의 항목을 찾을 수 있는 유일한 방법은 999개의 object를 먼저 휘졋고 다니는 것입니다.

 대조적으로, 큰 배열에서 (aref x 1000)명령어를 수행하는것은 이전 999항목을 거쳐 세는것 없이 천번째 항목을 직접 접근합니다. 이것이 의미하는 것은 큰 배열에서의 aref는 큰 list에서의 nth명령어보다 더욱 빠르게 수행될 것이라는 것입니다. 10억개의 항목을 가진 배열이 있을지라도, 마지막 항목을 검색하는 것은 여전히 매우 빠를것입니다. 실제 제한하는 요소는 오직 여러분의 시스템 뿐입니다: 여러분의 컴퓨터의 RAM용량과 이것을 이용하는 Lisp 환경의 저장 방식.
[pic]

 배열 값에 빠르게 접근할 수 있을 뿐만아니라, 일반적으로 여러분이 list로 같은 작업을 수행 할 수 있는 것보다 빠르게 특정 장소에 있는 값을 바꿀 수 있습니다.

 큰 data 구조에서 특정 값을 setting하거나 getting 하는 것은 매우 중요하므로, 배열을 여러분의 코드에서 가능한 최상의 성능을 얻도록 여러분을 도와줄수 있는 툴이라 명심하시기 바랍니다.


Hash Tables

 배열이 list과 비슷하듯이, 임의의 요소에 빠르게 접근한다는 점을 제외한다면 해쉬 테이블은 alist와 비슷합니다.

 사실, 해쉬 테이블은 때때로 마법처럼 보여질 정도로 매우 효율적입니다. 은하수를 여행하는 히치하이커를 위한 안내서의 Babel fish을 떠올려봅시다- 실제로는 존재하지 않지만 매우 놀랄만한게 유용한 것. 이것이 대다수의 모든 현대 언어들이 이제 해쉬 테이블 데이터형식을 제공하는지에 대한 이유입니다.
[pic]


Working with Hash Tables

 make-hash-table명령어로 새로운 해쉬 태이블을 만듭니다:
[source]

 alist와 같이 해쉬 테이블은 lookup key와 값을 이용하여 항목을 저장합니다. 항목의 key와 gethash 함수를 사용하여 해쉬 테이블로부터 하나의 항목을 받을 수 있습니다:
[source]

 지금까지 해쉬 테이블은 비어있습니다. 이것이 의미하는 것은 해쉬 테이블에서 어떤 key를 살펴볼때, 이번 예제에서 'yup  대답으로 NIL을 받는다는 것입니다. 실제로, 저희는 두개의 NIL을 받았습니다 - gethash 명령어는 Common Lisp에서 할 수 있는 여러개의 값을 반환합니다(다음 section에서 다룰것입니다). 반환된 첫번째 값은 해쉬 테이블에 저장된 실제 값이며, 두번째는 테이블에서 찾은 key가 무엇인지 가리킵니다(이번 경우에는, 없습니다).

 배열로 했을때 처럼, 여러분은 data로 테이블을 체우는 대신에 setf명령어와 data 요소를 참조하는데 사용하는 명령어를 조합할 수 있습니다 - 이번 경우에는 gethash:
[source]

 이번 예제에서, yup을 lookup key로써 해쉬 테이블에 값 25를 저장했습니다. 그 다음, 테이블에서 yup을 살펴보면, 25라는 답을 얻게 됩니다. 또한 t라는 두번째 값을얻는데 이것이 의미하는 것은 "예, 저는 테이블에서 key를 찾았습니다" 입니다.

 alist를 다루었을때, coffee 음료 주문을 포함하는 data 구조를 설정했던것이 기억나십니까? 여기 동일한 data가 있으며, 이번에는 해쉬 테이블을 사용하여 저장됩니다:
[source]

 누군가의 음료 주문을 찾아보는것이 이제 간단해졌습니다:
[source]


Returning Multiple Values

 Common Lisp는 여러분이 결과로 하나의 값보다 더 많이 반환하는 것을 허용합니다. 여러분이 봐왔던것 처럼 gethash함수를 포함하여 Common Lisp의 몇몇 core 함수는 이러한 일을 합니다. 일반적으로 사용되는 다른 함수는 수를 반올림하는 round 함수입니다:
[source]

 이 함수를 호출하면 수를 알맞게 2로 반올림하지만, 반올림 연산의 나머지인 두번째 값도 생성합니다. 이 함수 호출에서 두 값이 반환됩니다.

 또한 여러분의 code에서 values함수를 사용해서 다수의 값들을 생성할 수 있습니다. 예를들어, 여기서 여러분은 3과 7를 반환하는 foo라는 함수를 작성할 수 있습니다:
[source]

 round 함수와 마찬가지로 이 값들은 모두 REPL에서 출력됩니다. 그러나, Lisp는 첫번째 값을 더욱 중요하게 여기며, 후속 계산동안 항상 default로 사용될 것입니다. 예를들어, foo함수를 호출한 뒤 이와 같이 추가 작업을 수행할 수 있습니다:
[source]

 이번 경우에, 추가 연산은 foo가 반환한 두번째 값을 무시합니다.

 그러나, 종종 추가적인 반환 값을 사용해야 할 필요가 있습니다. multiple-value-bind명령어를 사용하여 이러한 일을 할 수 있습니다:
[source]

 이번 예제에서, a와 b 변수를 foo에 의해 반환된 값 (3 과 7)로 묶었습니다. multiple-value-bind와 함께 함수를 호출하여, 다른 경우에는 무시되어지는 함수로부터 반환된 추가 값들을 사용하도록 합니다.

 여러분은 multiple-value기능을 사용하는 대신에 함수로부터 list를 반환 할 수 있는지 궁금해할 지도 모릅니다. 정답은 "할 수 있다" 입니다. 그러나 mutiple-value기능을 사용하면 더욱 최적화되고 깔끔한 code를 이끌어내는 것이 가능합니다

 이 책에서는, multiple value를 사용하지 않습니다. 사실, Arc나 Clojure와 같은 최근 Lisp방언들은 multiple 값을 전혀 지원하지 않습니다. 대신에, 하나의 값보다 많이 반환될 필요가 있을 경우에 list를 반환합니다.


Hash Table Performance

 배열처럼, 해쉬 테이블이 얼마나 많은 항목들을 갖고 있던지 간에 해쉬 테이블 안에 있는 값의 접근과 수정은 상수 시간을 요구합니다. 예를 들어, 해쉬 테이블이 10개의 항목을 가지고 있다고 가정해 봅시다. key를 사용하여 테이블에서 값을 접근하고 이것을 찾아내는데 걸린 시간은 평균 0.001초가 걸립니다. 이제 해쉬 테이블이 1,000,000 항목을 가졌다고 가정해봅시다. (해쉬 테이블이 그렇게 설계되었기 때문에) 값을 받는데 여전히 0.001초가 걸릴 것이라고 예상할 수 있습니다. 다시말하자면, 테이블이 얼마나 크든지간에, 0.001초라는 상수 시간에 항목에 접근 할 수 있습니다.

 어떻게 엄청난 이 일이 가능한지 생각해 보십시요! 해쉬 테이블이 1,000,000개의 항목을 포함할지라도, gethash함수는 key를 취하여 상수 시간안에 여러분이 원하는 항목을 찾을수 있는 곳을 정확히 결정할 수 있습니다!

 어마어마한 양의 data를 뒤로하는 web-기반 프로그램의 시대에서, 많은 양의 값들을 저장하고 빠르게 반환하는 해쉬 테이블의 능력은 필수입니다. 키/값의 쌍으로 저장하는 효율성은 대다수의 온라인 저장 시스템에서 필수입니다. 구글의 BigTable이나 아마존의 S3와 같은 막대한 양의 온라인 데이터를 저장하는 최근 툴이라도, 해쉬테이블과 유사하게 만들어 키를 사용함으로써 값을 재빨리 받아오도록 만들어졌습니다

 그러나, 여러분은 항상 해쉬 테이블이 최고의 성능을 제공한다고 단언 할 수 는 없습니다. 여기에 왜 그런지에 대해 나와 있습니다:

가상 메모리 패이징virtual memory paging과  cache misses:
 배열과 마찬가지로, 큰 해쉬 테이블은 여러분의 운영체제로 하여금 하드 드라이브의 가상 메모리 패이징 유발시킵니다. 따라서 성능이 줄어들게 됩니다. 유사하게, CPU cache missed의 수도 증가 할 수 있습니다.

해쉬 충돌:
 내부적으로 해쉬 테이블은 키를 수로 변환시키는 hash함수라 불리는 특별한 함수를 사용합니다. 이와 같은 해쉬 함수는 해쉬 충돌을 유발시킵니다. 본질적으로 해쉬 충돌은 우연히 두키가 hash함수에 의해 같은 수로 변환될때 일어납니다. 이 경우에 미세한 성능 감소가 있을지라도 해쉬 테이블은 여전히 정확하게 행동합니다. 드믄 경우에, 특정 종류의 key가 충돌 횟수를 증가시키도록 hash 함수에 영향을 미칠 수가 있고 어플리케이션의 찾는 능력을 지연시켜 성능은 더욱더 감소하게 됩니다.

작은 테이블의 비효율성:
 매우 작은 테이블에서 해쉬 테이블이 요구하는 생성과 찾는 시간은 alist와 같은 간단한 구조보다 비효율적입니다. 해쉬 테이블의 성능 이점은 data양이 큰 경우에만 두드려집니다.


변하는 연산 속도:
 만약 여러분이 Common Lisp에서 작은 해쉬 테이블을 만들고 값으로 체워넣다보면 새로운 값을 추가하는 것이 때때로 비정상적으로 느리다는 것을 발견할 것입니다. make-hash-table함수가 작은 해쉬 테이블을 만드는 비용을 최소화하게 설계되었기 때문입니다. 그러나 테이블을 크게 만드는 값을 추가하기 시작한다면 Lisp는 더 많은 메모리를 할당하기위해 여분의 시간을 요구하며, 테이블은 더 많은 항목을 담을 수 있게 됩니다. 이러한 추가 할당은 테이블이 자라면서 종종 느린 삽입을 야기시킵니다.

해쉬 테이블이 항상 최선의 해결책이 아닌 마지막 이유:
 cons cells로부터 세워진 전통적인 Lisp 구조만큼 Lispy하지 않습니다. 이것이 의미하는 것은 Lisp REPL에서 자연스럽게 출력되거나 읽을 수 없기 때문에 디버그하기에 cons cells보다 어렵다는 것입니다. 그러므로, 좋은 rule of thumbs는 배열과 해쉬 테이블을 새로운 code조각으로써 염두에 두고 멀어지는 것입니다. 그리고 만약 성능이 이슈로 떠올랐을때, 어떤 성능 문제를 해결하기 위해 배열과 해쉬 테이블의 이점을 얻을 수 있는, 여러분의 code의 critical section을 신중하게 수정합시다.


A Faster Grand Theft Wumpus Using Hash Tables

 해쉬 테이블이 여러분의 code를 위해 무엇을 할 수 있는지 연습 문제를 살펴봅시다. 최근 게임 Grand Theft Wumpus에서 눈에띄는 비효율적인게 있었는데, 이제 그것을 해쉬 테이블로써 바로잡을 수 있습니다.

 Grand Theft Wumpus에서 도시 graph를 표현하기 위해 nodes와 edges의 list를 사용한 이전 장을 회상해봅시다. 주어진 node로 찾는 것 대신에, list를 통해 선형적으로 찾아야 합니다. Congestion City는 많은 교차로를 가지고 있지 않기 때문에, Grand Theft Wumpus에서 큰 작업을 요구하지 않습니다 그러나 도시가 천개의 node와 천개의 edge를 가진다면 어떨까요? get-commected 함수를 보고 어느 정도의 수치를 얻는지 봅시다:
[source]

 time명령어는 code 덩어리에 관한 모든 종류의 유용한 시간 정보를 출력하는 Lisp의 utility이며, dotimes함수는 code를 100번 수행하게 하고, 100개의 도시를 건설합니다. 이 명령을 사용해서 제 컴퓨터에서 이 code를 돌렸을때 일분 정도 걸렸습니다. CPU가 일분동안 처리할수 있는 엄청난 수의 instruction이 주어졌고, 이것은 명백하게 끔찍한 성능을 나타냅니다.

 이 문제를 해결하기 위해, edge list를 해쉬 테이블로 변경하고, 따라서 get-conncted함수는 상수 시간에 연결을 찾을 수 있을 것입니다. 또한 방문했던 list를 방문했던 table로 교체할 것이며, 따라서 함수는 빠르게 어떤 node가 이미 방문했는지 답할 수 있습니다.

 여기 이것을 수행하는 해쉬화된 버전으로 구성된 코드가 있습니다:
[source]

 우선, edge list를 해쉬 테이블로 변환시키는 hash-edges함수가 필요합니다. 함수의 시작 부분에서, tab이라는 새로운 해쉬 태이블을 만들었습니다. 그 다음, mapc로 테이블을 iterate합니다. side effect에 관해 주의해야 하거나 결과로 최종 list를 생성하는 것에 신경쓰지 않는 곳에 사용한다는 점을 제외하고, mapc는 mapcar와 같다는 것을 기억하시기 바랍니다.

 모든 node들에 대해 저희는 이것과 연결된 node들의 list를 포함할 table을 원합니다. 그러므로, list를 iterate하면서 starting node를 위해 neighbors의 list에 새로운 neighbor를 push합니다. regular Lisp 변수값처럼 해쉬 테이블 값에 push명령어를 사용할 수 있습니다. 다시 말해서 이것은, 166쪽 "Handling Data in a Generic Way" 에서 다룰, Common Lisp에서 만들어진 general 변수 시스템을 사용합니다.

 테이블에 있는 node의 값이 없는 경우를, 처리할 필요가 없어 혼란스러울지도 모릅니다. 어떻게 값이 존재하지 않는데 테이블에 무언가를 push할 수 있을까요? 테이블에서 key를 찾을 수 없을때 gethash함수는 NIL을 반환하기 때문에, 이 code는 단순히 새로운 neghbor를 empty list에 push하고 이전에 none을 찾았던 테이블에 새로운 기록을 집어넣습니다. 이리하여, push명령어는 node가 새것이거나 이전것이든 상관치않고 마법과도 같이 "정확한 일"을 수행합니다.

 마지막으로, 테이블이 가득차면 이것을 결과로 반환합니다. 이것은 원래 edge list와 같은 data를 포함하고 있습니다. 다른점은 Congestion City안의 어떤 node의 neighbors를 광속으로 찾을 수 있습니다.
[source]

 이제 저희는 Congestion City에서 시작 node에 연결된 모든 node들을 되돌려받을 get-connected-hash를 작성할 준비가 되었습니다. 이것은 get-connected와 행하는 것은 동일하지만, 해쉬 테이블을 통해 최적화 되었습니다.

 이 함수가 하는 첫번째 일은 방문했던 node들의 해쉬 테이블을 만드는 것입니다.

#TODO
그다음 Congestion City의 node들을 통해 이동합니다
 시작 node로부터 출발하는
Then we travel through the nodes of Congestion City, beginning with the 
starting node.

 새로운 node를 방문할 때마다, 이전에 방문했었는지 스스로 물어봅니다.
 이제 저희는 방문했던 테이블에 있는 현재 node를 살펴봄으로써 이 질문에 매우 효율적으로 대답할 수 있습니다.

만일 아니라면, 이 노드를 방문했다고 표시할 필요가 있고 mapc로 이것의 모든 neighbors를 확인해야합니다
 If the answer is no, we’ll need to mark 
this node as visited [ and check all of its neighbors by mapcing through 
them?checking our edge table \. Finally, we return our visited table, which 
in the end will hold all nodes that are connected to the starting node ].

 이제 새로운 logic으로 다시 테스트할 수 있습니다:
[source]

 보시다시피, graph의 연결을 계산하는데 일분 정도 걸렸던데 반해, 이제는 같은 일을 하는데 단지 일초정도 빢에 걸리지 않습니다!

 이것이 해쉬 테이블의 사용법을 알고 있어야 하는 이유입니다.


Common Lisp Structures


 structure는 Common Lisp에서 사용가능한 진보된 데이터형식입니다.

 Structure와 속성은 여러분의 code에서 data를 표현할 유용한 방법이 될 수 있습니다.

Working with Structures

 Structure는 이와 같이 defstruct 명령어를 사용하여, 전통적인 객체-지향 프로그래밍(OOP) 언어에서 찾을 수 있는 것처럼 객체objects와 속성properties을 나타내는데 이용할 수 있습니다:
[source]

 이 structure의 정의를 따르자면, person은 네가지 속성을 가집니다(Lisper들이 slots이라고 부르는): name, age, waist-size, 그리고 favorite-color.

 이 structure를 정의하면, person대신에 defstruct가 자동적으로 생성한 특별한 함수 make-person명령어를 사용하여 생성할 수 있습니다:
[source]

이제
*bob*을 REPL에 입력하면,
새로운 person을 보게될 것입니다
#S
structure
Now when we enter *bob* into the REPL, we see our new person marked as 
a structure with the #S prefix.

 저희는 또한 structure가 person 형식이라는 것과 이것의 각 속성(name, age, waist-size, 그리고 favorite-color)의 값을 알 수 있습니다:
[source]



 또 다른 자동적으로 생성된 person-age함수를 호출함으로써 Bob의 나이를 알 수 있습니다:
[source]

우리는 또한 setf와 이 명령어를 사용하여 Bob의 나이를 바꿀 수 있습니다.(생일 축하해, Bob!)
[source]

#TODO
Lisp reader는 또한
person을 직접 생성할 수 도 있습니다
person
Lisp의 print/read symmetry에 대한 또 다른 좋은 예제
The Lisp reader can also create a person directly from the printed repre-
sentation of the person, another great example of the print/read symmetry 
in Lisp:
[source]

 여기, 새로운 변수 *that-guy*를 만들고,

 Here, we’re creating a new variable called *that-guy*, and we set its value 
using only the printed representation of the person X.

 이 변수는 이제 make-person함수를 사용한것 처럼 실제 person structure를 가지게 되었습니다.

 보시다시피, defstruct는 특별한 함수를 만드는데 사용할 수 있고 새로운 object를 생성하고 속성에 접근하기 쉽게 만들어주는 매우 강력한 명령어 입니다


When to Use Structures

 오늘날, 많은 mainstream 프로그래머들은 크고 견고한 어플리케이션을 개발할때 객체 지향이 필수라고 믿고 있습니다.

 반면, 많은 Lisper들은 purely OOP 접근을 취하지 않고 고품질의 소프트웨어를 만들때 이것은 가능하다고 믿고 있습니다.


 14장 시작부분에서, 고-수준 함수형 프로그래밍과 domain-specific 언어 프로그래밍을 포함하여 이러한 반대되는 접근 방식을 보여줄 것입니다.

#TODO
Lisp언어의 설계
이러한 반대되는 접근의 이점을 쉽게
객체-지향적 언어보다 더욱 
 The design of the Lisp language makes it much easier to take advantage of these alternate approaches than is possible with other, more object-oriented languages.


 비록 여러분이 순수 OOP-style 소프트웨어를 작성하지 않을지라도, structure와 properties는 여전히 여러분의 code에서 data를 표현할 유용할 방법이라는걸 입증할 수 있습니다.
Regardless, even if you’re not writing purely OOP-style software, structures 
and their properties can still prove to be a useful way to represent data in 
your code.

예를들어, defstruct로 person class를 생성하는 대신에, 표준 list와 여러분만의 make-person함수로 이와 동일한 일을 할 수 있습니다.

#TODO
 어찌됬든, 왜 
 After all, why bother with structures if we can just roll our own person using 
lists, like so:
[source]

 비록 이런 접근이 통할지라도, 몇몇 않좋은 점을 가졌습니다.


우선, person의 나이나 다른 properties를 확인할때
에러-유발 함수를 작성할 필요가 있습니다
정확한 위치에서 
properties를 뽑아올때
 First, in order to check a person’s age or other properties, we would need to write a lot of error-prone functions that pull properties out of the list from the correct locations.


또한, 출력된 버전 
 Also, the printed version of our ad hoc object X is very hard to understand. How do we know BOB is a person? Is Bob’s age 35 or 32? 


Regular list는
Regular lists just don’t lend themselves well to encoding objects with multiple properties.

Another problem with using lists to represent an object in the real world 
is that the properties of an object (like a person object) may change over time. 
Lists in Lisp work best when you are dealing with information that never changes once the list is created.

 그러나 Bob이 36살이 되었을때, 그의 age property를 바꿔야됩니다.
 When Bob turns 36, however, we need to change his age property.
 
Having part of a data structure change over time is called a mutation by 
computer scientists. It’s easy to change the value of a specific property (mutate the property) in a structure created with defstruct, so these structures are very suitable for handling data that needs to be mutable.

 Therefore, it makes sense to store a person (or any other object that changes over time) in a structure. 
We will be discussing the issue of mutation in greater detail in Chapter 14.

NOTE 

defstrcut기능은
Common Lisp에서 object를 만드는데만 사용할 수 있는 툴이 아닙니다.
예를들어, 책의 에필로그에서 여러분은 Common Lisp의 Common Lisp Object System(CLOS)가 매우 정교한 객체-기반 시스템을 만드는 것을 볼 수 있습니다.
만일 여러분이
강건한 객체-지향적 태도를 


If you care to code with a strongly object-oriented mindset, you will probably find all the OOP language functionality you need in Common Lisp.

 대신, CLOS는 많은 다른 곳에서 발견하지 못한 객체-지향적 기능의 이점을 가지고 있습니다

 이러한 이유로, CLOS는 OOP idea들을 공부하는 연구 도구로 자주 사용되어집니다.


Handling Data in a Generic Way

Common Lisp는 우아하고 효율적인 프로그램을 작성하기 위한 다양한 데이터형식을 지녔습니다.

 그러나 주의하지 않으면, 많은 데이터형식을 지닌것은 못생기고 반복되는repetitive code를 야기할 수 있습니다.

예를들어, list와 array에 저장된 몇몇 수를 더하기 원한다고 가정해봅시다
list와 array의 행동방식이 다르므로,
서로 다른 두가지 -하나는 list다른 하나는 array를 위한- 덧셈 함수를 작성할 필요가 있습니다.

단일 code 덩어ㅣ를 작성할 수 있을때
어떤 수가 저장되었는지 신경쓸 필요가 없을때
It would be great if we could write a single chunk of code to 
handle both cases without caring about how the numbers are stored.


 Common Lisp는 generic library 함수, type predicates, defmethod, 그리고 generic accessor를 포함하여, 여러분이 제네릭 code를 작성할때 필요한 모든 기능을 가졌습니다

#TOOD
 여러분은  
 여러분의 code에서 불필요한 prepetition없이
 많은 데이터 형식을 다루는 code를 작성할때 이 기능들을 사용할 수 있습니다
 We can use these features to write code that works with many types 
of data?including built-in as well as custom types that we might create with 
defstruct?without superfluous repetition in our code.


Working with Sequences


가장 쉬운 방법
code를 작성하는
 type-checking
The easiest way to write code 
that works with any type of argument 
is to hand the type-checking work to someone else.


Common Lisp 라이브러리들은 인자에 있는 다양한 종류의 data를 제네릭하게 다룰 수 있는 함수들로 가득차 있습니다.


 The sequence functions work generically across the three main ways of sequencing objects in Lisp: lists, arrays, and strings.

여러분은 이미 이러한 sequence function


length 함수.
You’ve already seen one of these sequence functions without even realiz-
ing it: the length function.


여러분은 세가지 sequence 종류의 길이를 확인하기 위해 length 함수를 사용할 수 있습니다:
[source]

 제네릭 length 함수가 없다면, 여러분은 문자열, 배열, list의 길이를 판별하기 위해 세개의 다른 함수들을 사용해야만 합니다.


NOTE

 Common Lisp는 list의 길이를 확인하는 특별한 함수 list-length를 가졌습니다

 왜냐하면 제네릭 함수는 정확한 행동을 결정하기 위해 추가 type-checking이 필요로 하는 경향이 있고, 실행시 느려질 수 있습니다.

#TODO
 list-length함수는 성능에 예민한 code에 유용하지만, 대부분의 Lisper들은 regular code에서 제네릭 length 함수를 사용합니다.



Sequence Functions for Searching

Some sequence functions let you search sequences:
z find-if finds the first value that satisfies a predicate.
z count finds out how often a certain object appears in sequence.
z position tells you where an item is located.
z some and every tell you if some or every value in a sequence obeys a specific 
predicate. 
Here are some examples:

[source]

In these examples, we use find-if to find the first number in a sequence, 
which is the number 5 X. We use count to find out how many times the char-
acter s appears in "mississippi" Y. We use position to find at what position 
the character 4 appears. In this case, it is in the fifth position, starting the count 
from zero Z. We use some to see if any items in a sequence are numbers. Indeed, 
there is a number [. Finally, we use every to see if every item in the list is a 
number, which is not the case \.
Sequence Functions for Iterating Across a Sequence
One particularly useful generic sequence function is reduce. The reduce func-
tion allows you to iterate through a sequence and distill it down into a single 
result. Here, we use reduce to add together items in a list:
[source]

The sum of those numbers turns out to be 20. Here is a 
diagram that shows exactly what is happening in this example:
On the right side, shown in gray, is our list. On the left 
side, you can see the pairs of numbers that are fed into the 
plus (+) function and the intermediate results that are calcu-
lated. This shows that the plus function always receives a single 
intermediate result as well as the next number in the list as its 
arguments. The only exception to this is in the very first call to the plus function. Since no intermediate result exists when we start, the 
first time we call the plus function, we promote the number 3, which is at the 
start of the list, into our intermediate result column. Therefore, the first time the 
plus function is called, it actually receives two items straight off the top of the list.
Let’s look at a slightly more complicated example, this time using our own 
reduction function. We’re going to find the largest even number in the list:
[source]

Our reduction function, which we pass to reduce to distill down our answer 
from the list, has two arguments X. The first argument is the best value we’ve 
found so far?in other words, the largest even number we’ve found so far. 
The second argument is the next number from the list.
Our reduce function needs to return as a result the new best number. 
Therefore, if the latest number is better than the previous best Y, we return 
it Z. Otherwise, we return the previous best [.
Remember that the first number in the list we’re reducing will be used as a 
starting value. If this is a problem, we can instead pass an explicit initial value to 
the reduce function by passing in a keyword parameter named :initial-value \.
Specifying an initial value for the reduce function is often necessary, or a 
bug can sneak into your code. In our example, it could allow an odd number 
at the front of the list to erroneously be deemed the best large even number. 
Let’s see what happens if we leave out the initial value.
[source]

Yes, things go horribly, horribly wrong, as a result of not specifying an 
initial reduce value.

Another great benefit of the reduce function is that it is generic, as is true 
for all these sequence functions. This means that it can reduce lists, arrays, or 
strings in exactly the same way, and you can use reduce to write functions that 
are oblivious to the difference between these different sequence types.
Earlier, I mentioned that it would be convenient to be able to write a 
single function that could sum together numbers in lists or arrays equally 
well. Now we can write such a function:

[source]
[pic]

sum is blissfully unaware of the difference between arrays and lists; it works 
on both. However, since addition doesn’t make any sense for characters, the 
sum function returns an error when used on a string.
Another function that is useful for iterating across a sequence is the map 
function. This function is identical in behavior to mapcar. However, unlike 
mapcar, the map function works on all sequence types, not just lists. You specify 
the type of sequence to return from the mapping by passing an extra argu-
ment to the map function.
Here is an example of map:
[source]

In this example, we’re turning every s character in a string to its uppercase 
version. The mapping function we pass into map simply checks if the current 
character is an s and returns the uppercase S if it is Y.
The result of this calculation is a list of characters Z. This is because we 
told the map function that we wanted a list as a result X. Had we asked for a 
string instead, a string would have been our result.
Two More Important Sequence Functions
The subseq function lets you pull a subsequence out of a larger sequence by 
specifying starting and ending points:
[source]
As you can see, the word america contains the name eric, starting from 
the second character and ending at the sixth character.
The sort function lets you pass it an arbitrary function to use for the sort-
ing. In this case, we’re just using the less-than (<) function:
[source]

There are many more sequence functions than we’ve discussed so far, 
but the examples in this chapter will get you off to a good start.
NOTE For a comprehensive list of sequence functions, and indeed all Common Lisp functions, 
visit the Common Lisp Hyperspec at http://www.snipurl.com/rz3h0?an 
exhaustive, but daunting, description of all Common Lisp has to offer.
Creating Your Own Generic Functions with Type Predicates
Common Lisp, like virtually all other Lisps, is a dynamically typed language. 
This means that parameters or variables in your code can hold any type of 
data?symbols, strings, numbers, functions, or whatever else you want to place in 
them. In fact, the same parameter or variable can even hold different types 
of data at different times in a running program.
Therefore, it makes sense to have a bunch of functions that tell you whether 
a variable has a certain type of data in it. For instance, you can check whether 
you have a number with numberp:
[source]

The type predicates you will probably use most frequently are arrayp, 
characterp, consp, functionp, hash-table-p, listp, stringp, and symbolp.

You can use type predicates to write functions that handle different types 
of data generically. Suppose we wanted to write a function that lets us add 
both numbers or lists. Here’s one way we could write such a function:

[source]

In this add function, we use predicates to see if the arguments passed in 
are numbers or lists, and then we act appropriately. If we aren’t given two 
numbers or two lists, it simply returns nil.
Although you can write functions supporting multiple types of data using 
type predicates, most Lispers wouldn’t write an add function this way, for the 
following reasons:
A single, monolithic function for all types: This is fine for just two types, 
but if we wanted to handle a dozen or more types, our function would 
quickly turn into a giant monstrosity.
Modifications required to accommodate new cases: We would need to 
change the add function whenever we want to support a new type, 
increasing the chance that we would break existing code. Ideally, we 
would like to handle each new situation by itself without touching 
already working code.
Hard to understand: It is hard to see exactly what the main cond state-
ment is doing and if the types are all being routed to the right place.
Performance: The resulting function might be slow. For instance, a Lisp 
interpreter/compiler might be able to create faster code for appending 
two lists if it knew for sure that both items were lists when the appending 
happens. However, in our first attempt at the add function, the type of 
the two arguments is never really completely obvious. Our compiler would 
need a bit of smarts to be able to tell from the condition (and (listp a) 
(listp b)) that both variables are guaranteed to be lists. Life would be 
easier for the compiler if we explicitly stated the types of arguments for 
each type situation.
Because it is so useful to be able to have a single function that does differ-
ent things when given certain datatypes, the Common Lisp command defmethod 
lets us define multiple versions of a function that each supports different 
types. When that function is called, Lisp checks the argument types at the 

time of the call and chooses the correct version of the function automati-
cally. The proper term for having a compiler/interpreter choose among dif-
ferent versions of a function based on argument types is type dispatching.
Here’s how we would write our add function using defmethod:
[source]

As you can see, this version of the add function handles every type of situ-
ation with a separate function, and new cases can be added without modifying 
existing code. Overall, the code is much easier to understand. Also, the compiler 
can see the type of the parameters and may be able to write faster code using 
this knowledge.
The defmethod function is like defun, except that it allows us to write multiple 
functions with the same name. When using defmethod, we can explicitly state 
the type of each parameter in the function’s argument list so that Lisp can 
use these type declarations to figure out the correct version of add for each 
situation.
If you’re familiar with the world of OOP, the word method probably has a 
special meaning to you. Since this new command is called defmethod, does it 
have anything to do with OOP? In short, yes. This command can be used not 
only with Common Lisp’s built-in types, but also with structures you’ve cre-
ated with defstruct. The combination of defstruct and defmethod basically con-
stitutes a simple object system.
Now we’ll use this object system to write a game!

