WORKING WITH STREAMS
12.스트림과 함께 작업하기

 어느 시점에서 여러분이 작성하는 거의 모든 컴퓨터 프로그램은 바깥세상과 상호작용해야 할 것입니다. 아마도 여러분의 프로그램은 정보를 출력하고 키보드에서 사용자의 입력을 받아오는 REPL을 통해 사용자와 소통해야 합니다. 또다른 프로그램은 아마 하드드라이브에서 파일을 읽거나 써야할 것입니다. 덧붙이자면, 여러분은 아마 로컬 네트워크나 인터넷을 통해 다른 컴퓨터와 상호작용하는 프로그램을 작성하기 원할 것입니다. Common Lisp에서, 이러한 상호작용은 stream을 통해 일어납니다.


 stream은, 외부 자원을 취하여 여러분 코드에서 조작할 수 있도록 다른 단순한 데이터 조각으로 만들어주는, Common Lisp의 데이터 형식입니다. 외부 자원은 다양한 것이 될 수 있습니다: 디스크의 파일, 다른 컴퓨터의 네트워크, 혹은 화면에 있는 콘솔윈도우의 텍스트. 이번장에서 여러분이 배우는 동안 Lisp 프로그램은, 마치 리스트나 해쉬테이블처럼, stream을 사용하여 이 외부 자원과 쉽게 상호작용 할 수 있습니다.


Types of Streams
 Common Lisp 프로그램에서 외부 자원과 소통할때에는 stream을 이용합니다. 다양한 자원 타입에 따라 다양한 stream의 타입이 가능합니다. 또 다른 요소는 stream의 방향입니다 - 때때로 여러분은 자원에 데이터를 쓰기를, 데이터를 읽기를 원합니다.


Streams by Type of Resource
[pic]
 자원을 동작하는 방식으로 분류할때, 다음 나오는 것들은 가장 일반적으로 사용되는 stream 타입입니다:

Console streams REPL과 소통하면서 오랫동안 사용해왔던 것.
File streams 하드드라이브에 파일을 작성하거나 읽을수 있도록 함.
Socket streams 네트워크에 있는 다른 컴퓨터와 소통할 수 있도록 함.
String streams Lisp string으로부터 텍스트를 보내거나 받도록 함.

 이러한 stream 타입의 string stream은 골칫덩어리(the black sheep of the family)입니다. string stream은, 바깥세상과 소통하는 것보다, 새롭고 흥미로운 방법으로 string을 조작할 수 있도록 합니다.


Streams by Direction
 resource에 데이터를 작성할때, 출력 스트림을 이용합니다. resource로부터 데이터를 읽기 위해선, 입력 스트림을 이용합니다.


Output Streams
 출력 스트림은 REPL에 출력하고 파일을 작성거나, 소켓을 통해 정보를 보내는 작업을 할때 이용합니다. 가장 원초적인 레벨에서 출력 스트림과 두가지 일을 할 수 있습니다:

z 어떤 스트림이 유효한지 확인하기.
z 스트림에 새로운 항목을 넣기.
[pic]

 보시다시피, 스트림은 Lisp의 true data structure보다 더욱 제한적입니다. 예를들어, 리스트는 스트림과 동일한 모든 기능들을 지원하며 (push로 리스트에 새로운 항목을 집어넣을 수 있으며 리스트가 유효한지 listp로 확인할 수 있습니다), 리스트로 출력 스트림으로 할 수 없는 작업(setf로 리스트의 항목을 바꾸는 것과 같은)을 할 수 있습니다. 그러나 이러한 스트림의 제한된 기능이 실제로 많은 경우에 있어 유용합니다.

 유효한 출력 스트림을 가졌는지 확인하기 위해, output-stream-p 함수를 사용할 수 있습니다. 예를들어, REPL은 *standard-output*이라 불리는 출력 스트림을 가졌습니다. 다음 코드로 이것이 유효한 출력 스트림인지 확인할 수 있습니다:
[output]

 Lisp character는 기본 write-char 명령어를 사용하여 출력 스트림에 집어 넣을 수 있는 하나의 항목입니다. 예를들어, 문자 #\x를 *standard-output* 스트림에 출력하기 위해, 다음 명령어를 실행할 수 있습니다:
[output]

 이 코드는 표준 출력에 x를 출력합니다(이번 경우에, 이것은 REPL과 같습니다). 동일한 라인에 출력된 x와 반환된 값의 원인으로 이 함수는 또한 nil을 반환합니다. 6장에서 보았듯이, 이 추가 nil은 REPL에서 동작하는 코드의 side effect입니다. 이 명령어를 큰 프로그램의 일부로 실행하였다면, x만 출력될 것입니다.

NOTE
 이번 장에서, 오직 텍스트 문자에 기반한 스트림만 다룰 것입니다. Common Lisp에서는 또한 다른 데이터 타입에 기반한 스트림 만들 수 있습니다. 예를들어, 바이너리 데이터 작업을 한다면, 문자 대신에 raw 바이트를 보내거나 받기를 원할 것입니다. 그러나, 저희 목적에서 textual 데이터를 다루는것이 가장 편리합니다.


Input Streams
 입력 스트림은 데이터를 읽을때 사용됩니다. 출력 스트림처럼 입력 스트림으로 수행할 수 있는 행동은 제한적입니다. 가장 원초적인 레벨에서 여러분은 입력 스트림으로 두가지 일을 할 수 있습니다:

z 스트림이 유효한지 확인하기.
z 스트림에서 항목을 꺼내오기.

 input-stream-p 명령어로 유효한 스트림을 가졌는지 확인할 수 있습니다. 예를들어, 표준 출력과 같이, REPL은 다음처럼 검증할 수 있는 *standard-input* 입력 스트림을 가졌습니다:
[output]
[pic]

 read-char 명령어로 스트림에서 하나의 항목을 꺼내올 수 있습니다. REPL에서 읽어오므로, 몇몇 문자들을 쳐서 ENTER를 눌러 데이터를 표준 입력 스트림으로 보내야 합니다:
[output]

 보시다시피, 스트림 앞의 1이 read-char에 의해 꺼내졌고 반환되었습니다.


[box
USING OTHER COMMANDS TO INTERACT WITH STREAMS
 write-char와 read-char뿐만 아니라, Common Lisp는 스트림과 소통하기 위한 많은 다른 명령어들을 가졌습니다. 사실, 6장에서 소개된 출력과 읽어오는 모든 명령어는 스트림을 추가 인자로 받을 수 있습니다. 예를들어, 다음처럼 명시적으로 print 명령어에게 *standard-output*에 출력하라고 할 수 있습니다:

> (print 'foo *standard-output*) 
FOO

 이것은 *starndard-output*말고 곧 보게 될 다른 스트림과 작업할때 유용합니다.
]


Working with Files
 REPL에서 읽고 쓰는데 스트림을 사용한 것처럼, 파일에 쓰고 읽는데 스트림을 사용할 수 있습니다.

 Common Lisp에서 다양한 방법으로 파일 스트림을 생성할 수 있습니다. 가장 좋은 방법은 with-open-file 명령어를 사용하는 것입니다. 곧 보게될 것처럼, 이 명령어는 다른 가능한 파일 명령어보다 사용이 안전한, 특별한 버그-방지 기능을 지녔습니다. 다음 예제는 문자열 "my data"를 data.txt 파일에 작성하기 위해 with-open-file를 사용하였습니다:
[output]

 이번 예제에서, with-open-file 명령어는 출력 스트림와 my-stream을 bind하였습니다. my-stream란 이름의 파일 출력 스트림을 만듭니다. 이 스트림은 with-open-file 명령어 내에서 사용이 가능하며(마지막 닫음 괄호 전까지), 이 스트림에 보내는 데이터는 디스트의 data.txt로 가게됩니다. print 명령어는 my-stream을 이 출력의 목적지로 참조합니다. 그러므로 이 예제가 끝난 후에, 여러분은 CLISP를 실행시킨 폴더에서 새로운 data.txt를 찾을 수 있습니다. 이 파일은 텍스트 "my data"를 포함하고 있습니다.

 with-open-file의 방향으로 :output을 지정하여 출력 스트림을 생성하였습니다.  이를 입력 스트림이 대신하게 만들려면, 다음처럼 :input으로 방향을 바꿀 수 있습니다:
[output]

 보시다시피, 파일에서 데이터- 이전 예제에서 쓰여진 파일과 동일한 데이터 -를 읽어오도록 합니다.

 6장에서 배웠던 것처럼, print와 read명령어는 기본 Common Lisp 데이터 형식을 읽거나 쓸 수 있습니다. 이러한 기능은, 하드드라이브로 여러분의 프로그램의 데이터를 저장하는데 이용하는, 스트림을 쉽게 이용하게 해줍니다. 여기 연관 리스트(alist)를 파일에 쓰는 더욱 복잡한 예제가 있습니다:
[output]

 이번 예제에서, 동물과 그 소리의 연관 테이블을 생성하였습니다. 새로운 animal-noises란 alist를 생성하였습니다. key로 dog와 cat를 이 리스트에 넣었습니다. 이제 이 alist를 새로운 animal-noises.txt파일에 작성할 수 있습니다. 나중에, 저희는 쉽게 파일로부터 이 alist를 재구성 할 수 있습니다.

 with-open-file 명령어는 이것의 행동을 수정하는 키워드 인자를 취합니다. 예를들어, 주어진 이름의 파일이 이미 존재한다면 어떻게 할건지 이 명령어에게 알릴 수 있습니다. 다음 예제에서, :if-exists 키워드 인자를 사용하여 에러 메시지를 출력할 것입니다:
[output]

 아니면,  단순히 이미 존재하는 파일을 덮어 쓰기 원할지도 모릅니다. 이러한 경우에는, 다음처럼 :if-exists 키워드 인자를 :supersede로 설정합니다.
[output]

 with-open-file 명령어는 파일과 작업할 매우 간결한 방법을 제공합니다. 대다수의 프로그래밍 언어와는 달리, 이 명령어를 사용할때, 수동으로 파일을 열고 닫을 필요가 없으며, 잠제적으로 여러분의 파일이 적절하게 닫혀지지 않아서 망가지는것에 대해 걱정할 필요가 없습니다. (실제로, Common Lisp는 파일을 열고 닫기 위한 하위-레벨 명령어를 가졌지만, with-open-file는 모든 못생긴 세부사항을 숨기는 깔끔한 방식으로 그들을 포장package하였습니다.)
[pic]

 with-open-file의 주요 목적은 파일 자원을 얻는 것입니다. 이것은 파일의 명령어를 취해 이것을 닫는 책임을 맏습니다. 사실 with-open-file 코드 내부에서 프로그램이 죽어 멈추는 흉한 에러를 던질지라도, with-open-file은, 이 자원이 온전한 상태로 유지시키기 위해, 파일을 적절하게 닫을 것입니다.

NOTE
 Common Lisp는, 이와 같은 방법으로 자원을 안전하게 할당하는, with-로 시작하는 많은 명령어들을 가졌습니다. core Lisp 라이브러리에서 이용가능한 이 with- 명령어들은 Lisp의 굉장한 매크로 시스템으로 만들어졌습니다. 16장에서 Lisp 매크로에 대해 더 배울 것이며, 어떻게 여러분만의 with- 명령어를 만드는지 배울 것입니다.


Working with Sockets
[pic]
 저희는 REPL이나 파일과 소통하는 스트림을 사용하였고, 이제 그것을 사용하여 어떻게 다른 컴퓨터와 소통할수 있는지 봅시다.

 여러분이 표준 네트워크상(오늘날 대부분 모든 네트워크 TCP/IP 프로토콜을 사용합니다)에 있는 다른 컴퓨터와 소통할 수 있는 프로그램 작성을 원한다면, 우선 소켓을 만들어야 합니다. 소켓은, 네트워크 상에 있는 다른 컴퓨터들 사이에서 컴퓨터 네트워크를 통해 데이터를 보내는 메커니즘입니다.

 불행히도, 소켓은 ANSI Common Lisp 표준으로 들어서질 못했고, 이는 소켓으로 소통하는 표준 방식이 없다는 것을 의미합니다. 그러나, 표준을 따르지 않을 지라도 Common Lisp의 모든 버전은 소켓을 지원합니다. 이 책에서 CLISP를 이용하기 때문에, CLISP의 소켓 명령어만 고려할 것입니다.

NOTE
  Common Lisp의 표준 소켓 라이브러리로 추가하려는 두가지 시도로 cl-sockets (http://common-lisp.net/project/cl-sockets/)과 usocket (http://common-lisp.net/project/usocket/)가 있습니다.


Socket Addresses
 모든 네트워크와 소켓은 소켓 주소를 가져야만 합니다. 이 소켓 주소는 두가지 요소를 지닙니다:

IP 주소
 네트워크 상에서 컴퓨터를 판별하는 (192.168.33.22처럼 전통적으로 4바이트마다 점이 찍힌(IPv4))고유한 번호.

Port 번호
 네트워크를 사용하기 원하는 프로그램은 동일한 컴퓨터에서 어떠한 프로그램도 사용하지 않은 고유한 포트 번호를 선택해야 함.

 IP 주소와 port 번호가 결합하여 소켓 주소를 구성합니다. IP 주소가 네트워크 상에서 고유하고 port 번호가 주어진 컴퓨터에서 고유하기 때문에, 특정 컴퓨터에서 돌아가고 있는 특정 프로그램에 대해 네트워크 상의 모든 소켓 주소는 고유합니다. (TCP 패킷이라 불리는 데이터 덩어리를 통해) 네트워크상에 떠도는 메시지는 목적지를 나타내는 소켓 주소가 붙어있습니다.

 컴퓨터가 IP 주소가 붙여진 패킷을 받으면, 운영체제는 메시지의 소켓 주소에 있는 port 번호를 보고 어떤 프로그램이 이 메시지를 받는지 알아냅니다. 그러면 어떻게 운영 체제가 주어진 포트로 메시지를 받는 프로그램이 어떤건지 알 수 있을까요? 프로그램을 사용하기 위해, 그 포트를 위한 소켓을 우선 만들기 때문에 알수 있습니다. 다시 말하자면, 소켓은 컴퓨터 프로그램이 운영체제에게 말하는 단순한 방법입니다, "이봐, port 251 메시지를 받으면, 내게 줘!".


Socket Connections
 두 프로그램 사이에서 소켓을 통해 실제 메시지를 보내기 전에, 우선 소켓 연결을 초기화시키기 위해 몇몇 단계를 따라야 합니다. 연결을 하기위한 첫번째 단계는, 프로그램중 하나가 리스닝 상태에서 다른 프로그램 소통하기 원하는 네트워크상 다른 프로그램이 있는지 기다리는, 소켓을 만들도록 하는 것입니다. 리스닝 상태에 있는 소켓을 지닌 컴퓨터를 서버라 부릅니다. 그리고 클라이언트라 불리는 다른 프로그램은 소켓을 만들고 서버와 연결을 구성하는데 사용합니다. 모든 과정이 잘되면, 이 두 프로그램은 이제 소켓 연결을 통해 메시지를 전송할 수 있게 됩니다.

 예기는 이제 충분합니다. 마법과도 같은 일을 보기위해 지금 당장 두 프로그램을 연결connecting해 봅시다!


Sending a Message over a Socket
 우선, 여러분의 컴퓨터에서 서로 다른 두 콘솔 윈도우에 두 CLISP의 복사본을 띄웁니다. 하나는 클라이언트 다른 하나는 서버라 부를 것입니다.(혹은, 동일한 네트워크상에 있는 두대의 컴퓨터를 가졌고 IP를 안다면, 두 머신에서 각각 콘솔을 띄워도 됩니다.)

NOTE 이번 장에서 나온 소켓코드를 동작시키려면, CLISP를 사용해야합니다.

 서버에서, socket-server라 불리는 컨트롤 포트를 취합니다:
[output]

 이 명령어는 포트 4321을 획득하고 소켓을 운영체제와 결합시킵니다. 이 소켓은 my-socket 변수와 엮여졌으므로 저희는 이것으로 소통할 수 있습니다.

 이 명령어는 다소 위험한데, 운영체제는 저희가 이와 관련된 일을 마치면 소켓을 넘겨준다고 예상하기 때문입니다. 그렇지 않으면, 누구도 이 소켓을 더이상 사용할 수 없습니다. 사실, 이 소켓 연습을 하는 동안 실수를 저지르면,  컴퓨터를 재부팅하기 전에는 포트 4321의 소켓이 먹통이되어, 다른 포트로 바꿔야 합니다. (다음 장에서, Common Lisp에서 이런 괴상한 문제에 관해 어떻게 예외 처리 시스템을 사용하는지 배울 것입니다.)

 다음으로, 단일 클라이언트로부터 연결을 조작할 이 소켓으로부터 스트림을 만듭시다:
[output]

 이 명령어를 실행하면, 서버는 멈춘것처럼 보이며, REPL 프롬프트로 돌아오지 않게 됩니다. 놀라지 마시라 - socket-accept명령어는, 클라이언트가 접속하기 전까지 함수를 빠져나가지 않는, 블로킹 연산입니다.

 이제 여러분의 CLISP 클라이언트로 돌아와서, socket-connect 명령어를 사용하여 서버에 있는 소켓과 연결합니다:
[output]

 IP 주소 127.0.0.1은 항상 이것을 호출한 컴퓨터를 가리키는 특별한 주소입니다. 이번 예제에서 다른 두개의 컴퓨터를 사용한다면, 여러분의 서버의 실제 IP 주소를 입력해야 합니다.

 이 명령어가 실행된 후에는, 서버는 unlock될 것이며, my-stream 변수의 값이 설정될 것입니다. 이제 CLISP의 두 복사본에서 스트림을 열었으며, 둘사이에서 소통communicate하는데 이것을 사용할 수 있게 되었습니다.

 여기서 CLISP가 만든 스트림을 양방향bidirectional 스트림이라 합니다. 입력 스트림과 출력 스트림처럼 행동할 수 있다는 것을 의미하며, 양방향 소통하기 위해 이에 관한 각 명령어 집합set을 이용할 수 있습니다. 클라이언트와 서버에서 다정한 환영 메시지를 보내봅시다.

 다음을 클라이언트에 입력합니다:
[output]

 그리고 서버에 다음을 입력합니다:
[output]

 그런 다음, 다시 서버에 다음을 입력합니다:
[output]

 클라이언트로 돌아와서, 다음 명령어를 실행합니다:
[output]

 끝마쳤을때 두 CLISP 윈도우는 다음처럼 보일 것입니다:
[pic]
[pic]

 소켓을 통해 여러분이 보낸 메시지는 Lisp 문자열이였지만, Lisp의 우아한 스트림-처리 능력으로, 어떠한 추가 노력없이 동일한 방식으로 어떠한 표준 Lisp 데이터 구조라도 보낼 수 있습니다!


Tidying Up After Ourselves
 이번 예제에서 저희가 생성한 자원을 되돌리는 것은 중요합니다. 우선, 스트림을 닫기 위해 클라이언트와 서버 모두에서 다음 명령어를 실행합니다:
[output]

 다음, 포트를 놔주고 소켓연결을 끊기위해 서버에서 socket-server-close를 실행시킵니다. 그렇지 않으면, 포트 4321은 재부팅하기 전까지 사용하지 못할 것입니다.
[output]


String Streams: The Oddball Type
 스트림은 보통 리스프 프로그램에서 바깥세상과 소통할때 사용됩니다. 하나의 예외가 있다면 단순히 문자열을 스트림과 비슷하게 보이도록 만든 문자열 스트림string stream입니다. 다른 타입의 스트림으로 외부 자원을 읽거나 쓰는 동일한 방법으로, 문자열 스트림은 문자열을 읽거나 씁니다.

 make-string-output-stream과 make-string-input-stream 명령어로 문자열 스트림을 만들 수 있습니다. 다음은 make-string-output-stream을 사용한 예제입니다:
[output]

 이미 여러분은 스트림 사용없이 Lisp에서 문자열을 직접적으로 다룰수 있기 때문에, 왜 누가 이러한 일을 원했는지 혼란스러울 것입니다. 사실, 이러한 방식으로 문자열 스트림을 사용하는 데에는 몇몇 중요한 이유가 있습니다. 그것은 디버깅할때 유용할 뿐만아니라, 복잡한 문자열을 효율적으로 만듭니다.


Sending Streams to Functions
 문자열 스트림을 사용하는 것은 스트림을 인자로 요하는 함수를 사용할 수 있도록 합니다. 이는 파일이나 소켓을 지니지만 데이터를 입력과 출력하는데 문자열만 이용하는 코드를 디버깅할때 좋습니다.

 예를들어, 스트림에 로그 정보를 쓰는 write-to-log 함수를 가졌다고 가정해 봅시다. 보통, 로그 정보를 파일 스트림에 보내길 원할것이며, 안전하게 파일에게 쓸 것입니다. 그러나, 이 함수를 디버깅하기 원한다면, 대신 이것을 문자열 스트림에 보내기 원할 것이며, 따라서 여러분은 이것이 쓴 데이터를 볼 수 있을 것이며 정확한지 확신할 수 있을 것입니다. 오직 파일에만 쓰는 하드-코어한 write-to-log 함수를 지녔다면, 이러한 유연성을 갖지 못할것입니다. 이것이 외부 자원에 접근하는 다른 메소드를 사용하는것 대신에, 가능하다면 스트림의 추상적인 컨셉을 이용해 함수를 작성해야만 하는 이유입니다.


Working with Long Strings
 매우 긴 문자열을 처리할때 문자열 스트림은 더 좋은-성능의 코드를 이끌 수 있습니다. 예를들어, 두 문자열을 서로 합치는 것은 값비싼 작업이 될 수 있습니다
- 우선, 두 문자열을 붙잡아 놓기 위한 새로운 메모리 블럭의 할당이 요구되며, 문자열은 이 새로운 장소로 복사되어야만 합니다. 이러한 병목현상으로, 많은 프로그래밍 언어들은 이러한 오버헤드를 피하기 위해 string builder라 불리는 장치를 사용합니다. Lisp에서는, 문자열 스트림을 사용하여 유사한 성능 이점을 얻을 수 있습니다.


Reading and Debugging
 문자열 스트림을 사용하는 또다른 이유는, with-output-to-string 매크로를 사용할때 특히, 코드를 읽기 쉽고 디버깅하기 쉽도록 만들어 주기 때문입니다.
[pic]

 여기 그 명령어를 사용한 예제가 있습니다:
[output]

 with-output-to-string 매크로는 콘솔, REPL, 혹은 다른 출력 스트림으로 출력되는 텍스트를 가로채서 문자열로 잡아둡니다. 이전 예제에서, with-output-to-string내부에서 princ 함수에 의해 생성된 output이 자동적으로 문자열 스트림으로 방향이 바뀌었습니다. with-output-to-string명령어가 완료되면, 결과로 전체 출력된 output이 스트림에 보내져 결과로 반환됩니다.

 또한 with-output-to-string를 사용하여 각 부분을 "출력하고" 문자열로 잡아서 복잡한 문자열을 쉽게 구성할 수 있습니다. 이는 concatenate 명령어를 사용한 것보다 더 우아하고 효율적으로 되는 경향이 있습니다.


NOTE 
 with-output-to-string을 이용하는 것은 (14장에서 다룰)함수형 프로그래밍의 교리를 거스릅니다. 어떤 Lisper들은 이 함수(그리고 유사한 다른 목적지를 향하는 입력과 출력을 가로채는 함수)를 흉칙한 hack으로 간주합니다. 여러분은 Lisp 커뮤니티에서 with-output-to-string의 사용이 우아한지 흉칙한지에 관해 의견 다툼이 있는 것을 보실 수 있습니다.


What You’ve Learned
 이번 장은 외부 자원과 소통하기 위해 어떻게 스트림을 사용하는지를 설명하였습니다. 여러분은 다음 내용을 배웠습니다:

z 다양한 종류의 스트림은 다양한 자원의 종류와 소통한다. 이는 콘솔 스트림, 파일 스트림, 소켓 스트림, 그리고 문자열 스트림을 포함합니다.

z 스트림은 그 방향에 기반하여 분류될 수 있다. 출력 스트림은 자원에 쓸 수 있도록 합니다. 입력 스트림은 자원으로부터 읽도록 합니다.

z 소켓 스트림은 컴퓨터 프로그램들이 네트워크를 통해 소통할 수 있도록 한다. 소켓 스트림을 구성하기 위해, 우선 양쪽 끝의 소켓을 열고 프로그램 사이의 소켓 연결을 엽니다.

z  문자열 스트림은, 디버깅 목적으로 외부 자원과 링킹 없이, 스트림을 요구하는 함수를 사용할 수 있다. 또한 with-output-to-string를 이용하여 문자열을 효율적이며 우아하게 구성하는데 있어 유용합니다.