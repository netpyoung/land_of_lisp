LET’S CREATE A WEB SERVER!
13. 웹서버를 만들어 봅시다!


 6장에서 저희는 REPL에서 어떻게 텍스트를 보내어 사용자와 소통하는지를 배웠습니다. 그러나, 오늘날 "사용자와 소통하는 것"에 대해 예기할 때에는, 보통 웹에서의 사용자를 말합니다. 이번 장에서, 웹 서버를 처음부터 구축하여 웹에서 어떻게 사용자와 소통하는지 배울 것입니다. 네트워크상에서 소통하는 것은 환경에 의해 에러가 발생하기 쉬우므로, 에러를 Lisp에서 어떻게 처리하는지를 우선 배울 것입니다.


Error Handling in Common Lisp
 외부 세계와 소통할때, 여러분의 웹 서버에서 예상치 못한 일이 발생할 수 있습니다. 아마 현대 컴퓨터 네트워크가 아무리 똑똑해지더라도, 모든 가능한 예외 상황을 예측할 수 없을 것입니다. 어쨋든, 아무리 똑똑한 네트워크라 할지라도 잘못된 캐이블에서 발상된 문제로부터 복구할 수 없습니다.

 Common Lisp는 여러분의 코드에서 예상치 못한 상황을 처리하는 매우 포괄적인 기능 집합set을 지녔습니다. 이러한 예외 처리 시스템은 매우 유연하여, 다른 대다수의 언어에서의 예외 시스템에서 불가능한 일도 처리할 수 있습니다.


Signaling a Condition
 함수를 작성했는데 무언가 엄청나게 잘못된 방향으로 간다면, Lisp함수는 Lisp 환경에게 문제가 발생하였다는 것을 통지할 수 있습니다. 이는 condition을 신호로 보냄으로써 수행됩니다. 문제가 발생할 수 있는 종류에는 무엇이 있을까요? 0으로 나누려는 함수일지도 모릅니다. 혹은 잘못된 타입의 인자를 받는 라이브러리 함수일지도 모릅니다. 아니면 네트워크 케이블이 꼬여서 소켓 커뮤니케이션이 방해받는 경우일 것입니다.

 직접 conditon을 신호로 보내려면, error명령어로 할 수 있습니다. 여러분이 작성한 함수에서 문제가 발생하면 이러한 일을 해야 합니다 - 매우 심각 문제의 프로그램은 정상적으로 동작하지 못합니다. error 명령어를 사용하면, 다른 곳에서 인터럽트를 예방하기위해 에러를 가로채지 않는 한, 동작하고 있는 Lisp 프로그램을 중단시킬 것입니다. condition을 신호로 보내고, 에러를 기술하기 위해 "foo"메시지를 출력해봅시다:
[REPL]

 보시다시피 이 condition을 신호로 보내어, Lisp가 저희 프로그램을 멈추었으며, "foo"를 출력하고, REPL에서 에러 프롬프트를 출력하였습니다. (CLISP에서, 프로그램을 abort하기 위해 :a를 입력하여 REPL로 돌아갈 수 있습니다.) 여러분의 프로그램이 condition을 신호로 보내는 대부분은, 아마 여러분 스스로 error를 호출해서 그러한게 아닐 것입니다. 대신, 여러분의 프로그램이 버그를 지녔거나 라이브러리 함수를 호출하거나, 함수가 condition을 신호로 보낼때 그러할 것입니다. 그러나, 어떤 무언가가 condition을 유발하여 프로그램의 정상적인 실행을 정지시킨다면, 프로그램은 멈추어 이전 예제와 같은 error 프롬프트를 보일 것입니다.


Creating Custom Conditions
 저희 첫번째 예제에서, condition을 기술하기 위해 error 명령어에 문자열을 넣었습니다. 그러나, 이 텍스트 문자열은 에러 메시지를 단지 수정만하며, 다른 condition의 "타입"을 이끌 수는 없습니다. Common Lisp는 다양한 방식으로 다룰 수 있는 다양한 condition의 타입 또한 가지고 있습니다.

 더욱 정교하게 condition을 신호로 보내는 방법으로는, 다음 예제에 나와 있는 것처럼 define-condition을 이용하여 custom condition을 우선 정의하는 것입니다:
[REPL]

 이는 새로운 타입의 condition을 생성하는 전형적인 예이며, foo라 이름 지었습니다. 이 condition이 신호를 받으면, error를 보고하기 위해 호출되는 custom 함수를 제공할 수 있게 됩니다. 여기서, 저희는 이러한 목적을 위해 lambda 함수를 선언하였습니다. lambda함수에서 에러를 보고하기 위해 custom 메시지를 출력합니다.

 이 새로운 condtion이 발생하였을때 어떤 일이 펼쳐지는지 확인해 봅시다:
[REPL]

 보시다시피, 저희 custom 메시지가 출력되었습니다. 이 기술은 프로그래머가 발생한 특정 condition에 맞추어 더욱 의미있는 error 정보를 얻도록 해줍니다.


Intercepting Conditions
 defien-condition으로 condition을 생성하였을때, (foo와 같은)이름이 주어졌습니다. 이 이름을 condition을 다루고 가로체기 위해 프로그램의 상위-레벨 부분에서 이용할 수 있으며, 따라서 프로그램의 실행을 중지시키지 않습니다. 이러한 일을 다음처럼 handler-case 명령어로 할 수 있습니다:
[REPL]

 hanlder-case 명령어 안쪽에 넣은것중 처음에 나온것은, 저희가 다루기 원하는 condition을 신호로 보내는 코드 조각입니다.

 이번 예제에서, 저희가 관찰할 코드는 bad-function 입니다. hanlder-case 나머지부분에서는, 특정 condition이 발생하면 지정된 행동을 수행합니다. 이 코드가 동작하면, bad-function은 (error 'foo)를 호출하여 foo condition 신호를 보냅니다. 보통, 이는 저희프로그램을 중단시켜 REPL에 error 프롬프트를 야기시킵니다. 그러나, 저희 handler-case 명령어는 foo condition을 가로챕니다. 이는 handler-case가 "some-body signaled foo!"로 평가하여, 프로그램이 중단되지 않고 계속 동작하는 것을 의미합니다.


Protecting Resources Against Unexpected Conditions
 프로그램에서 예상치 못한 exception이 발생하면, 거기에는 항상 프로그램을 다운시키거나, 외부 자원에 타격을 입힐지도 모르는 위험이 뒷따릅니다. exception은 코드의 정상적인 흐름을 방해하며, 심지어 민감한 작업중에도 여러분의 코드를 멈추게 할 것입니다.

 예를들어, 예상치못한 exception이 발생하였을때, 프로그램이 파일이나 소켓 스트림에 쓰는 작업을 하고 있을지도 모릅니다. 이러한 경우, 프로그램이 파일/소켓 스트림을 닫고 파일 핸들이나 소켓을 해제하기 위한 기회를 갖는것은 상당히 중요합니다; 그렇지 않으면, 이 자원은 정의되지 않은 체로 잠겨lock버릴 것입니다. 이와 같은 자원이 적절하게 해제되지 않으면, 사용자는 자원을 다시 이용하기 전에 우선 컴퓨터를 재부팅 해야할 것입니다
 
 unwind-protect 명령어는 이러한 문제를 피하는데 도움이 됩니다. 이 명령어는, 여러분이 "이 코드 조각은 어떠한 경우라도 아무 문제 없이 돌아가야 한다"고 Lisp compiler에게 말할 수 있도록 해줍니다. 다음 예제를 잘 보시기 바랍니다:
[REPL]

 unwind-protect에서, condition을 신호로 보내도록 0으로 나누었습니다. 그러나 CLISP에게 abort라 말한 후에도, 중요한crucial 메시지를 출력합니다.

 Common Lisp의 "with-" 매크로에 의존함으로써 unwind-protect를 직접 사용하는 작업을 피할 수 있습니다. 16장에서, 어떻게 이게 가능한지 살펴보기 위해 저희만의 매크로를 만들 것입니다.

NOTE
 이 책의 마지막 부분에 있는 만화 에필로그에서, restarts라 불리는 Common Lisp의 추가 기능 signaling system에 대해 배울 수 있습니다.


Writing a Web Server from Scratch
 이제 소켓과 error 처리에 대한 기본 이해를 지녔으므로, Lisp로 작성된 동적 웹 페이지를 서비스하는 웹 서버를 만들기에 충분합니다. 어쨋든, 왜 Apache(세계에서 가장 유명한 웹 서버)가 이런 재미있는 일들을 해야만 할까요?


How a Web Server Works
 Hypertext Transfer Protocol, 혹은 HTTP는 웹페이지를 전송하는데 사용되는 Internet protocol입니다. 소켓 연결이 성사되면 페이지 요청을 위해 TCP/IP 상단에 레이어가 추가될 것입니다. 클라이언트 컴퓨터에서 돌아가고 있는 프로그램이 적절히 부호화된 요청을 보낸다면, 서버는 그 요청된 페이지를 찾아서 응답으로 그것을 소켓 스트림을 통해 보낼 것입니다.
[PIC]

NOTE
 이 웹 서버는 Ron Garret이 만든 http.lisp를 채택하였습니다.

 예를들어, 클라이언트가 Firefox 웹 브라우저라 가정하면, 페이지 lolcats.html를 요구할 것입니다. 클라이언트의 request는 다음과 같을 것입니다:
[REPL]

 저희 웹 서버에서, 이 request의 가장 중요한 부분은 첫번째 라인입니다. 여기서 request의 종류(GET request는, 이것을 수정하지 않고 페이지를 살펴보기 원한다는 것을 의미합니다)와 요청된 page(lolcats.html)의 이름을 확인할 수 있습니다. 서버에게 보내진 이러한 데이터를 request header라 합니다. 나중에 여러분은, request header아래 request body에서 서버로 보낼 수 있는 추가 정보를 보게될 것입니다

NOTE
 머나먼 미래에서 온 독자들를 위해, lolcats(웃긴고양이)는 B.C 3000년경 바이러스성의 인터넷 현상입니다. 이는 고양이의 재미있는 사진을 포함합니다. 여러분과 친한 사람들이 더 이상 lolcats와 친숙하지 못하게 된다면, 이는 상당한 손실이 아닐 수 없습니다.

 응답으로, 서버는 소켓 스트림을 통해 보여지는 HTML 문서를 보낼 것입니다. 이를 responese body라 불립니다. 여기 response body가 무엇인지 나와 있습니다:
[OUTPUT]

 HTML문서는 열고 닫음 태그 html로 감싸져 있습니다. 이러한 태그로, body section을 선언 할 수 있습니다. body section에서, 웹 페이지의 body로 웹 브라우저에서 보여질 텍스트메시지를 작성할 수 있습니다.

 완벽하게 HTML을-준수하는 웹 페이지에는, DOCTYPE 선언과 같은 다른 항목들이 있어야 됩니다. 그러나, 저희 예제는 잘 작동할 것이며, 저희 간단한 시연에선 이런 기술적인 세부사항을 무시할 것입니다.

 웹서버는 또한 일반적으로 response header를 생성합니다. 이 헤더는 웹 브라우저에게 이 문서를 받았을때 HTML인지 다른 format 문서인지와 같은 추가 정보를 줍니다. 그러나 저희가 만들 단순한 웹서버에서는 이와 같은 header를 생성하는 대신 단순히 body만 반환합니다.

NOTE
 CLISP-특화된 소켓 명령어를 사용하기 때문에, 이번장에서 나온 샘플 웹 서버를 CLISP에서 돌려야 합니다.


Request Parameters
 웹 form은 웹사이트를 운용하는데 있어 필수적인 요소입니다. 예를들어 웹사이트에 간단한 login form을 만든다고 가정해 봅시다.
[OUTPUT]

 저희 웹 서버의 방문자가 이 페이지에서 Submit 버튼을 누르면, POST request가 웹 서버로 보내집니다. POST request는 이전 예제의 GET request와 매우 유사합니다. 그러나, 보통 POST request는 서버에서 데이터가 변경될 수 있다는 기대를 수반합니다.

 저희 단순한 login form에서, 이 form에서 text field에 입력한 사용자 ID와 비밀번호를 서버에게 예기해 주어야 합니다. POST request의 일부로 서버로 보내지는 이 필드의 값들을 request prameter라 부릅니다. reqeust header아레 request body로 마련된 공간에 POST request를 추가하여 보냅니다.

 저희 login 예제에서 POST request는 다음처럼 보일 것입니다:
[OUTPUT]

 이 POST reqeust header의 추가 인자 Content-Length는 request 아래에 있는 parameter 데이터의 길이를 나타냅니다. Content-Length: 39로 지정함으로써 request parameters는 39 문자의 길이의 텍스트를 포함한다는 것을 서버에게 알립니다.


Request Parameters for GET Requests
 이전에 다루었듯이 request parameter의 목적은 POST request동안 web form 데이터를 서버에게 보내기 위한 것입니다. 그러나 GET request 또한 request parameter를 포함합니다. 보통, GET reqest는 parameter가 request의 URL에 나타나며, POST request에서는 request의 내부에 parameter가 감춰져 있습니다.

 예를들어, Google에서 "dogs."를 검색한다고 가정해 봅시다. 이러한 경우에, 다음에 나오는 페이지는 http://www.google.com/search?q=dogs&hl=en&safe=off&... 처럼 생긴 URL를 가지게 됩니다. ([q]uery="dogs"로 시작하는 것 처럼) URL에 있는 이 값들은 request parameter입니다.

 저희가 만든 웹 서버는 서버 코드에게 이 request parameter의 타입에 접근해야 합니다; 하나는 request의 내부에 있고(보통 POST request) 또하나는 URL에서 보입니다(보통 GET request)


Decoding the Values of Request Parameters
 HTTP는, 사용자가 form에 입력한 알파벳이 아닌 문자를 HTTP escapse code를 사용하여 나타내는, 특별한 방식을 지녔습니다. 이 escape code들은 여러분이 HTTP format이 아니면 이용할 수 없는 request parameter의 값을 문자로 갖도록 만듭니다. 예를들어, 유저가 "foo?"라고 입력하면, request에서 물음표가 escapse code로 표시되어 "foo%3F"라 보일 것입니다. 저희 웹 서버는 이러한 escape 문자를 decode해야 하며, 저희가 작성할 첫번째 함수는 decode-param입니다:
[SOURCE]

NOTE
 저희가 여기서 다룬 HTTP escape code들은 저희가 이 책의 다른 부분에서 다루었던 Lisp 문자열의 escapse character와는 관련이 없습니다.

 우선, 이 함수는 재귀적으로 문자들을 처리하는데 이용할 지역 함수 f를 정의합니다. 재귀적으로 일을 처리하기 위해, coerce사용하여 문자열을 문자들의 리스트로 바꾸어, 이 리스트를 f로 넘겨줘야 합니다.

 퍼센트 표시(%)나 더하기 표시(+)인지 확인하기 위해, f 함수는 리스트에 있는 첫번째 문자를 확인합니다. 퍼센트 표시라면, 리스트에서 다음에 오는 값이 16진수로 표시된 ASCII 코드라는 것을 알게됩니다. (ASCII 코드는, 많은 컴퓨터 시스템과 응용프로그램 사이에서 공유하는, 텍스트 문자에 해당하는 표준 숫자들의 집합입니다.)

 이 ASCII 코드를 decode하기 위해, http-char 함수를 만들었습니다. 이 함수에서, 문자열을 정수로 변환하기 위해 parse-integer함수를 이용합니다. 이번 경우, parse-integer에서 키워드 인자를 사용하였습니다: 함수에게 16진수 숫자를 분석하라고 말하는 :radix와, 유효하지 않은 수가 주어지면 error를 신호로 보내는 대신에 nil을 반환하도록 하는 :junk-allowed 인자.

 그런 다음, 이 정수를 사용자가 입력한 실제 문자로 변환하기 위해 code-char 함수를 사용합니다.

 HTTP 인코딩 규칙에 의해, request parameter에 있는 값이 더하기 표시가 있으면, 공백 문자로 변환되야 합니다. 이러한 변환을 이곳에서 합니다.

 f 함수를 통과하는 다른 문자들은 변하지 않습니다. 그러나, 모든 문자들이 처리될 때까지 리스트의 나머지를 f에 넣어 호출해야 합니다.

 여기 decode-param이 동작하는 몇몇 예가 있습니다:
[REPL]


Decoding Lists of Request Parameters
 다음으로  저희 서버가 해야 할 일은 "name=bob&age=25&gender=male"과 같이 문자열에 name/value 쌍으로 주어진 parameter의 리스트를 decode하는 것입니다. 전에 다루었듯이, 웹 페이지의 URL은 보통 뒷쪽에 name/value 쌍을 포함합니다. 보시다시피, 이 문자열은 웹 페이지에서 여러분이 찾는 사람의 이름이 bob이며 나이는 25며 성별은 남자라 알려줍니다. 이 name/value 쌍은 엠퍼샌드(ampersand, &)로 분리되었습니다. 이 문자열의 구조는 연관 리스트(alist)와 동일하므로, 다음 함수를 이용하여 이 인자들을 alist로 저장 할 것입니다:
[SOURCE]

 parse-params 함수는, position 함수를 이용하여 문자열에서 엠퍼센드와 equal 표시(=)가 처음 보여지는 곳을 찾습니다. name/value 쌍을 찾았으면(문자열에서 equal 표시를 찾았으면 i1에 저장하여 이것이 참인지 알 수 있습니다), intern 함수를 사용하여 name을 Lisp 심볼로 변환합니다. 이 name을 decode-param 함수로 decode할 parameter의 값으로 cons 합니다. 마지막으로, 나머지 문자열에 parse-params를 재귀적으로 호출합니다.

 새로운 parse-params 함수를 테스트해봅시다:
[REPL]

 이 데이터를 alist로 넣어서, 필요하다면 저희 코드를 쉽게 특정 변수로 참조할 수 있도록 만듭니다.

NOTE
 14장에서 다루게될 tail call을 이용하여 작성하게 된다면, decode-param과 parse-params는 높은 성능을 낼 수 있습니다.


Parsing the Request Header
 다음으로, 저희는 request header의 첫번째 라인을 처리하는 함수를 작성할 것입니다(이는 GET /lolcats.html HTTP/1.1로 보이는 라인입니다).

 다음에 오는 parse-url 함수는 이러한 문자열을 처리합니다:
[SOURCE]

 이 함수는 우선 URL을 찾고 추출하기 위해, 문자열의 구분자로 사용된 공백을 이용합니다. 그런 다음 이 URL을, 다루어질 필요가 있는 request parameter가 있다는 것을 나타내는, 물음표에 대해 검사합니다. 예를들어, URL이 lolcats.html?extra-funny=yes라면, 물음표는 URL에 있는 인자의 이름이 extra-funny라는 것을 알려줍니다. 인자가 있다면, 그것을 parse-params를 이용하여 추출합니다. request 인자가 없다면, URL 그대로 반환합니다. 이 함수는 request method(대부분 GET이나 POST)에 대해선 넘어갑니다. 멋진 웹 서버는 이러한 데이터 부분을 잘 추출합니다.

 저희 새로운 URL 추출기를 테스트 해 봅시다:
[REPL]

 이제 저희는 첫번째 라인을 읽을수 있게 되었으므로, 이 request의 나머지 부분을 처리할 겁니다. 다음 get-header 함수는 request에 남아있는 라인을 alist로 변환합니다:
[SOURCE]

 이 함수는 스트림으로부터 한 라인을 읽어서, 콜론의 위치를 기반으로 하여 key/value 쌍으로 변환한다음, 헤더에 있는 나머지 라인들을 변환하기 위해 반복recurse합니다. header 라인에 어울리지 않은 라인을 만났다면, 헤더의 끝에 위치한 빈 라인에 도달했다는 것을 의미합니다. 이번 경우 i와 h는 nil이 될 것이며, 함수는 종료될 것입니다.

 키를 생성할때 사용되는 intern 명령어는 문자열을 심볼로 변환시키는 간단한 함수 입니다. 대신, 이러한 목적을 위해, 이 책에 이전에서 다룬 read 명령어를 사용할 수 도 있습니다. 그러나 read 명령어의 유연성은 웹 서버를 해킹crack하기 위해 잘못된 헤더를 만들지도 모르는 해커에 있어 훌륭한great 먹이감target라는 것을 기억하시기 바랍니다. 데이터를 인터넷을 통해 웹 서버로 보내는 작업을 처리하기 위해, 더욱 제한된 intern 함수를 이용하는 것이 현명합니다.


Testing get-header with a String Stream
 get-header 함수가 데이터를 소켓 스트림으로부터 직접 끌어오기 때문에, REPL을 통해 직접 테스트할 수 없다고 생각할 지도 모릅니다. 그러나 이전 장에서 봤듯이, 사실 소켓 외에도 Common Lisp의 스트림 인터페이스를 통해 접근 할 수 있는 몇몇 다양한 타입의 자원이 있습니다. 스트림에 관한 common interface덕에, 소켓 스트림 대신 문자열 스트림에 이것을 통과 시킴으로써 get-header 함수를 테스트 할 수 있습니다.
[REPL]

 make-string-input-stream 함수를 사용하여, 문자열로부터 입력 스트림을 생성할 수 있습니다. 이 예제에서, 일반적인 HTTP header와 같은 두 key(foo와 bar)를 빈 라인으로 끝나는 문자열을 정의하였습니다. Common Lisp에서 다음과 같은 문자열을 허용합니다. 보시다시피, get-header 함수는 두 key와 값을 스트림에서 적절하게 꺼내오며, 동일한 방식으로 소켓 스트림에서 이러한 값들을 꺼내옵니다.

 이러한 꼼수trick를 이용하여, REPL에서 스트림을 직접 다루는 함수를 테스트할 수 있습니다. 이러한 일을 하기 위해선 단순히 복잡한 스트림 타입을 문자열 스트림으로 치환하면 됩니다.


Parsing the Request Body
 POST request에서 parameter는, 보통 request body혹은 request content라 알려져 있는 헤더 밑에 저장되어 있습니다. 다음 get-content-params 함수는 이 parameter들을 추출합니다:
[SOURCE]

 우선, 이 함수는 header에서 content parameter의 길이를 알려주는 content-length라 불리는 값을 찾습니다. content-length가 존재하면, parameter를 분석해야 될것이라는 것을 알게 됩니다. 그런 다음, make-string을 이용하여 주어진 길이의 문자열을 생성하며, read-sequene를 이용하여 스트림으로부터 그 문자열을 채웁니다. 이 parameter를 정제된(clean-up) alist 형식으로 변환하기 위해, 그 결과를 parse-params 함수에 넣어 돌립니다.


Our Grand Finale: The serve Function!
 이제 웹 서버의 심장을 작성하기 위한 모든 조각들을 모았습니다: serve함수. 여기에 이 놀라운 것들이 있습니다:
[SOURCE]

 serve함수는 하나의 인자를 취합니다: 웹사이트의 생성자로부터 제공된 request-handler. server가 네트워크에서 request를 받을때, 그 request를 순수한 Lisp 데이터 구조로 분석하고(이번장에서 다룬 함수를 이용하여), 이 request 정보를 request-handler로 넘겨줍니다. 그런 다음 request-handler가 올바른 HTML을 보여줍니다.
[PIC]

 어떻게 이러한 일을 해내는지 serve함수를 자세히 살펴봅시다. 우선, serve는 port 8080에 bind된 소켓을 생성합니다. 이는 보통 개발중에 있는 사이트에서 웹 페이지를 서비스하는데 이용되는 몇몇 포트중 하나입니다(Port 80은 보통 상용 웹사이트/웹 서버에 사용됩니다). 그런 다음, 서버가 돌아가는 동안 어떤일이 발생하여도 아무런 문제가 없다는 것을 보증하는 unwind-protect를 호출하며, socket-server-close는 소켓을 해제하는 지점에서 호출될 것입니다.

 그런 다음에, 주 web-serving 루프를 시작합니다. 이 loop에서 서버로 접근하는 클라이언트를 위해 스트림을 엽니다. 그런 다음, 어떤일이 일어나도 스트림이 적절하게 닫힘을 보장하는 with-open-stream 매크로를 사용합니다.이제 저희가 만든 읽고 분석하는 모든 함수를 이용하여, 클라이언트가 서버에게 요구한 웹 사이트 request를 읽고 분석할 준비가 되었습니다.

 마지막으로, request 세부사항을 넣어 request-handler 함수를 호출합니다. 그 전에 동적 변수 *standard-output*를 재정의 하였습니다. 이는 request handler가 표준 출력으로 쓸 수 있다는 것을 의미하며, 모든 출력된 데이터는 클라이언트 스트림으로 자동적으로 흘러갈 것입니다. 12장에서 배웠듯이, 표준 출력에서 데이터를 잡는 것은 문자열 결합을 최소화시킵니다. 또한 곧 보게되겠지만, request-handler 함수를 디버그하기 쉽게 만들어 줍니다.

NOTE
 저희 웹 서버가 수행하지 않는 것 중 하나는 request-handler가 예외를 발생시킬때 crashing되는 것을 방지하는 것입니다. 대신, 예외가 발생하여도 토막난 자원이 없다는 것을 보장합니다. 끔찌한 예외가 발생하더라도 저희는 서버가 흔들리는걸tick 방지하는 예외 처리를  쉽게 추가할 수 있습니다. 그러나, 저희 목표는 Lisp를 배우고 브라우저 게임을 개발하는 것이기에, 저희 서버가 다운될 지라도, 예외에 대해 즉각 알 수 있도록 하는 것이 저희에게는 더 알맞습니다


Building a Dynamic Website
 새로운 웹서버를 테스트 하기 위해, 매우-간단한 함수 hello-request-handler를 이용하여 방문자에게 환영 메시지를 보내는 간단한 사이트를 만들어봅시다:
[SOURCE]

 이 hello-request-handler 함수는 환영메시지를 보여주는 오직 하나의 웹 페이지만 지원합니다. 이 환영 페이지를 서비스하기 위한 첫번째 단계는, 이 페이지가 실제 클라이언트가 요구한 것인지 확인하는 것입니다. 만일 아니라면, 지정된 페이지를 찾을 수 없다고 사용자에게 사과문을 출력해야 합니다. 그 외에는, 사용자의 name을 알고 있는지 알기 위해 request parameter를 확인합니다. 아니라면, web form을 이용하여 사용자에게 username을 입력하도록 합니다. 사용자의 이름을 알게 되었다면, 방문자를 열렬하게 환영합니다.

NOTE
 저희는 웹 서버와 초기 웹 사이트에 많은 꼼수shortcut를 취하였습니다. 예를들어, 클라이언트에게 보낼 HTML은 <html><body>...</body></html>와 같은 HTML 기본뼈대로 감싸야 됩니다. 그러나, 저희 페이지는 현대 HTML표준을 준수하지 않습니다. 추가로, 클라이언트가 존재하지않는 페이지를 요청할때, 적절한 응답으로는 정중한 사과메시지를 출력하는게 아니라, 404 error 페이지를 보여주는 것입니다. 다행스럽게도, 웹 브라우저는 다음과 같은 shortcut에 매우 관대하며, 저희 단순한 response를 보여줄 것입니다.


Testing the Request Handler
 새로운 웹 사이트를 실행하기 전에, lolcats에 관한 페이지를 우선 보여줘서 REPL에서 hello-request-handler를 테스트 해봅시다:
[REPL]

 완벽합시다. 보시다시피, request handler에게 환영 페이지 말고 다른 페이지를 요청할때, 사과메시지를 출력합니다. 이제 정확한 greeting page를 살펴봅시다:
[REPL]

 훌륭합니다! request handler가 사용자에게 username을 물어보는 HTML form을 생성하였습니다. 이제 form이 진행되고 서버로 보내지는 것처럼, 사용자의 이름을 인자로 넣어 봅시다:
[REPL]

 웹 서버를 디자인한 방식으로인해, REPL에서 request handler를 독립적으로independently 디버그 하는것은 매우 간단합니다. 실제로 웹 브라우저를 가동시키지 않고, hello-request-handler가 정확한 response을 생성하는 것을 볼 수 있습니다.


Launching the Website
 새로운 웹사이트가 작동하므로, 이제 이것을 돌려봅시다! 그러나 먼저, 이번 장에서 다루어진 모든 함수가 정의 되어야 합니다. 여러분이 읽었던 것처럼 이 함수들을 REPL에 입력할 수 없다면, webserver.lisp파일에 전부 저장하여, (load "webserver")로 로드할 수 도 있습니다.

 CLISP에서 함수를 정의하였으면, 다음을 REPL에 입력하여 서버를 시작합니다:
[REPL]

 바로 이겁니다! 이제 여러분은 웹 브라우저로 사이트를 방문할 수 있습니다:
[PIC]
[PIC]

 보시다시피,  (웹브라우저가 돌아가고 있는 동일한 머신의 포트 8080을 가리키는, 127.0.0.1:8080을 이용하여) 브라우저로 greeting page를 방문했을때, 이름을 물어봅니다. 그런 다음 서버는 이름에 맞게 환영메시지를 보여주는 다음 페이지를 보여줍니다. 이것은 저희 웹 서버가 request parameter로 들어온 이름을 북석해 내서, hello-request-handler 함수로 이름을 넘겨줄 수 있다는 것을 보여줍니다.

 이제 여러분은 완전한 함수로 구성된 웹서버와 request handling 인프라-구조를 갖게되었습니다. 나중에, 이 툴을 사용하여 화려한 웹-기반 게임을 만들 것입니다.


What You’ve Learned
 이번장에서, 여러분은 Common Lisp를 이용하여 웹 서버를 만들었으며, 그런 과정속에 다음 것들을 배웠습니다:

z Common Lisp에서 error 함수로 condition을 신호로 보낼 수 있다. 이와 같은 error를 handle-case 명령어로 잡을 수 있습니다. 어떠한 error가 발생하든지 신경쓰지 말아야되는 코드가 있다면, 이 코드를 unwind-protect 명령어 안에 놔둘 수 있습니다.
z  웹 서버는 HTTP reqeust를 수행한다. 대부분의 request 타입은 정보를 보는데 사용하는 GET request입니다. 또다른 타입은 웹 form에서 submit할때 사용하는 POST request입니다. request header를 살펴봄으로써 다른 정보와 함께 어떤 페이지가 요청되었는지, 이 request 타입에게 말할 수 있습니다. GET과 POST request는, 요청하는 URL의 끝이나 request 아레 request body에서 보여지는, request parameter를 지닙니다.

#==================================================
//HTTP1.1-rfc2616
-영문
http://www.w3.org/Protocols/rfc2616/rfc2616.html
-한글
http://secretofsh.tistory.com/27

//PacketTracer Http request - youtube
http://www.youtube.com/watch?v=qiEabvX9UX4 
#==================================================