INTRODUCTION
서론


 만약, 여러분이 Lisp에 관한 책을 집어들고 시작부분을 읽기로 결심하였다면, 여러분은 책꽃이에 꽂아진 다른 프로그래밍책들과 섞여있는 만화책에 놀랄 것입니다. 누가 리스프와 같은 기괴한 academic 프로그래밍 언어에 관한 만화책을 만드는데 신경을 쓸까요? 혹시 여러분은 다른 굉장한 이들로부터 Lisp에 대해 듣고 생각했을지도 모릅니다. "애야, Lisp는 사람들이 말하는 다른 언어들과는 틀리단다. 언젠가 내가 Lisp 책을 꺼내들 것이란다". 어찌됫던간에, 여러분은 지금 매우 굉장하며 또한 매우 괴상한 프로그래밍에 관한 책을 들고 있습니다.
[PIC]


What Makes Lisp So Cool and Unusual?
 Lisp는 매우 풍부한expenssive 언어입니다. Lisp는 여러분이 지닌 가장 복잡한 프로그래밍 아이디어를 명확하고 적절한 방법으로 표현할 수 있도록 설계되었습니다. Lisper는 당면한 어떠한 문제를 풀기위해 정확한 방법으로 가장 유용한 프로그램을 작성할 수 있는 자유를 가졌습니다.
 Lisp코드를 작성할 때 이를 매우 색다르게 만드는 것은 여러분 손끝의 power입니다. 여러분이 Lisp를 얻으면, 여러분은 영원히 프로그래머로 변하게 될것입니다. 심지어 여러분의 남은 일생동안 Lisp코드를 다시 작성하지 않는다 하더라도, Lisp를 배우는 것은 기본적으로 여러분을 coder로 바꾸어줍니다.
 일반적인 프로그래밍 언어를 배우는 방법은 성인일때 외국어를 배우는 것과 흡사합니다. 여러분이 프랑스어를 배우기 위해 내일 떠난다고 가정해봅니다. 여러분은 아마도 여러분이 찾을 수 있는한 프랑스로 가는 모든 경로를 모을 것이고, 프랑스에 관한 기사들을 읽고, 결국 프랑스로 가게될 것입니다. 하지만 여러분이 무얼하든지간에, 여러분이 프랑스를 이해하는것은 항상 조금 불완전하게 남아 있게됩니다. 여러분의 꿈이 모국어처럼 말하는 것이라도, 갑자기 프랑스어를 잘하게 될 순 없습니다.
 Lisp는 다릅니다. 이것은 외국어를 배우는 것과는 조금 다릅니다. 여러분이 Lisp를 배우기만 한다면, 여러분은 심지어 Lisp에 관한 꿈을 꾸게될 것입니다. Lisp는 강력한 idea입니다. 이것은 여러분의 이전 프로그래밍 경험에서 해방되게할 것이고, 여러분의 새로운 모국어가 될 것입니다! 어찌됫건 여러분이 다른 언어에서 새로운 프로그래밍 idea를 마주치게 된다면, 여러분은 항상 혼잣말로 말할것입니다, "저러한 것을 Lisp에서 구현한다면, 아마도 . . . ." 이런 종류의 power는 오직 Lisp만이 여러분에게 선사할 것입니다.
[PIC]

 여기서, 여러분은 적어도 어느 한사람(me)이 열정적으로 빠져있는 Lisp에 대해 알게 되었습니다. 여러분의 시간이 중요한데, 새로운 무언가를 배우는 것에는 조금의 노력이 필요합니다.
  좋은 소식으로는 Lisp는 실제로 그다지 어렵지 않다는 것입니다. 예를들어, 다음에 나오는 것은 유요한 Lisp 표현식입니다 :
[SOURCE]

 여러분은 이 표현식의 결과 값을 추측할 수 있나요? 만일 여러분의 답이 11이라면, 여러분은 이미 기초적인 Lisp코드를 읽는 방법을 알아낸 것입니다. 함수 - 이번 경우, 덧셈과 곱셈 - 이 숫자 앞에 오는것과 모든 것이 괄호안에 있는 경우를 제외하면 이것은 마치 수학처럼 쓰여졌습니다.


If Lisp Is So Great, Why Don't More People Use It? 
 실제로, 상당수의 대기업들이 몇몇 중요한일을 처리하기 위해 Lisp를 사용합니다.(http://snipurl.com/e3lv9/ 에서 길게 나열된 Lisp프로젝트들을 볼 수 있습니다). 다른 프로그래밍 언어들은 지속적으로 Lisp의 기능을 "빌려서" 그것이 마치 최신이고, 대단한 idea라고 발표합니다. 많은 이들이 웹의 미래를 주도할 것이라고 믿는 시맨틱 웹 또한, Lisp로 쓰여진 많은 툴들을 이용하고 있습니다.

NOTE
 시맨틱 웹Semantic Web의 idea는, 컴퓨터가 웹 페이지에 있는 "의미있는" 정보를 판별하기위해, 웹사이트의 protocol의 set을 만드는 것입니다. 이는 annotating web pages와 다양한 웹 사이트가 공유하는 일반적인 어휘와 연결하는 특별한 metadata로 가능합니다(보통 이러한 포맷을 Resource Description Framework, 혹은 RDF라 부릅니다). description logics과 RDF 데이터를 다루는 많은 도구들이 Lisp로 작성되었습니다(예를들어, RacerPro와 AllegroGraph).


 따라서, Lisp는 확실히 유망한 미래를 가지고 있습니다. 그러나 몇몇 이들은 Lisp를 배울 가치가 없다고 생각하기도 합니다.

 어찌하여 Lisp는 이와 같은 부당한 명성을 갖게 되었을까요?

 저는 사람들이 일생중에 어떠한 일을 배울지 결정하는데, 경험 법칙rule of thumb를 이용한다 생각합니다.

 대다수의 사람들이 다음 나오는 세가지 분류 중 하나를 추구합니다 :

z 다른 사람들이 많의 익히는것(미적분학, C++, 기타 등등) 
z 쉽게 배울 수 있는 것 (훌라우프, Ruby, 기타 등등) 
z 쉽게 주목을 끄는 것(예를 들어, 열핵 물리학이나 여러분의 입에 손가락사이로  우스꽝스러게 큰 휫바람을 부는 것)

 Lisp는 이러한 분류에 속하지 않습니다.

 이것은 미적분학 만큼 유명하지도, 특별하게 쉽게 배운다던지, 시끄러운 휫바람을 부는 것과 같이 주목을 끌 순 없습니다. 만일 우리가 이러한 규칙(일반적으로 매우 합리적인) 경험 법칙를 따른다면, 사려깊은 사람들은 Lisp를 떠나야 한다는 결론에 이르게 됩니다. 그러나 Lisp의 경우, 우리는 이러한 규칙을 던져버리고 진행할 것입니다. 이 책을 읽다보면, 작은 노력을 필요함에도 불구하고 모든 진지한 프로그래머들이 이 특이한 언어에 대한 몇몇 경험을 있고, Lisp가 여러분에게 매우 심오한 컴퓨터 프로그래밍에 대한 통찰력을 준다는것을 알게될 것입니다. 약간의 노력이 필요하더라도 이 책을 읽다보면, Lisp는 컴퓨터 프로그래밍에 있어, 이 특이한 언어에서 진지한 프로그래머들이 격게 되는 매우 심오한 통찰력을 여러분에게 줄 것입니다.

 만약 여러분이 아직도 확신이 서지 않는다면, 이 책의 끝부분에 있는 만화 에필로그를 들여다 보시기 바랍니다. 당장 여기에 나와있는 것을 이해할 수 없지만, 이것은 여러분에게 Lisp의 진보된 특색이 이용가능하며, Lisp 프로그래밍이 다른 종류의 프로그래밍과는 다르다는 느낌을 줄 것입니다.


Where Did Lisp Come From? 
 Lisp계의 언어들은 실로 오래되었고, 다른 언어들과는 다른 역사를 가졌습니다. 저희는 이 모든 것들이 시작된 시간으로 되돌아갈 것입니다.

 (1940s 이전으로 돌아가서) 옛날 옛적에, 지구는 판탈라사 해(Panthalassic Ocean)로 불리는 거대한 바다로 덮혀있고, 그 가운데 판개아(Pangaea)란 이름의 하나의 척박한 땅덩어리가 있었습니다. 이런 힘든 환경 속에서, 첫 컴퓨터 프로그램이 탄생하였으며, 순수 기계 언어(혹은 그들이 말한 그대로 "0과 1")로 작성되었습니다

  ENIAC이나 Zuse Z3과 다른 초기 진공관 머신과 같은 초창기 언어들은 특정 컴퓨터 시스템과 밀접하게 관계되어 있었습니다. 초기컴퓨터들은  매우 원시적이여서 종종 "프로그래밍"은 단순히 스위치들을 전환하거나 각 동작에 맞게 물리적으로 캐이블을 배치하는 작업이 동반되어졌습니다

 초기 언어들의 암흑기에는 컴퓨터 아키텍처에 대해 수많은 많은 실험과 컴퓨터 instruction sets의 폭발적인 증가가 보였습니다. 경쟁이 치열하였습니다. 그러나 대다수의 고대언어들의 실험-고대 서바이벌 전쟁의 희생자들-들은 결국 사라지게 되었고 다른이들은 번성하게 됩니다.
[PIC]

 어느 순간, 컴퓨터는 프로그램들을 저장할 수 있는 그들만의 메모리와, 순수 숫자 대신 문자로 프로그램 작성이 허용된 원시 어셈블러 얻게 되었습니다. 이러한 어셈블리 언어에는 Short Code, ARC assembly, 그리고 DESAC Initial Orders가 포함되어 있습니다.

 어셈블리 언어들은 소프트웨어 개발을 더욱더 효율적으로 만들었고, 고대 어셈블러이 이 원시바다의 많은 포식자를 피하는게 가능하였습니다. 그러나 어셈블리 언어들은 여전히 상당한 제약을 지녔습니다. 그들은 항상 특정 프로세서의 instruction set에 맞춰 설계되었고, 따라서 다른 머신 아키텍쳐로 이식이 불가능하였습니다. 프로그래밍 언어들은 생존을 위해 특정 머신 instruction set의 경계를 넘나 들 수 있는 진화가 필요하였습니다.

 1950년대에 들어 처음으로 머신에 의존하지 않는 프로그래밍 언어가 나왔습니다. Autocode와 Information Processing Language 같은 언어들은, 폐와 다리 뿐만아니라, 컴파일러와 인터프리터와 같은 새로운 종류의 소프트웨어를 통해 이런 비의존성을 이루었습니다.

 컴파일러와 인터프리터로 인해, 컴퓨터 프로그램은 이제 인간이 알아 듣기 쉬운 문법으로 쓰여질 수 있습니다. 컴파일러는 사람이 작성한 프로그램을 취하여, 이것을 자동으로 기계가 알아듣기 쉽고 실행할 수 있는, binary 형식으로 바꾸어 줍니다. 반면 인터프리터는, 기계가 알아듣기 쉬운 binary 형식으로 바꾸는 과정없이 사람이 작성한 프로그램을 직접 실행합니다.

 원시적인 하드웨어 수준에서의 작업이 필요하지 않는 프로그래머는, 처음으로 컴퓨터 프로그래밍을 즐거운 활동으로 만들도록 설계된 언어를 사용할 수 있었습니다. 이러한 인터프린트되거나 컴파일된 프로그래밍 언어들은 최초의 "진정한" 프로그래밍 언어들로 여겨지고 있습니다. 이러한 초기 언어들 중 가장 인상적인 (1957년에 개발된)FORTRAN은 상당히 많은 서로 다른 아키텍쳐를 지원하고 있으며, 오늘날까지 여전히 사용되고 있습니다.
[PIC]

 여기까지 오기까지, 많은 성공적인 언어들은 하나의 주요 idea를 중심으로 설계되었습니다 : 초보자라도 쉽게 프로그래밍을 할 수 있는 일반적인 디자인과 문법을 제공. 그러나, 이렇게 디자인된 좋은 프로그래밍 언어는 매우 어렵게 변하게 됩니다. FORTRAN, BASIC, C와 같은 대다수의 이런 언어들은 예전의 idea들을 단지 뒤석어 놓은 것이고, 이러한 것은 진정한 아름다움이 빠진 어떤 하나를 복사하고 묶어서 나온 것입니다. 그것들은 피상적인 방법으로 사용하기에 편했습니다. 여전히, 이런 야만적인 언어들은 수십년간 정글안에서 쉬운 먹잇감들을 찾고 있습니다.

 이 무시무시한 짐승들의 그늘속에서, 대륙으로 기어나온 초기의 기계에 종속되지 않은 언어로부터 나온 작고 천하지만 완전히 다른 생명체(가려져서보이지 않지만 존재하는)가 숨어서 기다리고 있습니다. 이러한 언어들은 1930년대 수학자에 의해 개발된 람다계산법 같은 수학적인 문법을 사용하였습니다.

 실용적이거나 초보자들이 쉽게 배우는데에 어떠한 관심도 주지 않은, 이러한 언어들은 매우 지능적이였고 언어설계의 한계를 밀어내기를 원하였습니다. 이들은 프로그램 표기법, 언어 의미론, 가능한 간단한 언어 문법에 대한 의문들을 제기하였습니다.

 이러한 매우 지능적인 수학적 syntaxes가 가장 주목할만한 생명체로 진화하였습니다 : Lisp프로그래밍 언어의 기원. 대다수의 프로그래밍 언어와는 달리, 이는 FORTRAN 또는 실용주의나 쉬운 사용법을 염두에둔 다른 프로그래밍 언어로부터 진화하지 않았습니다. 이 혈통은 수학으로부터 곧바로 그려진 어떠한 것에서 완전히 떨어져 나왔습니다. 그렇다면 Lisp는 어디서 나왔을까요?

 어떤 사람들은 Lisp의 기원이 시간의 안개속에서 자취를 감췄다고 주장합니다. (아마도 더 정확한)다른이들은 Lisp는 John McCarthy의 1959년 작품이라 말합니다. 어느날 그는 MIT에 있는 그들의 부족을 모아서 하나의 독창적인 idea를 발표하였습니다. McCarthy은 적은 문법과 의미를 지니면서 놀랄만한 프로그램을 만들어낼 이론적으로 완벽한 프로그래밍 언어를 구상하였습니다. Lisp에서 돌아가는 Lisp인터프린터는 오직 50여줄의 컴퓨터 코드로 쓰여질 만큼 매우 우아하였습니다!
[PIC]

NOTE
 John McCarthy는 논문 "Recursive Functions of Symbolic Expressions and 
Their Computation by Machine, Part I,"을 발표하였습니다 Communications of the ACM (April 1960): 184-195. http://www-formal.stanford.edu/jmc/recursive.pdf에서 이를 읽을 수 있습니다.
[PIC]

 McCarthy가 처음 그의 idea를 공표하였을때, 이는 수학 문법의 지적 탐구만을 의미하였습니다. 그러나 곧, Lisp언어는 진화하였고 컴파일러와 인터프리터들과 함께 작업할 수 있습니다. FORTRAN과 다른 프로그래밍 언어와 같이, 이것은 실제 컴퓨터에서 동작하였습니다! 그러나 이러한 다른 언어와는 달리, Lisp는 수학적 계통으로 부터 물려받은 아름다움을 유지하였습니다.

 Lisp가 처음 등장하고 곧, 첫 Lisp 프로그래머들이 나타나 반려동물들을 잡아들여 이들을 더욱 세련된 프로그래밍 언어로 변화시켰습니다. 시간이 지나서, 이 프로그래머들은 원시 Lisp로부터 MACLISP나 Interlisp와 같은 방언을 사용하였습니다.
[PIC]

 초기 Lisp 프로그래머에게 있어 초기 Lisp의 사냥이 성공적이였지만, 곧 이러한 사냥꾼들이 경쟁자들을 가졌다는게 분명해졌습니다 : 크로마뇽인. 크로마뇽인은 평화로운 Lisp프로그래머들보다 더욱 공격적이여서, COBOL과 같은 언어를 사용하는 아주 큰 소프트웨어 개발 프로젝트를 공격하였습니다. 비지니스 어플리케이션을 개발함에있어 COBOL은 난폭해졌고 사악한 괴수가 되었지만, 그럼에도 불구하고 크로마뇽인을 위한 제물이 되었습니다. 반면 Lisp프로그래머들은 더많은 우아한 프로그래밍에 만족하였고 가끔씩 Lisp를 사냥하였습니다.

 Lisp가 엄청 강력한 idea가 되는 동안, 다른 프로그래밍 언어들은 이미 생각의 공유와 보다 낳은 개발 도구들로 앞서 나갔습니다. 이것은 Lisp에게 고난을 주었으며, Lisp프로그래머는 주류로서의 성공에 필요한 힘을 얻기 위해 그것들에 의존하였습니다. 그러나, 온건한(gentle) Lisper들은 그와 같은 사소한 것에 관심을 갖지 않았습니다. 다른 성향에도 불구하고, Lisper와 크로마뇽인은 나란히 조화를 이루면서 살았습니다.

 그들 나름대로, Lisper는 번성하고 있었습니다. 이 때에는, 이미지 인식과 컴퓨터 데이터 분류, 인공지능에 맞닥들인 다른 문제와 같은 고도의 학문 연구에 강력한 이점을 가졌습니다. 고도의 수학적인 문제에 대해 그들의 Lispy적인 접근 조사를 빌렸고, 그것들을 공략하기 위해 Lisp프로그래머들은 새로운 Lisp의 방언을 더욱 발전한 컴퓨터 시스템에 내장하였습니다. 많은 이들이 이때를 Lisp의 황금시대라고 생각합니다.

 불행히도, 이러한 짧은 황금시대가 지나가고, 불쌍한 Lisper에게 예상치못한 바람이 불어닥쳤습니다. 1980s 중반에, 지구의 축의 경사가 기후를 변화시켰고, Lisp언어가 살아남기 위해 필요했던 식량저장소가 바닥이 났습니다. AI 연구 진행에서의 실망이 많고 거대한 학술적 연구의 씨를 마르게 하였고, Lisp를 선호했던 많은 수의 하드웨어들은(Symbloics, Lisp Machine, Inc. 그리고 Texas Instruments의 Lisp머신) 많은 전통적인 complex instruction set computer (CIS, http://terms.co.kr/CISC.htm)와 reduced instruction set computer (RISC, http://terms.co.kr/RISC.htm) 하드웨어 아키텍처 보다 성능이 떨졌습니다. 세상은 Lisp와 Lisp프로그래머로부터 생존하기 위해 그들을 환영하지 않았습니다. "AI winter"이 지나간후, Lisp는 침체되었습니다.

 결국 크로마뇽인은 언어 경쟁에서 확고한 우위를 점하게 됩니다. FORTRAN에서 유래된, 거석문화(megalithic)의 새 유행인 객체 지향언어(1983년에 개발된 C++과 같은)는 산업 소프트웨어 개발을 느리게 점령해 나갑니다. 이것은 크로마뇽인에게 (Lisper를 비참하게 만든)AI winter로부터 면역을 갖게 해주었습니다. 더욱, 꾀가많은 크로마뇽인들은 주류 언어를 개선하기 위해 Lisper에 의해 개척된 몇몇 idea들 빌렸습니다. 예를 들어, 원래 Lisp에서 발견된 garbage collection와 매개변수 다형성(parametric polymorphism)이 주류 프로그래머들이 사용하는 언어에서 일반적인게 되었습니다.

 엄청난 노력에 결국 크로마뇽인에 의해 오랜기간 길들여진 언어 거대기업들은 C#, Java와 유사한 언어로 돌아섰습니다. Lisp의 황금시대는 오래전에 잊혀짐과 동시에, 이런 언어가 과거에 이용했던 어떤 것보다도 도구로 사용하기 좋다는 신념이 떠올랐습니다. 최근에는 Python과 Ruby와 같은 언어가 크로마뇽인 언어를 더욱 근대적인 방향으로 개선하였습니다.

 그러나 이러한 기간 동안 어떤일이 Lisp 프로그래머에게 어떤 일이 일어났을까요? AI winter에 완전히 굴복한 것일까요? 그들은 다시한번 그늘에 숨어서, 태양이 다시 뜨기만을 기다리는 것일까요? 어느 누구도 알 수 없습니다. 그러나 여러분이 자세히 들여다보면, 아마 매우 높은 산 속이나 깊고깊은 정글속, 혹은 MIT의 지하실 마지막층에서 여러분은 이상한 종류의 생명체를 얼핏 볼 수 있을 것 입니다. 이것을 Windigo라 부르기도 합니다; 다른이들은 yeti, Sasquatch, rms라 합니다. 그러나 진짜로 그게 무엇인지 아는 이들은 Lisp 프로그래머(그게 될수 있는 유일한)라고 확신합니다.
[PIC]


Where Does Lisp Get Its Power? 
 제가 예전에 특별히 강력한 언어라고 말을 드렸습니다. 그러면 John McCarthy(그리고 Lisp후발주자들)가 지닌 어떠한면이 이러한 능력이 가능케 할까요?

 프로그래밍 언어를 강력하게 만들기 위해선, 여러분은 이것을 표현력(expressive)있게 만들 필요가 있습니다. 표현력을 가진 언어란 매우 적은 실제 코드양으로 많은 일을 할 수 있다는 것입니다. 이것을 가능케하기 위해, 언어에 필요한 것으로는 무엇이 있을까요? 저는 여기에 가장 중요한 두가지 방법이 있다고 생각합니다.

 하나는 언어에 내장된 기능이 많은 것입니다. 이 방법에서는, 여러분이 해야 할 대부분의 것들에 대해, 누군가가 여러분에 맞는 어떤 작업하였고, 여러분의 코드를 알차게 보이도록 만드는 작업에 이용할 수 있습니다. 많은 현대 언어들이 이 방법을 취합니다. Java언어 같은 경우 강력한 라이브러리로 유명한데, 예를 들어 다른 PC로부터 소켓을 통해 쉽게 데이터를 얻을 수 있습니다.

 언어에 강력함을 주는 두번째 방법으로는, 여러분의 요구를 처리할 수 있도록 가능한 깊이있게 여러분이 언어를 파해칠 수 있도록 하는 것입니다. 이 방법은, 언어설계자가 여러분이 하려는것을 절대 상상하지 못하였을지라도, 여러분이 지닌 문제를 우아하게 풀기위해 필요로 하는 만큼 언어를 자신의 것으로 바꿀 수 있습니다. 이런 방법을 언어에서 제공하는 것은 매우 어렵습니다. 여러분이 자바에 중첩된 함수정의 같은것을 추가하길 원한다고 가정합시다. 만일 여러분이 Java를 잘 알고있다면, 악몽속에서 어떻게 추가할지 생각할것입니다.

 대다수의 언어들이 이러한 방법들을 동시에 지원이 어려운 이유는 서로 대립되기 때문입니다. 언어의 부유함이 시작되면서, 이것은 더욱 심화되었습니다. 그리고 더욱 복잡화된 언어에선, 그 언어를 청소하는 일은 더욱 고통럽습니다. 이러한 것이 가장 성숙한 프로그래밍 언어로 바꾸려는 여러분의 요구사항이 불가능에 가깝다는 이유입니다.

 물론 여러분이 열심히 노력한다면, 어떠한 언어를 근본적으로 바꿀 수 있을 것입니다. 예를들어, C++이 개발 되었을때, 처음에는 C 전처리기의 형태를 이용하였습니다. 새로운 C++ 방언으로 작성된 코드를 처리할 수 있는 특별한 C프로그램이 작성되었고, 예전의 C로 변환함으로써, 여러분은 표준 C컴파일러를 통해 실행할 수 가 있습니다. 이것이 C++의 개발자인 Bjarne Stroustrup가 자신의 방법대로 C 언어를 개선하고 기능을 추가 할 수 있었던 방법입니다. 그러나, 이것에 대한 번역기를 작성하는것은 이것을 최후의 수단으로 고려해야만할 매우 어렵고 지루한 작업입니다.

 반대로, Lisp언어는 숙련된 Lisper가 프로그램을 실행하는 컴파일러/인터프린터를 변경하는것을 굉장히 쉽게 할 수 있게 만들어 주면서, 많은 언어의 기능들과 확장성있는 라이브러리를 지원합니다. 사실 Lisp와 함께 언어를 가지고 노는 것은 이제까지 만들어진 다른 언어들에 비해 매우 쉽습니다.
 예를 들어, Lisp로 두점사이의 거리를 계산하는 함수를 작성하는 것은 대부분의 다른 언어들보다 매우 단순합니다! 그러나 숙련된 Lisper는, 새로운 중첩 함수 정의나 케케묵은(a funky) if-then 명령어 방식을 발명함으로써, 이것과 동일하며 쉬운 일을 찾을 것입니다. 심지어 여러분이 지닌 객체-지향적인 프로그래밍을 Lisp에서 지원하도록 작성하는 것은 복잡하지 않습니다(대다수의 Lisper들이 아마도 어느 순간에 했었을것입니다). Lisp에서는, 모두가 mini-Stroustrup이 될 수 있습니다.
[PIC]

 어떻게 Lisp는 이런 멋진 기능을 가능하게 만들었을까요? Lisp의 주요 특징중 하나는 Lisp안에서 Lisp자체를, 믿지 못할만큼 간편하게, 직접 작성할 수 있다는 것입니다. 이것이 Lisp가 두 방법의 경계를 깰 수 있도록 한 성질로 밝혀졌습니다. 언어 밖에서 시작함으로써, 우아하게 자기 자신을 작성할 수 있는 놀라운 수학적 재주를 부릴수 있는 성과를 낼 수 있었는데, 이것은 결국 풍요함과 수정가능함을 보유하는데 필요한 상당한 자산이 되었습니다. 그럼으로써, 어떠한 종류에 관한 프로그램을 실제로 작성하기 위한 훌륭한 도구가 되었습니다!

 이런 방법으로 생각해봅시다 : 프로그래머에게 물고기명령어를 가진 프로그래밍 언어를 주면 그는 하루만 중국음식점에서 먹고 Jolt를 마실 것입니다. 프로그레머에게 그만의 물고기명령어를 작성할 수 있는 프로그래밍 언어를 주면 그는 일생동안 중국음식점에서 먹고 Jolt(http://terms.co.kr/Jolt.htm)를 마실 것입니다.(인정하건데, 영양실조에 빠지거나, 심장 부정맥이 발생할 확률 같은 것은 논외로 합니다).

 따라서, 여러분은, Lisp가 매우 멋지면서 특별한 언어인지에 대한, idea를 가지게 되었습니다. 이것은 대다수의 프로그래밍 언어들과 비교하여 길고 전형적이지 않은 역사를 가졌습니다. 공학의 세계로부터 나온 대다수의 언어들과는 달리, Lisp는 수학적 배경을 기원으로 합니다. 이것은 새로운 무언가를 배우는데 드는 시간을 줄여줍니다.