BUILDING A TEXT GAME ENGINE
5장.Text게임엔직제작

 여러분이 사용하는 프로그래밍 언어나 프로그램에 관계없이, 프로그램을 짤때에는 text와 관련된 작업이 필요할 것입니다. 물론, 어느날 저희 머리에 Ehternet port가 달릴수도 있습니다(100Mbps Ethernet이 적합할 것입니다). 그러나, 직접 접속(direct hookup)을 이용하여 MacBook과 생각을 주고 받을 수 있는 날이 오기전에는, 여러분은 소프트웨어의 input과 output을 위해서 알파벳(alphabetic) text를 사용할 수 밖에 없습니다.


 컴퓨터는 text와 항상 약간의 빈약한 관계를 가지고 있습니다. text작업이 컴퓨터 하드웨어와 소프트웨에 대한 주된 작업으로 여기는 경향이 있지만(실제로, 8-bit 바이트는 대부분의 현대 컴퓨터에서 표준 디자인 요소이며, 때문에 서양 문자들을 다루는데에 있어 적합합니다.), 문제는 컴퓨터에게 인간의 text에 대한 개념이 실제로는 외계어라는 것입니다.

 이번 장에서는, 여러분은 Lisp를 이용하여 어떻게 text를 다루른지를 배울 것입니다. 여러분은, 다시 한번 문제를 해결하는 Lispy적 접근법이 우아함과 대칭(symmetry)이 가득한 코드를 만들도록 도와주는 것을 보게 될 것입니다. 이러한 접근을 보여주기 위해선, 어쩔 수 없이 text를 생각하며 만드는 무언가를 해야합니다: 간단한 text 모험 게임 엔진 제작. 그러기 위해선, 이러한 인위적으로 정해진 text의 디자인에 얽혀매여서는 안됩니다. 이러한 것은 컴퓨터의 능력에 중점을 두어 코드를 작성케 합니다.

 이번 장을 읽을때, text를 다루는 것은 컴퓨터의 능력이 아니라는 것을 기억하길 바랍니다. 이것은 최소한으로 지켜져야할 필요악 입니다(It is a necessarry evil best kept to a minimum).


The Wizard’s Adventure Game
 이번 게임에서는, 우리 모두가 마법사의 제자입니다. 여러분은 마법사의 집을 살펴볼 것입니다. (17장에서) 게임을 완료할때 쯤에는, 여러분은 문제를 해결하여 마법의 도넛을 얻을 수 있을 것입니다.

Our Game World
 이건 저희 게임 세계의 모습입니다:
[PIC]

 보시다싶이, 세개의 장소가 있습니다: 거실, 다락방, 정원(a living room, an attic, and a garden) 게이머는 문을 통해 장소, 사다리를 사용하여 다락방으로 오고 갈 수 있습니다.

 이러한 게임 세계를 간단하게 (타원으로 된)3개의 노드node와 (화살표로 표시된) 4개의 간선edge이라 생각해 봅시다:
[PIC]

 플레이어는 어떠한 방향을 지닌 edge를 따라 감으로써 node사이를 이동할 수 있습니다. 플레이어가 어디에 있든지, 주변에 있는 다양한 물건들(objects)과 상호작용할 수 있습니다.
[PIC]


Basic Requirements
 저희 게임 코드에서 다룰 기본적인 것입니다:
z 주위를 둘러보는것
z 다른 장소로 이동하는 것
z 물건을 집는것
z 물건을 집고 행동하는 것

 이번 장에서는, 이 요구사항 중에서 처음 3개를 다룰 것입니다. 물체가 좀 더 복잡한 행동을 하려면, 나중에 다루게될 더 진보된 Lisp 기술을 사용해야만 합니다. 이러한 연유로, 저희 게임 engine은 17장에서 이 작업이 끝나기 전에는 몇몇 기능이 제한될 것입니다.

 게임 세상을 둘러볼때, 여러분은 어떠한 장소에서 3가지를  "볼" 수 있습니다:
z 기본 배경
z 다른 장소로 가는 길
z 집을 수 있고 다룰 수 있는 물체

 차근차근 이러한 기능을 추가해봅시다.


Describing the Scenery with an Association List
 저희 어드벤처 게임 속 세상은 단지 3개의 장소만을 포함하고 있어 매우 간단합니다. 우선, 게임내 장소location에 대한 정보를 담을 전역변수 *note*를 만듭시다:
[CODE]

 이 변수는 세 장소에 대한 정보와 list를 포함하고 있습니다. *nodes* 변수는 우리에게 lookup key와 관련된 데이터 조각을 찾을 방법을 제공합니다. 이번 경우, 이 key는 장소의 이름입니다(living-room, garden, or attic), 그리고 data는 그 장소의 배경에 대한 text정보입니다. 이러한 종류의 구조를 association list라 부르거나, 짥게 alist라 부릅니다(alist는 7장에서 좀 더 자세히 다룹니다).

 *nodes*변수에 정의된 한가지 특이한 것이 있습니다: 다양한 장소의 정보 포함하였지만, 실제로는 어떤한 text 문자열을 포함하지 않았습니다. Common Lisp는 string 데이터형을 가졌기 때문에, 정보들을 따옴표를 사용해서 작성할 수 있습니다. 예를 들어, "You are in a beautiful garden. There is a well in front of you."로 쓸 수 있습니다. 대신, 저희는 이 정보들을 부호화 하기 위해 기본적인 데이터형식(symbol과 list)을 이용할 것입니다.

 저희는 왜 문자열을 이용하지 않을까요? 이번 장 시작부분에서 언급했듯이, text를 다루는 것은 근본적으로 컴퓨팅의 개념이 아닙니다. 저희는 게임 세상과의 상호관계에 기반하여 플레이어에게 보여지는 메시지를 복잡한 방법으로 다룰 것입니다. 대부분의 실제 프로그램에서는, 여러분이 생성하려는 output 정보는, 아마 단순한 text보다 더욱 더 복잡할 것입니다(HTML, PDF, or even richer graphical formats).

 시작함에 있어 여러분의 데이터구조의 근원이 output 형식에서 자유롭기에, 여러분의 코딩은 여러분의 프로그래밍 언어를 최대한 활용할 수 습니다. Lisp에서 symbol과 list를 다루는 것은 쉽기에, 대부분의 숙련된 Lisper는 가능한 그들의 소프트웨어 설계에 있어 이러한 데이터종류에 중점을 둡니다. 따라서, 저희 설계에 있어 문자열과 멀리 떨어져 있을 것입니다.(다음 장에서는, 이 list들과 symbol들을 적절하게 형식화된 text로 변환할 것입니다.)

NOTE
 Common Lisp는 list와 syombol들을 이러한 방법으로 문자열로 나타내도록 강요하지 않습니다. 만약 더 편리하다면, 문자열을 그대로 사용할 수 있습니다. (11장에서 특히, 이 책에서 문자열을 가지고 작업하는 예제를 볼 수 있습니다.) text를 조작함에 있어 list와 symbol을 매개체로 사용하는 것은, 분명 구식(old-school) Lisp 기술입니다. 그러나, list 연산은 Lisp에 있어 매우 근본적이기에, 이는 종종 매우 우아한 코드로 이끌어줍니다.


Describing the Location
 이제 게임 세계의 alist를 만들었으며, 장소를 기술할 명령어를 만들것입니다.  이를 위해, 저희는 key를 이용하여 list에서 정확한 item을 찾는 assoc함수를 사용할 것입니다:
[CODE]

 assoc를 사용하여, describe-location함수를 쉽게 만들 수 있습니다 :
[CODE]

 이 함수를 사용하기 위해, 장소와 *nodes* list를 넘겨줍니다:
[CODE]

 왜 장소를 기술하는 함수에서 *nodes*변수를 직접 참조하지 않을까요? 왜냐하면, 이 함수는 함수형 프로그래밍 형식으로 작성되었기 때문입니다. 이런 형식에선, 함수는 함수자체에서 정의된 인자parameters 혹은 변수variables 를 참조하며, (이번 경우에서는 장소에 대한 설명)값을 반환하는 것 외에는 아무것도 하지 않을 것입니다.

 "바깥 세상"에 있는 변수를 직접 참조하지 않으며 값을 반환하는 것 외에 다른 행동을 하지 않는 함수를 작성 함으로써, 여러분은 분리된 환경에서 쉽게 테스트를 할 수 있는 코드를 작성할 수 있습니다. 여러분은 가능한 이러한 형식으로 여러분의 Lisp함수를 작성해야 합니다. (14장에서 함수형 프로그래밍 형식에 대해 더욱 자세히 다룰 것입니다.)
[PIC]


Describing the Paths
 이제 저희는 각 장소에 대한 기본적인 정보를 가졌으며, 다른 장소로 가는 길에 대한 정보가 필요합니다. 플레이어가 지도에 있는 다른 장소로 이동할 수 있는 방법이 나온, 두번째 변수 *edges*를 만들 것입니다. (간선(edges)라는 용어를 사용하였는데, 이는 그래프의 노드를 연결하는 선에 대한 적절한 수학 용어이기 때문입니다.)
[CODE]

 이 구조를 이용하여, symbol시스템을 이용하여 주어진 간선에 대해 문자열로된 설명description을 만드는 describe-path 함수를 만들 것입니다.
[CODE]

 이 describe-path 함수는 매우 이상하게 보입니다 -데이터 조각과 같은 것들이 함수보다 많습니다. 이를 테스트해보고, 이것이 어떤 일을 하는지 밝혀봅시다.
[CODE]

 이 함수는 약간의 계산과정을 거친 정보를 포함하는 데이터 조각을 반환합니다. quasiquoting(외견상 quote)이라 불리는 이러한 Lisp의 기능은 자그마한 Lisp코드 조각을 포함하는 데이터 덩어리를 만들도록 도와줍니다.


How Quasiquoting Works
 quasiquoting을 사용하기 위해선, 코드를 데이터 모드로 바꿀때 따옴표가(single quote) ['] 아닌 역따옴표(backquote)[`]를 사용해야만 합니다. describe-path함수는 이와 같은 역따옴표를 갖고 있습니다.

 Lisp에서 따옴표와 역따옴표 모두 code조각을 data mode로 "전환"하지만, 역따옴표는 code 모드로 전환케하는 쉼표를 이용하여 unquoted 될 수 있습니다.

 약간의 상상력을 발휘한다면, 이를 이해할 수 있을 것입니다. 쉼표가 마치 역따옴표가 뒤집힌것저럼 보이지 않습니까? describe-path 함수가 하는 일에서 flip-flop이 무엇인지 나와 있습니다(코드mode에 있는 부분입니다):
[PIC]

 Lisp는 list를 가능한 쉽게 다룰수 있도록 노력합니다. 이제 저희는 text를 저장하기 위해 저희 프로그램이 어떻게 symbol list를 사용하는지를 이해할 수 있으며, 매우 간결하고 깔끔한 방법으로 문장을 만들기 위해 quasiquoting기능을 지지대로 사용할 수 있습니다.


Describing Multiple Paths at Once
 이제 describe-path함수를 이용하여 더 진보된 함수를 만들어 봅시다. 어떤 장소에는 이를 빠져나갈 수 있는 여러 갈래의 길이 있기에, edge data구조로부터 장소를 살펴봐서, 주어진 장소의 모든 edge들의 정보를 생성하는 함수가 필요합니다:
[CODE]

 이 함수는 Lisp세계에 익숙하지 않은 사람에겐 매우 이국적(exotic)인 명령어를 이용합니다. 많은 프로그래밍 언어들은 edges를 이용하기 위해 for-next loop와 같은 것을 이용하여, 각 경로를의 정보를 임시 변수에 넣습니다. Lisp는 좀더 우아한 접근법을 이용합니다. 이것이 동작하는 것을 살펴봅다 : 
[CODE]

 describe-paths 함수는 다음과 같은 과정을 거칩니다 : 
1. 관련된 간선들(edges)을 찾습니다
2. 간선을 정보(descriptionn)로 바꿉니다.
3. 정보를 묶습니다.

 세 과정이 각각 어떻게 동작하는지 살펴봅시다.


Finding the Relevant Edges
 우선, describe-paths함수의 내부는 매우 직관적입니다. living room으로부터 관련된 edges와 경로를 찾기 위해, edges list에서 장소를 둘러보려고 다시 assoc를 사용합니다:
[CODE]


Converting the Edges to Descriptions
 다음, edges가 정보desctiption으로 바뀝니다. 여기 이 부분을 수행하는 코드가 있습니다:
[CODE]

 mapcar는 Lisper가 자주 사용하는 함수입니다. 이것은 어떤 함수와 list를 취해, list의 각 맴버에 대해 함수를 적용합니다. 여기 예가 있습니다: 
[soruce]

 루트(sqrt)함수와 (1 2 3 4 5) list를 mapcar에 넣은 예제가 있습니다. 최종적으로, 이 함수는 list의 각 맴버에 sqrt를 적용하여 새로운 list를 만들어냄으로써, 원래 수에 루트를 한 새로운 list를 생성합니다.

 mapcar와 같은 다른 함수를 인자로 취하는 함수들은 매우 유용하며 Lisp의 특출한 기능입니다. 이와 같은 함수들을 higher-order 함수라 부릅니다.

 여기 다른 예가 있습니다:
[CODE]

 이번 소스 list는 작은 list두개를 포함하고 있습니다. car함수는 list에서 첫번째 항목을 찾기 때문에, mapcar가 작은 list 각각에서 첫번째 항목만 반환하여, foo와 baz가 됩니다. 여러분은 mapcar에서 함수 이름앞에  #'심볼들이 있어 혼란스러웠을지도 모릅니다. 이 심볼 조합은 함수 연산자를 짥게 쓴 것입니다. Lisp reader(여러분이 입력한 코드를 읽는 Lisp환경의 일부분)는 이전 예제를 다음과 같이 긴 버전으로 바꿀 것입니다:
[CODE]

 Common Lisp는 이와 같이 함수를 직접 값으로 참조하는 함수 연산자를 사용하기 위해 여러분을 필요로하는데, 함수의 이름이 프로그램에서 다른 항목의 이름과 충돌하여 예측하지 못한 에러를 유발시키기 때문입니다. 예를 들어, 다음과 같이 이전 예제보다 더 많은것을 추가 한다고 생각해 봅니다.
[CODE]

 이번 버전에서는, car 심볼은 서로 다른 두 의미를 지니고 있습니다. 첫번째 의미는 (3장에서 소계된)Lisp에 내장된 표준 함수입니다. 그러나, 우리는 또한 지역 변수에 car 라는 이름을 붙였습니다. 우리가 호출하는 mapcar에서 car앞에 #'를 붙였기 때문에, 지금 예기하고 있는 car와 혼동되지 않습니다.

 describe-paths함수를 다시 살펴 봅시다:
[CODE]

 함수를 받고 사용하도록 설계된 apply와 mapcar 함수가 append와 describe-path 함수를 값으로 받는 것을 주목하시기 바랍니다.

 Common Lisp는 함수이름은 변수이름과 다르게 다룹니다. 이는 하나의 이상의 변수와 하나 이상의 함수를 포함하는 다중이름공간(multiple namespaces)을 지녔습니다. (16장에서 이름공간에 대해 더 자세히 다룰것입니다.) 다른 유명한 Lisp방언 Scheme은,값으로 이용하기위해 함수 연산자로 함수를 나타내는것을 강요하지 않습니다.

 다른 말로 하자면, Scheme은 오직 함수와 변수를 위한 이름공간을 하나만 가집니다. 예를들어, Scheme에서는 여러분은 단순히 (map sqrt '(1 2 3 4 5))라고 작성하면 에러가 발생하지 않고 1부터 5까지 루트를 합니다(map은 mapcar의 Scheme버전입니다). 이러한 설계로 인해 Scheme에선 변수와 분리된 함수를 같은 코드 블럭에서 사용할 수 없습니다. Scheme의 이러한 설계의 이점(혹은 저주)중 하나는, 여러분의 관점(view of point)에 의존한다는 것입니다. 이름공간에 있어 이러한 차이점이 있기에, Scheme은 종종 Lisp-1이라 불리며, Common Lisp는 종종 Lisp-2로 언급됩니다.


Joining the Descriptions
 mapcar를 이용하여 모든 길과 edges의 description list를 생성한후, 그들을 하나의 정보로 묶을 필요가 있습니다. append 함수로 여러 list를 큰 list로 묶을 수 있습니다:
[CODE]

 append함수를 길의 정보description를 담은 list를, 한번에 모든것을 설명describe하는 하나의 list에 넣기 위해 사용할 것입니다. 문제는 append가 분리된 인자로 리스트를 다뤄야 한다는 것입니다. describe-paths에서는, 저희는 인자처럼 넘길 수 있는 분리된 object가 아니라 하나의 큰 리스트안에 리스트들을 가졌습니다. 이런, 우리는 그곳에 얼마나 많은 길이 있는지 모릅니다.

 apply 함수는 이러한 문제를 해결해줍니다. 이것에 함수와 object의 list를 넣으면, 이것은 list에 들어있는 항목들을 분리된 object로 여기고 주어진 함수에 넘깁니다. 예를들어, 중접된 '((mary had) (a) (little lamb)) list를 가지고 있으면, apply 함수는 append함수가 큰 list에 대해 동작하도록 만들때 필요한 필요한 약간의 연결고리(little bit of duct tape)를 추가할 것입니다:
[CODE]

WARNING 
 apply함수는 list에 있는 각 항목을 인자로 받기 때문에, 수천개의 매우 많은 list들을 받아 호출할때 문제가 생깁니다. REPL에서 call-arguments-limit 변수값을 확인함으로써 함수에 인자로 들어갈 수 있는 최대 수를 볼 수 있습니다. (근대 Lisp방언들은 인위적인 한계없이 어떤 크기의 list라도 허용하도록 설계되었습니다.)

 여러분은, 어떻게 apply가 describe-paths 함수를 하나의 지점에서 이끌 수 있는 모든 길을 서술하는 긴 리스트를 만드는게 가능케하는지 이해할 수 있습니다. 저희가 만든 path description list에 이와 동일한 접근법을 사용해 봅시다.
[CODE]

 이제 저희는 describe-paths함수의 각 부분을 살펴보았으며, 이것이 어떻게 동작하는지 정리해 봅시다:
[CODE]

 이 함수는 두 인자를 받습니다: 현재 게이머의 위치와, 게임 지도에서의 edgets/paths의 alist. 처음, 이것은 assoc를 이용하여 edge alist로부터 현제 위치를 살펴봅니다. assoc는 alist에서 key와 value를 반환하기 때문에, cdr을 호출하여 값만 취합니다. 다음으로, describe-path 함수를 우리가 찾은 각 edge들에 대응시키기 위해 mapcar를 사용합니다. 마지막으로, 모든 경로의 정보를 담은 list들을 append를 적용하여 하나의 list로 만듭니다.

 describe-path에서 사용한 프로그래밍 형식은 Lisp code에 있어 일반적입니다. 이것은, 주로 higher-order 함수를 이용하여, 길고 복잡한 데이터 덩어리를 통과시키고 몇몇 단계에서 이를 조작하는 것과 관련있습니다. 숙련된 Lisp 프로그래머가 되려면, 이러한 방식으로 작성된 읽기 편한 코드를 작성하기 위해 노력해야 합니다.


Describing Objects at a Specific Location
 저희 게임세상을 visualize하게 도와줄 마지막 code 조각을 만들기 위해, 주어진 장소의 바닥에 플레이어가 집고 사용할 수 있는 물건들을 정의할 필요가 있습니다.


Listing Visible Objects
 이 일을 하기 위해, 우선 물건 목록(a list of objects)을 만들어야 합니다 : 
[CODE]
[PIC]

 alist의 형태로 된 각 물건들의 위치를 추적하기 위해, *object-locations*라는 두번째 변수를 만들어야 합니다.
[CODE]

 다음으로, 물건들의 목록을 주어진 장소에서 보이게하는 함수를 작성합니다:
[CODE]

 objects-at함수는 labels 명령어를 사용하여 at-loc-p함수를 선언합니다. (labels 함수로 지역 함수를 선언할 수 있다는 것을 기억하시기 바랍니다.) at-loc-p 함수가 다른 곳에서 사용되지 않기에, 나머지 code에서 숨겨두기 위해 objects-at에서 선언하였습니다.

 at-loc-p 함수는 물체에 관한 symbol을 받아서, 물체가 위치 loc 에 있는지 여부를 따져 t나 nil을 반환합니다. obj-locs alist에서 물체를 찾음으로써 이러한 일을 합니다. 그 다음, 질의한 장소와 일치하는 장소가 어느곳인지 확인하기 위해 eq를 사용합니다.

 왜 이 함수의 이름은 at-loc-p일까요? 함수가 nil혹은 truth값을 반환할때, Common Lisp는 p를 함수의 이름 뒤에 붙이는 관습이 있습니다. 예를들어, (oddp 5)를 호출함으로써 5라는 숫자가 홀수인지 검사할 수 있습니다. 참/거짓 함수를 술어(predicate)라 부르듯이, p 문자를 사용합니다.

 예상할 수 있듯이, 나열된 마지막 줄에 있는 remove-if-not 함수는 passed-in 함수(이번 경우, at-loc-p)가 true를 반환하지 않으면 list에 있는 모든 것들을 없엡니다. 본질적으로, at-loc-p가 참을 만족하는 물건들로 구성된 filtered 물건 목록들을 반환합니다.

 object-at은 다음과 같이 행동합니다 :
[CODE]


Describing Visible Objects
 이제 저희는 주어진 장소에서 보이는 물건들을 설명하는 함수를 작성할 수 있습니다:
[CODE]

 여기에 있는, describe-objets는 우선 describe-obj함수를 만듭니다. 이 함수는 quasiquoting를 이용하여 바닥에 있는 물체에 대한 아름다운 문장을 생성합니다. 이 함수의 중요한 부분은 objects-at을 호출하여 현재 장소에 있는 물건을 찾는 것으로 구성되었고, 물건 목록을 describe-obj와 역어, 이러한 정보를 하나의 list에 추가하는 것입니다.

 describe-objects를 돌려 봅시다:
[CODE]

 완벽합니다!
[PIC]


Describing It All
 이제 우리는 이러한 함수들을 한데모아 하나의 쉬운 명령어 look으로 묶을것입니다. 게이머가 게임을 둘러보는 실제 명령어을 입력 할 수 있도록, look은 게이머의 현제 위치가 어딘지를 알아야만 합니다. 따라서, 게이머의 현재 위치를 알 수 있는 변수가 필요합니다. 이것을 *location*이라 부릅시다:
[CODE]

 *location*변수가 living-room symbol로 초기화 되었기 때문에, 게임이 시작되자 마자, 플레이어는 자기자신이 마법사의 집의 거실에 있다는 것을 발견할 것입니다. 이제, 우리의 모든 descriptor함수들을 호출 함으로써, 우리가 필요한 모든 것을 설명describe할 look 함수를 작성 할 수 있습니다:
[CODE]

 look함수는 (*location*, *nodes*, 기타등등과 같은)전역 변수 이름을 이용하기에, 플레이어는 게임 세계를 염두에둔 어떤 케케묵은(funky) 값을 넣을 필요가 없습니다. 그러나, 이는 또한 look함수가 함수형 프로그래밍 형식이 아님을 의미하는데, 그 이유는 함수형 프로그래밍 형식에서 함수는 오직 함수 자체에서 선언된 인자와 변수들만 참조하기 때문입니다. *location*는 전역 변수이므로, look함수는 저장된 값을 유지하지 않을 것입니다(*location* and its ilk are global variables, so the look function doesn’t hold up muster.).

 플레이어의 장소는 게임이 진행되는 동안 바뀌므로, look은 게임에서 매시간 마다 다른 일을 할 것입니다. 다른 말로 하자면, 여러분이 주변을 둘러봐서 보는것은 여러분이 있는 위치에 따라 달라질 것입니다. 대조적으로, 함수형 프로그래밍 형식의 함수는, 인자로 주어진 것이 같은 값인 동안 항상 같은 결과를 반환할 것입니다. describe-location, describe-paths, 그리고 describe-objects와 같이 이전에 저희가 만든 함수는, 인자가 동일하다면 어디서 호출되던지간에 항상 같은 것을 반환합니다.

 아레 look을 사용할때 보여지는 것이 나와 있습니다.
[CODE]
[PIC [look함수는 전역 변수를 읽으므로, 이건 함수형이 아냐!]]


Walking Around in Our World
 이제 저희는 게임 세상에 존재하는 것을 볼 수 있으며, 주변을 돌아다닐 수 있는 코드를 작성해 봅시다. (함수형 방식이 아닌) walk함수는 방향을 취해 우리가 그곳으로 가도록 해 줍니다:
[CODE]

 우선, 이 함수는 현재 위치를 이용하여 *edges* 항목에서 이용 가능한 이동 경로를 살펴 봅니다. 적절한 방향에 맞는 길을 찾기 위해 find함수를 사용합니다(find는 list에서 item을 찾아, 발견한 item을 반환합니다.). (서쪽, 윗층, 기타등등과 같은) 방향은 각 path의 cadr에 위치하며,  따라서 list에 있는 모든 경로의 cadr에 대해 방향이 일치하는 것을 찾기 위해서 find를 호출해야 합니다.

 keyword를 find 인자로 넣음으로써 이러한 일을 할 수 있습니다. Common Lisp에서 (find와 같은)많은 함수들은, 함수 호출이 끝날때 특별한 인자로 접근 할 수 있는 내장된 기능을 갖고 있습니다. 예를 들어 다음 코드는 list에서 cadr위치에 symbol y를 갖고 있는 첫번째 항목을 찾습니다:
[CODE]

 keyword 인자는 두 부분을 가지고 있습니다:
z 첫번째는 콜론(:)으로 시작하는 이름입니다(이번 경우에는 :key),(17장에서 이 콜론이 의미하는 것에 대하여 자세히 알아보겠습니다)
z 두번째는 이번 경우엔 #'cadr인 값입니다.

  같은 방식으로 walk함수에서 keyword 인자를 주어진 방향을 기반으로 적절한 길을 찾기 위해 사용할 것입니다. 올바른 길을 가졌다면, 결과를 next 변수에 저장합니다. if 표현식은 next가 값을(next 변수가 nil이 아닌지) 가졌는지 검사합니다. 만약 next가 값을 가졌으면, 적합한 위치이기 때문에 if는 플레이어의 위치를 조정합니다. look을 호출해서 새로운 장소의 description을 받아, 값으로 반환합니다. 게이머가 적합하지 않은 장소를 고른다면, look은 새로운 장소대신 경고(admonishment)를 생성합니다.

 여기 walk함수가 있습니다.
[CODE]

 방향 앞에 따옴표가 붙여있는데, 방향 이름이 data 모드에서 쓰여지기 위해 필요합니다. 게임 명령에 따옴표를 넣도록 게이머에게 강요하는 것은 어색한 일이지만, 저희가 만든 이 interface는 쉬운 디버깅과 개발을 위한 것입니다. 단순히 REPL에 게임 명령어를 넣기 때문에 이것을 "interface"라 부르기에는 많이 부족합니다. 다음 장에선, 우리는 text 게임을 위해 설계된 custom REPL을 이용하여 이러한 wart(사마귀)를 감내할만한 더 좋은 interface를 만들 것입니다.

NOTE
 따옴표를 방향 앞에 붙일 필요 없는 vanilla Lisp REPL을 만드는데 Lisp macro를 사용할 수 있으며, 예를들어, 단순히 (walk west)라 쓰면됩니다. 16장에서 macro에 관해 좀 더 배울것입니다.


Picking Up Objects
 다음, 물체를 집는 명령어를 만들어봅시다. 이를 수행하기 위해, 저희는 장소에 있는 물체들을 찾는데 사용할 *object-locations* 변수를 수정할 것입니다:
[CODE]

 pickup함수는 현재 장소 바닥에 물건이 놓여있는지 보는 member함수를 사용합니다. (member함수는 특정 물건이 물건 목록에 있는지 확인합니다). objects-at명령어를 이용하여 현재 위치에 있는 물건 목록을 생성합니다.

 물건이 현재 위치에 있다면, push명령어를 이용하여 물건과 새로운 장소로 구성된 *object-locations* 항목에 새로운 물건을 집어넣습니다. 새로운 장소는 플레이어의 몸에 해당하는, body가 될 것입니다.

 push 명령어는 단순히 새로운 물건을 list 앞에 추가합니다. 예를들어, list 1 2 3에 숫자 7을 더하는 예제가 있습니다.
[CODE]

 setf를 기반의 내장된 push 명령어는 기본적이며 편리한 함수입니다. 예를 들어, push 명령어를  (setf *foo* (cons 7 *foo*)) 로 바꿔도 같은 결과를 얻을 수 있습니다. push를 쓰는게 훨신 편합니다.

 물건에 대한 새로운 장소를 *object-locations* alist에 넣는것은 조금 이상하게 보여집니다. 물건의 예전 장소를 지우지 않고, 단지 새로운 것만 추가하는데, 이것이 의미하는 것은 *object-locations*는 하나의 물건에 대해 많은 항목들을 포함하며, 이제 이 list는 의문속에서 물체에 대한 두개의 저장된 장소를 갖습니다. 다행히도, (objects-at 명령어를 통해)주어진 장소에서 물건을 찾는 assoc 명령어는 항상 list에서 첫번째 항목을 반환할 것입니다. 그러므로 push 명령어를 이용하는 것은, assoc 명령어를 만약 주어진 key에 해당하는 값이 list에 있으면 다른 걸로 바꾸도록 합니다.

 이 방법에서 push와 assoc 명령어를 같이 사용함으로 alist에 있는 값은 바뀐다는걸 예상할 수 있으며, 이전 값은 여전히 유지됩니다. 새로운 값에 의해 이전 값이 뒤로 물러나므로, 이전 값에 대한 기록이 유지됩니다. push/assoc 표현방식(idiom)은 Lisper에 의해 일반적으로 쓰이는 기법입니다.

 이제 living room으로 돌아와서 물건을 집어 봅시다:
[CODE]

 해냈습니다. 우리는 whiskey를 갖고 있으며, 이것이 의미하는 것은 이제 저희세계에 있는 물건들을 집을 수 있다는 것입니다.


Checking Our Inventory
 마지막으로, 플레이어가 보유하고 있는 물건 항목을 볼 수 있는 함수를 만들어 봅시다:
[CODE]

 이 inventory 함수는 지정한 장소로부터 물건 항목을 받기 위해 objects-at함수를 이용합니다. 어떤 장소에서 찾을 수 있을까요? 기억하실지 모르겠지만, 게이머가 물건을 집었을 때 이것의 장소를 'body로 바꾸었습니다: 이것이 질의query에 사용할 장소입니다.

 inventory함수를 수행해 봅시다:
[CODE]

 보시다싶이, 지금 하나의 물건만을 가지고 있습니다: 방금 집었던 whiskey bottle.

 바로 이겁니다! 이제 저희는 text adventure 게임을 위한 기본 engine을 가졌습니다. look으로 세계를 둘러 볼수 있고; walk로 장소를 이동할 수 있으며; pickup으로 물건을 집을수 있습니다; 그리고 inventory로 물건항목을 확인해 볼 수 있습니다.

 물론, 게임에 사용할 만큼 많이 가지고 있진 않는데, 우리가 찾은 물건으로 아무것도 하지 못하기 때문입니다. 17장에서 실제로 물체를 다루는 mechanism을 추가할 것입니다. 다음 장에서는, 저희 게임의 user interface를 향상시키는데 중점을 둘 것입니다. REPL이 저희 게임 prototyping에 적합하지만, custom text game interface를 추가하는 것은 게이머에게 좀더 좀더 원할한 게임플레이를 제공해 줄 것입니다.


What You’ve Learned
 이번 장에선, text advanture 게임을 위한 간단한 엔진을 다루었습니다. 이러한 과정을 통해, 다음과 같은 것을 배웠습니다:
z 게임 세상은 플레이어가 방문할 수 있는 node와, 장소 사이의 길을 위한 edge로 구성된 수학적 그래프로 나타낼 수 있다.
z 이 node를 연관 리스트(alist)라 불리는 *nodes*에 저장 할 수 있다. alist는 여러분이 이것의 이름을 사용하여 node/place의 정보를 살펴 볼 수 있게 합니다. 저희 게임에서의 우리가 저장하는 속성은 각 node/place의 정보입니다.
z key(저희 예제에서 장소의 이름)로 alist 안을 살펴 보기 위해 assoc함수를 이용한다.
z Quasiquoting은 작은 컴퓨터 코드의 비트를 더 큰 데이터 조각에 넣는 것을 허용케하는 기술이다.
z 몇몇 Lisp함수들은 다른 함수를 인자로 받아 들인다. 이러한 것들을 higher-order함수라 부릅니다. Common Lisp에서 mapcar함수는 가장 유명한 higher-order 함수입니다.
z alist에서 값을 변경하려면, 새로운 항목을 list에 넣어야 한다. assoc함수에 의해 최근 변경된 값만이 보고됩니다.